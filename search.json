[{"title":"算法刷题记录DAY3","url":"/2024/08/08/算法刷题记录DAY3/","content":"\n# 位运算的奇巧淫技\n\n- 判断奇偶数\n`x&1=1`为奇数，`x&1=0`为偶数\n\n- 获取二进制位是1还是0\n左移后和1作&运算\n\n- 交换两个整数变量的值\n```cpp\nx=x^y;\ny=x^y;\nx=x^y;\n```\n- 不用判断语句，求整数的绝对值\n\n## 异或性质\n\n![](./算法刷题记录DAY3/1723186263238.png)\n\n# 找出唯一成对的数\n\n![](./算法刷题记录DAY3/1723186362438.png)\n\n> 思路：可以利用set，也可以单独开一个长度1000的数组，但是都不符合题意；这个时候可以利用`^`运算：\n```\nA^A=0;\nA^A^B^C^C=B;\nA^A^A=A;\n```\n即奇数个一样的数异或等于它本身。\n\n```cpp\nint slove(vector<int> &nums){\n    int n=1000;\n    int number=0;\n    number=number^nums[0];\n    for(int i=1;i<=n;i++){\n        number=number^i;\n        number=number^nums[i];\n    }\n    return number;\n}\n```\n\n# 二进制中1的个数\n\n![](./算法刷题记录DAY3/1723187280829.png)\n\n> 思路1：获取到该数中二进制的每一位，计算为1的个数\n\n```cpp\nint slove(int n){\n    int ans=0;\n    while(n){\n        ans+=(n&1);\n        n>>1;\n    }\n    return ans;\n}\n```\n\n> 思路2：x&(x-1)可以将x中最低位的1变成0，循环操作即可，循环次数即为1的个数\n\n```cpp\nint solve(int n){\n    int ans=0;\n    while(n){\n        n=n&(n-1);\n        ans++;\n    }\n    return ans;\n}\n```\n\n# 是不是2的整数次方\n\n用1条语句判断一个整数是不是2的整数次方\n\n> 思路：x&(x-1)之后可以将x最低位的1变成0，如果x是2的整数次方，则x二进制中只有一个1，与x-1作&运算之后将变为0；\n\n```cpp\nbool slove(int n){\n    return x&(x-1) ==0 ;\n}\n```\n\n# 将整数的奇偶位互换\n\n> 思路：![](./算法刷题记录DAY3/1723188154647.png)\n![](./算法刷题记录DAY3/1723188213237.png)\n然后将c左移一位、d右移一位，拼接在一起即可\n\n```cpp\nint slove(int n){\n    int a=0x55555555;\n    int b=0xaaaaaaaa;\n    int c=a&n;\n    int d=b&n;\n    return (c<<1)|(d>>1);\n}\n```\n\n# 0~1间浮点实数的二进制表示\n\n![](./算法刷题记录DAY3/1723188474391.png)\n\n> 思路：依次小数*2取整数位即可。\n\n```cpp\n#include<string>\nvoid slove(double a){\n    string ans=\"0.\";\n    int count=0;\n    while(a>0&&count<32){\n        a=a*2;\n        if(a>=1) {\n            ans+=\"1\";\n            a-=1;\n        }else{\n            ans+=\"0\";\n        }\n        count++;\n    }\n    if(a>0) cout<<\"ERROR\"<<endl;\n    else cout<<ans<<endl;\n}\n```\n\n# 出现K次与出现1次\n\n![](./算法刷题记录DAY3/1723188840312.png)\n\n> 思路：k个相同的数作k进制下的不进位加和结果为0，所以只需要这些数全部作k进制下的不进位加和，将结果还原即为答案。\n\n```cpp\nint slove(vector<int> &nums,int k){\n    vector<vector<int>> numskradix(nums.size(),vector<int>());\n    //求每个数的k进制表示\n    int maxlen=0;\n    for(int i=0;i<nums.size();i++){\n        int t=nums[i];\n        while(t){\n            numskradix[i].push_back(t%k);\n            t=t/k;\n        }\n        maxlen=max(maxlen,numskradix[i].size());\n    }\n\n    //计算\n    vector<int> arr(maxlen,0);\n    for(int i=0;i<maxlen;i++){\n        for(int j=0;j<nums.size();j++){\n            if(i<numskradix[j].size()){\n                arr[i]=(arr[i]+numskradix[j][i])%k;\n            }\n        }\n    }\n\n    //复原\n    int ans=0;\n    int m=1;\n    for(int i=0;i<maxlen;i++){\n        ans+=arr[i]*m;\n        m=m*k;\n    }\n    return ans;\n}\n```\n","categories":["算法","位运算"]},{"title":"sql递归查询","url":"/2024/08/07/sql递归查询/","content":"\n# 前言\n\n之前在南大夏令营笔试遇到一题SQL递归查询的，当时空在那，现在补一下\n\n# MySQL with Recursive\nMySQL with Recursive是一种基于递归思想的MySQL查询方式，可以实现对数据的递归查询和处理，返回符合条件的数据。在MySQL 8.0版本中，该功能被正式引入。\n\n> WITH RECURSIVE 语句包含两部分：\n> - 递归部分: 定义了如何递归查询数据;\n> - 终止条件部分: 定义了递归查询何时停止。\n\n## 语法\n\n```sql\nWITH RECURSIVE recursive_query_name (col1, col2, ..., coln) AS (\n    -- 递归部分\n    SELECT \n\t\t\tinitial_query_result_col1, \n\t\t\tinitial_query_result_col2, \n\t\t\t...,\n\t\t\tinitial_query_result_coln\n    FROM initial_query\n    UNION ALL\n    SELECT \n\t\t\trecursive_query_result_col1,\n\t\t\trecursive_query_result_col2, \n\t\t\t..., \n\t\t\trecursive_query_result_coln\n    FROM recursive_query_name, recursive_query\n    WHERE recursive_query_condition\n)\n-- 终止条件部分\nSELECT * FROM recursive_query_name ;\n```\n\n![](https://i-blog.csdnimg.cn/blog_migrate/61f13906cb550c4b1ca419fbd59a3f5e.png)\n\n### 案例\n\n![](https://i-blog.csdnimg.cn/blog_migrate/642511f78aaf8bff51222cf6d7ec605e.png)\n[](https://i-blog.csdnimg.cn/blog_migrate/04ecb3374db9d50e65baea1384bb6cbc.png)\n\n`SELECT p.* FROM course_category p WHERE p.id = '1' ` 这个sql结果赋值给t1;然后通过这个初次查询结果的t1表继续去跟course_category联查,符合where条件的再赋值给t1;直至没有符合条件的;最后需要的数据都在t1表里了,只需要查询t1表即可;\n\n\n# 参考\n[CSDN](https://blog.csdn.net/djdjfjf1/article/details/134808935)\n","categories":["sql"]},{"title":"codeforces-964-div4","url":"/2024/08/07/codeforces-964-div4/","content":"\n# 前言\n\n本想先拿div4的难度入个门，没想到只会签到题，还是太菜了。。。\n\n# A. A+B\n\n![](./codeforces-964-div4/1723016317231.png)\n\n```cpp\n#include<iostream>\n\nusing namespace std;\n\nint main(){\n    int t;\n    cin>>t;\n    int a;\n    while(t--){\n        cin>>a;\n        cout<<a/10+a%10<<endl;\n    }\n    return 0;\n}\n```\n\n# B. Card Game\n\n![](./codeforces-964-div4/1723016430524.png)\n![](./codeforces-964-div4/1723016563903.png)\n\n> 思路：情况很少，枚举出来就行\n\n```cpp\n#include<iostream>\n\nusing namespace std;\n\nint func(int a1,int a2,int b1,int b2){\n    int ans=0;\n    //a1-b1 a2-b2\n    if(a1>b1&&a2>b2) ans+=2;\n    else if(a1>b1&&a2==b2) ans+=2;\n    else if(a1==b1&&a2>b2) ans+=2;\n\n    //a1-b2 a2-b1\n    if(a1>b2&&a2>b1) ans+=2;\n    else if(a1>b2&&a2==b1) ans+=2;\n    else if(a1==b2&&a2>b1) ans+=2;\n    return ans;\n}\nint main(){\n    int t;\n    cin>>t;\n    int a1,a2,b1,b2;\n    while(t--){\n        cin>>a1>>a2>>b1>>b2;\n        cout<<func(a1,a2,b1,b2)<<endl;\n    }\n    return 0;\n}\n```\n\n# C. Showering\n\n![](./codeforces-964-div4/1723016780857.png)\n![](./codeforces-964-div4/1723016998339.png)\n\n> 思路：计算区间间距，大于s就可以\n\n```cpp\n#include<iostream>\n#include<vector>\n\nusing namespace std;\nbool func(int n,int s,int m,vector<pair<int,int>> &nums){\n    int before=0;\n    if(m-nums[n-1].second>=s) return true;\n    for(int i=0;i<n;i++){\n        if(nums[i].first-before>=s) return true;\n        else{\n            before=nums[i].second;\n        }\n    }\n    return false;\n}\nint main(){\n    int t;\n    cin>>t;\n    int a;\n    int n,s,m;\n    while(t--){\n        cin>>n>>s>>m;\n        vector<pair<int,int>> nums(n);\n        for(int i=0;i<n;i++){\n            cin>>nums[i].first>>nums[i].second;\n        }\n        if(func(n,s,m,nums)){\n            cout<<\"YES\"<<endl;\n        }else{\n            cout<<\"NO\"<<endl;\n        }\n    }\n    return 0;\n}\n```\n\n# D. Slavic's Exam\n\n![](./codeforces-964-div4/1723016954808.png)\n![](./codeforces-964-div4/1723017090563.png)\n\n> 思路：\n\n\n# E. Triple Operations\n\n![](./codeforces-964-div4/image.png)\n\n> 思路：\n\n\n# F. Expected Median\n\n![](./codeforces-964-div4/1723017618441.png)\n\n![](./codeforces-964-div4/1723017667456.png)\n\n> 思路：\n\n\n# G1. Ruler (easy version)\n\n![](./codeforces-964-div4/1723017842288.png)\n![](./codeforces-964-div4/1723017873538.png)\n![](./codeforces-964-div4/1723017899752.png)\n\n> 思路：\n\n# G2. Ruler (hard version)\n\n![](./codeforces-964-div4/1723017988966.png)\n![](./codeforces-964-div4/1723018030170.png)\n![](./codeforces-964-div4/1723018053558.png)\n\n> 思路：\n\n","categories":["算法"]},{"title":"数学","url":"/2024/08/05/数学/","content":"\n[参考](https://www.bilibili.com/video/BV1Ei4y137gj/?spm_id_from=333.337.search-card.all.click&vd_source=1e4dde82b17a014f17a01a1aada081b1)\n\n# 集卡片 [原题链接](http://acm.hdu.edu.cn/showproblem.php?pid=1099)\n![](./数学/image.png)\n\n> 关键思想：知道此处期望是概率的倒数即可，<br>\n> 比如有5张卡片，<br>\n- 第一步你获得想要卡片的概率是1，倒数为1；<br>\n- 第二步你获得想要卡片的概率是4/5，倒数为5/4；<br>\n- 第三步你获得想要卡片的概率是3/5，倒数为5/3；<br>\n……累加即为结果\n\n```cpp\n#include <iostream>\nusing namespace std;\n\ntypedef long long ll;\n\nll GCD(ll a,ll b){\n    if(a==0||b==0)return 1; \n    return a%b==0?b:GCD(b,a%b);\n}\n\nint digits(ll n){\n    int d=0;\n    while(n){\n        n/=10;\n        d++;\n    }\n    return d;\n}\n\nint main(){\n    int n;\n    ll num,deno,inte;//分子分母整数部分 \n    while(scanf(\"%d\",&n)!=EOF){\n        num=0,deno=1,inte=1;\n        for(int i=1;i<=n-1;i++){ \n            num=num*i+deno*n;\n            deno=deno*i;\n            ll gcd=GCD(num,deno);//约分 \n            num/=gcd;\n            deno/=gcd; \n        } \n        inte+=num/deno;//整数部分 \n        num=num%deno;//分数部分 \n        if(num==0)printf(\"%lld\\n\",inte);//若能整除 \n        else{//格式化输出 \n            for(int i=0;i<=digits(inte);i++)printf(\" \"); \n            printf(\"%lld\\n\",num);\n            printf(\"%lld \",inte);\n            for(int i=0;i<digits(deno);i++)printf(\"-\");\n            printf(\"\\n\");\n            for(int i=0;i<=digits(inte);i++)printf(\" \");\n            printf(\"%lld\\n\",deno);\n        }\n\n    }\n    return 0;\n}\n```\n\n[来源](https://www.cnblogs.com/G-M-WuJieMatrix/p/7400401.html)\n\n# 随机数生成器\n\n![](./数学/1722852855899.png)\n\n> 使用","categories":["算法","数学"]},{"title":"力扣热题100","url":"/2024/08/04/力扣热题100/","content":"# 两数之和\n> easy\n\n![](./力扣热题100/image.png)\n\n> 用哈希存储遍历过的元素即可\n\n```cpp\n#include<vector>\n#include<map>\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        vector<int> ans;\n        map<int,int> mp;\n        for(int i=0;i<nums.size();i++){\n            if(mp[target-nums[i]]!=0){\n                ans.push_back(mp[target-nums[i]]-1);\n                ans.push_back(i);\n                return ans;\n            }else{\n                mp[nums[i]]=i+1;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n# 字母异位词分组\n> medium\n\n![](./力扣热题100/1722785853405.png)\n\n> 一开始的思路是计算每个字符串的哈希值，两个异位词的哈希值相同，但是想不出怎么计算比较合适，于是改成直接排序字符串\n\n```cpp\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<map>\n\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        vector<vector<string>> ans;\n        map<string,int> mp;\n        for(int i=0;i<strs.size();i++){\n            string ss=sort_(strs[i]);\n            auto fd=mp.find(ss);\n            if(fd!=mp.end()){\n                int index=mp[ss];\n                ans[index].push_back(strs[i]);\n            }else{\n                mp[ss]=ans.size();\n                ans.push_back(vector<string>(1,strs[i]));\n            }\n        }\n        return ans;\n    }\n\n    string sort_(string str){\n        sort(str.begin(),str.end());\n        return str;\n    }\n};\n```\n\n> 官方题解中另一种方法是用字符和该字符出现的次数拼接成字符串作为哈希map的键，感觉也大差不差\n![](./力扣热题100/1722787345351.png)\n\n```java\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        Map<String, List<String>> map = new HashMap<String, List<String>>();\n        for (String str : strs) {\n            int[] counts = new int[26];\n            int length = str.length();\n            for (int i = 0; i < length; i++) {\n                counts[str.charAt(i) - 'a']++;\n            }\n            // 将每个出现次数大于 0 的字母和出现次数按顺序拼接成字符串，作为哈希表的键\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < 26; i++) {\n                if (counts[i] != 0) {\n                    sb.append((char) ('a' + i));\n                    sb.append(counts[i]);\n                }\n            }\n            String key = sb.toString();\n            List<String> list = map.getOrDefault(key, new ArrayList<String>());\n            list.add(str);\n            map.put(key, list);\n        }\n        return new ArrayList<List<String>>(map.values());\n    }\n}\n```\n\n> 作者：[力扣官方题解](https://leetcode.cn/problems/group-anagrams/solutions/520469/zi-mu-yi-wei-ci-fen-zu-by-leetcode-solut-gyoc/)\n来源：力扣（LeetCode）\n\n# 最长连续序列\n\n![](./力扣热题100/1723019783568.png)\n\n> 思路：先用set存好数，然后用每个数去匹配，这样大概是$O(n^2)$复杂度，改进：遍历set中的数，每对一个数进行匹配，当前数num的前驱num-1不能在set中。\n\n```cpp\n#include<vector>\n#include<set>\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        set<int> st;\n        int n=nums.size();\n        for(int i=0;i<n;i++){\n            st.insert(nums[i]);\n        }\n        int ans=0;\n        for(int num:st){\n            if(!st.count(num-1)){\n                int cur=num;\n                int len=1;\n                while(st.count(cur+1)){\n                    cur++;\n                    len++;\n                }\n                ans=max(ans,len);\n            }\n        }\n        return ans;\n    }\n};\n```\n\n# 盛最多水的容器\n\n> medium\n\n![](./力扣热题100/1723020925708.png)\n![](./力扣热题100/1723020968959.png)\n![](./力扣热题100/1723021071234.png)\n\n> 思路：双指针法，从两边向中间遍历，每次移动那个height值更小的位置指针，因为如果移动更大的指针，则之后面积一定会比当前的面积更小。**短板效应**\n\n```cpp\nclass Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        int left=0;\n        int right=height.size()-1;\n        int ans=0;\n        int s=0;\n        while(left<right){\n            s=(right-left)*min(height[left],height[right]);\n            ans=max(ans,s);\n            if(height[left]<height[right]) left++;\n            else right--;\n        }\n        return ans;\n    }\n};\n```\n\n# 三数之和\n\n> medium\n\n![](./力扣热题100/1723181610096.png)\n![](./力扣热题100/1723181637470.png)\n\n> 思路：","categories":["算法","Leetcode热题100"]},{"title":"算法刷题记录DAY2","url":"/2024/08/04/算法刷题记录DAY2/","content":"\n# 华为2016研发工程师编程题 [牛客网](https://www.nowcoder.com/exam/test/81883766/detail?pid=710802&examPageSource=Company&testCallback=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fcompany%3FcurrentTab%3Drecommand%26jobId%3D100%26selectStatus%3D0%26tagIds%3D239&testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91)\n\n## 删数\n![](./算法刷题记录DAY2/image.png)\n\n> 思路：用计数器计数即可\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\nvoid solve(int n) {\n    stack<int> stk;\n    vector<bool> nums(n, true);\n    int count = 0;\n    int index = 0;\n    while (stk.size() < n) {\n        if (nums[index] && count == 2) {\n            nums[index] = false;\n            stk.push(index);\n            count = 0;\n            index = (index + 1) % n;\n        } else if (!nums[index]) {\n            index = (index + 1) % n;\n        } else {\n            index = (index + 1) % n;\n            count++;\n        }\n    }\n    cout << stk.top() << endl;\n}\nint main() {\n    int n;\n    while(cin>>n){\n        solve(n);\n    }\n    return 0;\n}\n// 64 位输出请用 printf(\"%lld\")\n```\n\n## 字符集合\n![](./算法刷题记录DAY2/image1.png)\n\n> 思路：用set记录之前出现过的字符即可\n\n```cpp\n#include <iostream>\n#include <set>\n#include <string>\nusing namespace std;\n\nvoid solve(string &s){\n    set<char> st;\n    for(int i=0;i<s.length();i++){\n        if(st.count(s[i])) continue;\n        else{\n            st.insert(s[i]);\n            cout<<s[i];\n        }\n    }\n    cout<<endl;\n}\nint main() {\n    string s;\n    while(cin>>s){\n        solve(s);\n    }\n    return 0;\n}\n// 64 位输出请用 printf(\"%lld\")\n```\n\n## 数独\n![](./算法刷题记录DAY2/image3.png)\n\n> 思路：使用回溯法，一行一行的进行搜索<br>\n注意：不需要用数组存储该位置可以放的数\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <set>\n#define SIZE 9\n\nusing namespace std;\n\nvector<vector<int>> map(SIZE, vector<int>(SIZE));\n// int cnt = 0;\nint notzerocnt = 0;\nbool check(int row, int col, int num)\n{\n    for (int i = 0; i < SIZE; i++)\n    {\n        if (map[row][i] == num || map[i][col] == num)\n            return false;\n    }\n    int rb = (row / 3) * 3;\n    int cb = (col / 3) * 3;\n    for (int i = rb; i < rb + 3; i++)\n    {\n        for (int j = cb; j < cb + 3; j++)\n        {\n            if (map[i][j] == num)\n                return false;\n        }\n    }\n    return true;\n}\nvoid print()\n{\n    for (int i = 0; i < 9; i++)\n    {\n        for (int j = 0; j < 9; j++)\n        {\n            cout << map[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\nvoid backtrace(int n, int notzerocnt)\n{\n    int row = n / 9;\n    int col = n % 9;\n    if (n == 81 || notzerocnt == 81)\n    {\n        print();\n        return;\n    }\n    if (map[row][col] != 0)\n    {\n\n        if (col < SIZE - 1)\n        {\n            backtrace(++n, notzerocnt);\n        }\n        else\n        {\n            backtrace(++n, notzerocnt);\n        }\n    }\n    else\n    {\n        for (int i = 1; i <= SIZE; i++)\n        {\n\n            if (check(row, col, i))\n            {\n                map[row][col]=i;\n                backtrace(n+1, notzerocnt+1);\n                map[row][col]=0;\n            }\n        }\n    }\n}\nint main()\n{\n\n    for (int i = 0; i < SIZE; i++)\n    {\n        for (int j = 0; j < SIZE; j++)\n        {\n            cin >> map[i][j];\n            if (map[i][j] != 0)\n                notzerocnt++;\n        }\n    }\n    backtrace(0, notzerocnt);\n}\n```","categories":["算法"]},{"title":"CSAPP-Lab1-data","url":"/2024/08/04/CSAPP-Lab1-data/","content":"\n\n# 实验准备\n\n> 了解! ~ & ^ | + << >> 运算符\n**&（按位与）、|（按位或）、^（按位异或）、~（按位取反）和<<（左移）、>>（右移）都是直接在整数的补码表示上进行运算。**\n\n1. ! 运算符\n    - 若对布尔值进行运算非false则true，非true则false。\n    - 若对整数进行运算，C语言中的整数可以直接在逻辑表达式中隐式地转换为布尔值，其中非零整数转换为 true，零整数转换为 false，计算规则同上。\n2. ~ 运算符 \n    对操作数的每一位进行取反。在补码表示中，按位取反然后加1等价于取一个数的二进制补码。但是，~ 运算符本身不涉及补码转换，它只是简单地翻转每一位。\n3. & 运算符\n\t对两个操作数的对应位进行逻辑与操作。由于操作数已经是补码形式，直接进行位运算。\n4. ^ 运算符\n\t对两个操作数的对应位进行逻辑异或操作。与 & 类似，直接在补码形式上进行。\n5. | 运算符\n\t对两个操作数的对应位进行逻辑或操作，同样直接在补码形式上进行。\n6. \\+ 运算符\n\t加法运算符在补码表示上直接进行。如果操作数是整数，它们已经是补码形式，加法运算会考虑溢出。\n7. << 、>>运算符\n    - 左移运算符将操作数的所有位向左移动指定的位数，空出的位填充为0。\n    - 右移运算符将操作数的所有位向右移动指定的位数。\n        - 逻辑右移用0填充空出的位；\n        - 算术右移用符号位填充空出的位。\n\n\n# 1-bitXor\n\n> 要求：\n bitXor - x^y using only ~ and & \n Example: bitXor(4, 5) = 1\n Legal ops: ~ &\n Max ops: 14\n Rating: 1\n \n 代码\n```c\nint bitXor(int x, int y) {\n  int ans=~((~((~x)&y))&(~(x&(~y))));\n  return ans;\n}\n```\n\n# 1-tmin\n\n> 要求：\ntmin - return minimum two's complement integer \nLegal ops: ! ~ & ^ | + << >>\nMax ops: 4\nRating: 1\n\n代码：\n```c\nint tmin(void) {\n  int ans=1<<31;\n  return ans;\n}\n```\n\n# 2-isTmax\n\n> 要求：\n  isTmax - returns 1 if x is the maximum, two's complement number,\n  and 0 otherwise \n  Legal ops: ! ~ & ^ | +\n  Max ops: 10\n \n 代码：\n```c\nint isTmax(int x) {\n  int plus1=x+1;\n  plus1=(plus1^x);\n  int tmp=((plus1>>31)&1);\n  int ans=tmp&(!(x>>31)&1);\n  return ans;\n}\n```\n\n# 2-allOddBits\n\n> 要求：\nallOddBits - return 1 if all odd-numbered bits in word set to 1\n  where bits are numbered from 0 (least significant) to 31 (most significant)\n  Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1\n  Legal ops: ! ~ & ^ | + << >>\n  Max ops: 12\n  Rating: 2\n\n```c\nint allOddBits(int x) {\n  /*\n   */\n  int t1=(x&0xAA)^0xAA;\n  int t2=((x>>8)&0xAA)^0xAA;\n  int t3=((x>>16)&0xAA)^0xAA;\n  int t4=((x>>24)&0xAA)^0xAA;\n  int t=!(t1+t2+t3+t4);\n  return t;\n}\n```\n","categories":["计算机基础","CSAPP"]},{"title":"CSAPP-Lab0-环境搭建","url":"/2024/08/04/CSAPP-Lab0-环境搭建/","content":"\n# 使用工具\nWindows 11，WSL，VScode，GCC编译套装\n\n# 安装步骤\n## WSL安装Ubuntu\n\n参考：**[安装WSL](https://blog.csdn.net/weixin_57367513/article/details/135001273)**\n\n## VScode配置WSL插件\nvscode搜索如下插件进行安装：![alt text](./CSAPP-Lab0-环境搭建/image.png)\n参考：**[安装WSL插件](https://blog.csdn.net/yanbober/article/details/138245581)**\n\n## 安装GCC编译套装\n打开WSL命令行窗口，输入 `sudo apt-get update` \n然后输入下面三条指令：\n```shell\nsudo apt-get install build-essential\nsudo apt-get install gcc-multilib\nsudo apt-get install gdb\n```\n参考：**[GCC编译套装的安装](https://blog.csdn.net/qq_45703010/article/details/120897185)**","categories":["计算机基础","CSAPP"]},{"title":"树","url":"/2024/08/04/树/","content":"\n\n# 树的定义\n\n![](树/Untitled.png)\n\n![](树/Untitled%201.png)\n\n![](树/Untitled%202.png)\n\n![](树/Untitled%203.png)\n\n## 树的性质\n\n![](树/Untitled%204.png)\n\n# 二叉树\n\n二叉树是另一种树形结构，其特点是每个结点至多只有两棵子树( 即二叉树中不存在度大于2的结点)，并且二叉树的子树有左右之分，其次序不能任意颠倒。\n\n![](树/Untitled%205.png)\n\n![](树/Untitled%206.png)\n\n## 满二叉树\n\n每个节点要么是叶节点，要么是有两个子节点的节点\n\n## 完全二叉树\n\n每一层都从左往右尽量铺满\n\n## 二叉树的实现\n\n```java\nimport java.util.*;\n\n/**\n * 二叉检索树：对任意一个节点，\n *      左子树上的节点的值均小于该节点的值\n *      右子树上的节点的值均不小于该节点的值\n */\npublic class MyBST<K extends Comparable<K> ,V> implements BST<K,V>{\n\n    private BinNode<K,V> root;\n    public MyBST(){\n        root=null;\n    }\n    @Override\n    public void insert(K key, V value) {\n        if (key==null){\n            try {\n                throw new Exception(\"key is null.\");\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return;\n        }\n        root=insertHelper(key,value,root);\n    }\n\n    private BinNode<K,V> insertHelper(K key,V value,BinNode<K,V> root){\n        if (root==null){\n            return new BinNode<>(key,value);\n        }\n        int res=root.getKey().compareTo(key);\n        if (res<=0){//root更小 插入右子树\n            root.setRight(insertHelper(key,value,root.getRight()));\n        }else{\n            root.setLeft(insertHelper(key,value,root.getLeft()));\n        }\n        return root;\n    }\n\n    @Override\n    public V remove(K key) {\n        if (key==null) {\n            try {\n                throw new Exception(\"key is null.\");\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n        V val=search(key);\n        if (val!=null) removeHelper(key,root);\n        return val;\n    }\n\n    private BinNode<K,V> findMin(BinNode<K,V> root){\n        if (root==null) return null;\n        if (root.getLeft()==null) return root;\n        return findMin(root.getRight());\n    }\n\n    private BinNode<K,V> removeHelper(K key,BinNode<K,V> root){\n        if (root==null) return null;\n        int res=root.getKey().compareTo(key);\n        if (res>0){\n            root.setLeft(removeHelper(key,root.getLeft()));\n        } else if (res<0) {\n            root.setRight(removeHelper(key,root.getRight()));\n        }else{\n            //恰好是这个节点需要删除\n            V val=root.getValue();\n            if (root.getLeft()==null){\n                root=root.getRight();\n            }else if (root.getRight()==null){\n                root=root.getLeft();\n            }else{\n                //找到右子树中最大的节点\n                BinNode<K, V> min = findMin(root);\n                root.setKey(min.getKey());\n                root.setValue(min.getValue());\n                root.setRight(min);\n            }\n        }\n        return root;\n    }\n\n    private void deleteMaxHelper(BinNode<K,V> root){\n        if (root==null) return;\n        if (root.getRight()==null) return;\n        if (root.getRight().getRight()==null){\n            root.getRight().setRight(null);\n        }else{\n            deleteMaxHelper(root.getRight());\n        }\n    }\n    @Override\n    public V search(K key) {\n        if (key==null) {\n            try {\n                throw new Exception(\"key is null.\");\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n        return searchHelper(key,root);\n    }\n\n    private V searchHelper(K key, BinNode<K,V> root){\n        if (root==null) return null;\n        int res=root.getKey().compareTo(key);\n        if (res==0) return root.getValue();\n        else if (res>0) return searchHelper(key,root.getLeft());\n        else return searchHelper(key,root.getRight());\n    }\n\n    @Override\n    public boolean update(K key, V value) {\n        if (key==null) {\n            try {\n                throw new Exception(\"key is null.\");\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return false;\n        }\n        return updateHelper(key,value,root);\n    }\n\n    private boolean updateHelper(K key, V value, BinNode<K,V> root){\n        if (root==null) return false;\n        int res=root.getKey().compareTo(key);\n        if (res==0) {\n            root.setValue(value);\n            return true;\n        }else if (res>0) return updateHelper(key,value,root.getLeft());\n        else return updateHelper(key,value,root.getRight());\n    }\n    @Override\n    public boolean isEmpty() {\n        return root==null;\n    }\n\n    @Override\n    public void clear() {\n        root=null;\n    }\n\n    @Override\n    public void travelPrev() {\n        travelPrev(root);\n    }\n\n    private void travelPrev(BinNode<K,V> root){\n        System.out.println(\"先序遍历\");\n        if (root==null) return;\n        System.out.print(root);\n        travelPrev(root.getLeft());\n        travelPrev(root.getRight());\n    }\n\n    @Override\n    public void travelMid() {\n        travelMid(root);\n    }\n    private void travelMid(BinNode<K,V> root){\n//        System.out.println(\"中序遍历\");\n        if (root==null) return;\n        travelMid(root.getLeft());\n        System.out.print(root);\n        travelMid(root.getRight());\n    }\n\n    @Override\n    public void travelLast() {\n\n        travelLast(root);\n    }\n\n    private void travelLast(BinNode<K,V> root){\n        System.out.println(\"后序遍历\");\n        if (root==null) return;\n        travelLast(root.getLeft());\n        travelLast(root.getRight());\n        System.out.print(root);\n    }\n\n    @Override//层序遍历，也就是广度优先遍历\n    public void travel() {\n        System.out.println(\"层序遍历\");\n        Map<Integer, List<BinNode<K,V>>> map=new HashMap();\n        class MyQueue{\n            class BinNodeWithLevel{\n                int level;\n                BinNode<K,V> binNode;\n                BinNodeWithLevel next;\n                BinNodeWithLevel(int level,BinNode<K,V> binNode,BinNodeWithLevel next){\n                    this.level=level;\n                    this.binNode=binNode;\n                    this.next=next;\n                }\n            }\n            int size;\n            BinNodeWithLevel top;\n            MyQueue(){\n                top=null;\n                size=0;\n            }\n            public void push(int level,BinNode<K,V> node){\n                top=new BinNodeWithLevel(level,node,top);\n                size++;\n            }\n            public BinNodeWithLevel pop(){\n                if (this.isEmpty()) return null;\n                BinNodeWithLevel res=top;\n                top=top.next;\n                size--;\n                return res;\n            }\n            public boolean isEmpty(){\n                return size==0;\n            }\n        }\n        MyQueue queue=new MyQueue();\n        queue.push(0,root);\n        while (!queue.isEmpty()){\n            MyQueue.BinNodeWithLevel pop = queue.pop();\n            int level=pop.level;\n            BinNode<K,V> node=pop.binNode;\n            List<BinNode<K,V>> list=map.get(level);\n            if (list==null){\n                list=new LinkedList<>();\n                list.add(node);\n                map.put(level,list);\n            }else{\n                list.add(node);\n            }\n            System.out.print(node);\n            if (node.getLeft()!=null) queue.push(level+1,node.getLeft());\n            if (node.getRight()!=null) queue.push(level+1,node.getRight());\n        }\n        System.out.print(map);\n    }\n}\n```\n完美解决！\n\n# AVL树\n\n![](树/Untitled%207.png)\n\n查找效率提高\n\n将二叉检索树转变为AVL树\n\n![](树/Untitled%208.png)\n\n![](树/Untitled%209.png)\n\n![](树/Untitled%2010.png)\n\n**在插入和删除节点时会出现失衡**\n\n- **插入**\n\n  - LL型\n\n  ![](树/Untitled%2011.png)\n\n  - LR型\n\n  ![](树/Untitled%2012.png)\n\n  1. 先对root的左子树进行一个左旋\n\n     ![](树/Untitled%2013.png)\n\n     ![](树/Untitled%2014.png)\n\n  2. 对roo右旋\n\n     ![](树/Untitled%2015.png)\n\n  - RR型\n\n    ![](树/Untitled%2016.png)\n\n  - RL型\n\n    1. 先对root的右子树进行一个右旋\n\n    ![](树/Untitled%2017.png)\n\n    ![](树/Untitled%2018.png)\n\n    1. 对root进行左旋\n\n    ![](树/Untitled%2019.png)\n\n  **删除基本相同，删除后判断是哪种类型，进行相应处理**","categories":["算法","数据结构","树"]},{"title":"算法渐进分析","url":"/2024/08/04/算法渐进分析/","content":"\n# 三个符号\n\n$O(n)$:上界。相当于\"<=”\n\n![](./算法渐进分析/Untitled.png)\n\n$o(n)$:非紧的上界。相当于\"<”\n\n![](./算法渐进分析/Untitled%201.png)\n\n$Ω(n)$:下界。相当于\">=”\n\n![](./算法渐进分析/Untitled%202.png)\n\n$w(n)$:非紧的下界。 相当于\">”\n\n![](./算法渐进分析/Untitled%203.png)\n\n$θ(n)$:紧确界。相当于\"=”\n\n![](./算法渐进分析/Untitled%204.png)\n\n注解：渐近非负的意思是“当n趋于无穷大时，f(n)和g(n)都非负”。\n\n- 如果$f(n)=Θ(g(n))$,则$f(n)=O(g(n))$且$f(n)=Ω(g(n))$。\n- 如果$f(n)=o(g(n))$,则$f(n)=O(g(n))$。\n- 如果$f(n)=ω(g(n))$，则$f(n)=Ω(g(n))$。\n\n[参考](https://blog.csdn.net/gaoxiangnumber1/article/details/45066841)\n\n## 用集合描述\n\n$f(n)∈ O(g(n))$\n\n举例：\n\n![](./算法渐进分析/Untitled%205.png)\n\n如果$f(n)=O(g(n))$,则要么是$f(n)=o(g(n))$，要么是$f(n)=Θ(g(n))$。\n\n## 性质（没啥用）\n\n1. 传递性：一条链上的都是同一个符号\n\n![](./算法渐进分析/Untitled%206.png)\n\n2. 自反性：带等号的\n\n![](./算法渐进分析/Untitled%207.png)\n\n3. 对称性\n\n![](./算法渐进分析/Untitled%208.png)\n\n4. 单调性\n\n![](./算法渐进分析/Untitled%209.png)\n\n5. 多部份决策：通俗点来说来说就是当算法由两个连续执行部分组成时，该算法的整体效率由具有较大增长次数的那部分所决定，即效率较差的部分决定。\n\n![](./算法渐进分析/Untitled%2010.png)\n\n## 例题\n\n![](./算法渐进分析/Untitled%2011.png)","categories":["算法","基础知识"]},{"title":"网络安全大作业","url":"/2024/08/03/网络安全大作业/","content":"{% pdf 安全通信软件的设计与实现.pdf %} ","categories":["课程学习","网络信息安全"]},{"title":"计算机网络课程设计","url":"/2024/08/03/计算机网络课程设计/","content":"{% pdf 计算机网络课程设计项目报告.pdf %} \n","categories":["课程学习","计算机网络"]},{"title":"算法刷题记录DAY1","url":"/2024/08/03/算法刷题记录DAY1/","content":"\n先从暴力开始吧\n\n# 暴力\n\n## 三角形\n\n![](./算法刷题记录DAY1/qq_pic_merged_1717912944477.jpg)\n\n这个暴力就行\n\n```cpp\n#include<stdio.h>\nint max(int a,int b){\n\treturn a>b?a:b;\n}\nint check(int a,int b,int c){\n\tif(a+b>c&&a+c>b&&b+c>a) return 1;\n\treturn 0;\n}\nint main(){\n\tint ans=0;\n\tint n;\n\tscanf(\"%d\",&n);\n\tint len[n];\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&len[i]);\n\t}\n\tfor(int i=0;i<n-2;i++){\n\t\tfor(int j=i+1;j<n-1;j++){\n\t\t\tfor(int k=j+1;k<n;k++){\n\t\t\t\tif(check(len[i],len[j],len[k]){\n\t\t\t\t\tans=max(ans,len[i]+len[j]+len[k]);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n\n下面这个有技巧：\n\n## Ants\n\n题目链接：[1852 -- Ants (poj.org)](http://poj.org/problem?id=1852)\n\n![](./算法刷题记录DAY1/qq_pic_merged_1717913392418.jpg)\n\n题目中说的不能交错通过，相遇之后会各自反向，这和相遇之后不改变方向的情况的时间是一样的，所以只需要扫描一遍。\n\n```c\n#include<stdio.h>\nint max(int a,int b){\n    return a>b?a:b;\n}\nint min(int a,int b){\n    return a<b?a:b;\n}\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    int len,t;\n    int x;\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&len,&t);\n        int mid=len/2;\n        int mn=0,mx=0;\n        for(int j=0;j<t;j++){\n            scanf(\"%d\",&x);\n            if(x>mid){\n                mn=max(mn,len-x);\n                mx=max(mx,x);\n            }else{\n                mn=max(mn,x);\n                mx=max(mx,len-x);\n            }\n        }\n        printf(\"%d %d\\n\",mn,mx);\n    }\n    return 0;\n}\n```\n\n## 抽签\n\n![](./算法刷题记录%20DAY1_pic_merged_1717913706542.jpg)\n\n这题直接暴力：\n\n![](./算法刷题记录%20DAY1_pic_merged_1717913813520.jpg)\n\n$$\n进阶：n的限制条件改为1\\leq n \\leq 1000\n$$\n\n解法：二分搜索\n\n先排好序，然后查找m-ka-kb-kc(假设为x)，查找数组中间的元素\n\n- 如果它比x小，x只能在后半段\n- 如果它比x大，x只能在前半段\n\n$$\n总时间复杂度：O(n^3logn)\n$$\n\n```cpp\n//二分查找方法\nbool binary_search(vector<int> nums,int target){\n\tint l=0,r=nums.size()-1;\n\twhile(l<=r){\n\t\tint mid=l+(r-l)/2;\n\t\tint com=nums[mid]-target;\n\t\tif(com==0) return true;\n\t\telse if(com>0){\n\t\t\tr=mid-1;\n\t\t}else{\n\t\t\tl=mid+1;\n\t\t}\n\t}\n\treturn false;\n}\n```\n\n这样的时间复杂度还是太大，继续改进\n\n先枚举出$kc+kd$，然后寻找$kc+kd=m-ka-kb$\n\n时间复杂度： $排序O(n^2logn)+循环O(n^2logn)$\n\n![](./算法刷题记录%20DAY1_pic_merged_1717914931937.jpg)\n\n![](./算法刷题记录%20DAY1_pic_merged_1717914879578.jpg)\n\n## 二进制枚举法\n\n使用二进制与位运算\n\n![](./算法刷题记录%20DAY1_pic_merged_1717916148154.jpg)\n\n```c\ntypedef long long ll;\nint a[MAX_N];\nint n,k;\nvoid solve(){\n\tll mask=1<<n;\n\tfor(ll i=1;i<mask;i++){\n\t\tll t=i;\n\t\tint m=0;\n\t\tint sum=0;\n\t\twhile(t){\n\t\t\tif(t&1) sum+=a[m];\n\t\t\tm++;\n\t\t\tt>>1;\n\t\t}\n\t\tif(sum==k){\n\t\t\tprintf(\"Yes\\n\");\n\t\t}\n\t}\n\tprintf(\"No\\n\");\n}\n```\n\n也可以用DFS（回溯法）\n\n```c\nint a[MAX_N];\nint n,k;\n\nbool dfs(int index,int sum){\n\tif(i==n) return sum==k;\n\tif(dfs(i+1,sum)) return true;\n\tif(dfs(i+1,sum+a[i])) return true;\n\treturn false;\n}\nvoid solve(){\n\tif(dfs(0,0)) printf(\"Yes\\n\");\n\telse printf(\"No\\n\");\n}\n```\n\n## DFS\n### 连通域判断\n![](./算法刷题记录%20DAY1_pic_merged_1717939197339.jpg)\n\n```c\n#include<stdio.h>\nchar map[101][101];\nint m;\nint n;\nvoid dfs(int x,int y){\n\tmap[x][y]='.';\n\tfor(int dx=-1;dx<=1;dx++){\n\t\tfor(int dy=-1;dy<=1;dy++){\n\t\t\tint nx=x+dx;\n\t\t\tint ny=y+dy;\n\t\t\tif(nx>=0&&nx<n&&ny>=0&&ny<m&&map[nx][ny]=='W'){\n\t\t\t\tdfs(nx,ny);\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%s\",map[i]);\n\t}\n\tint ans=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(map[i][j]=='W'){\n\t\t\t\tdfs(i,j);\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n\n\n还有道力扣：\n### 字母迷宫\n![](./算法刷题记录DAY1/Untitled.png)\n![](./算法刷题记录DAY1/Untitled%201.png)\n\n```cpp\n#include<vector>\n#include<string>\nusing namespace std;\nclass Solution {\npublic:\n    bool wordPuzzle(vector<vector<char>>& grid, string target) {\n        vector<vector<bool>> used(grid.size(),vector<bool>(grid[0].size(),false));\n        for(int i=0;i<grid.size();i++){\n            for(int j=0;j<grid[i].size();j++){\n                used[i][j]=true;\n                if(dfs(grid,target,0,i,j,used)) return true;\n                used[i][j]=false;\n            }\n        }\n        return false;\n    }\n    int dirx[4]={-1,0,0,1};\n    int diry[4]={0,1,-1,0};\n    bool dfs(vector<vector<char>>& grid,string target,int index,int x,int y,vector<vector<bool>> used){\n        if(index==target.length()-1) \n            return target.at(index)==grid[x][y];\n        if(target.at(index)!=grid[x][y]) return false;\n        for(int i=0;i<4;i++){\n            int nx=x+dirx[i];\n            int ny=y+diry[i];\n            if(nx>=0&&nx<grid.size()&&ny>=0&&ny<grid[0].size()&&used[nx][ny]==false){\n                used[nx][ny]=true;\n                bool res=dfs(grid,target,index+1,nx,ny,used);\n                used[nx][ny]=false;\n                if(res) return true;\n            }\n        }\n        return false;\n    }\n};\n```\n\n这里有一个大佬的解：\n\n```cpp\nclass Solution {\npublic:\n    bool exist(vector<vector<char>>& board, string word) {\n        int rows = board.size(), cols = board[0].size();\n\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++) {\n                if (board[r][c] == word[0] && dfs(board, word, 0, r, c)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    bool dfs(vector<vector<char>>& board, string& word, int index, int row, int col) {\n        if (index == word.size()) {\n            return true;\n        }\n\n        if (row < 0 || col < 0 || row >= board.size() || col >= board[0].size()) {\n            return false;\n        }\n\n        if (board[row][col] != word[index]) {\n            return false;\n        }\n    \n        auto board_val = board[row][col];\n        board[row][col] = '0';//用当前数组代替了used\n        bool result = dfs(board, word, index + 1, row - 1, col);\n        result = result || dfs(board, word, index + 1, row + 1, col);\n        result = result || dfs(board, word, index + 1, row, col - 1);\n        result = result || dfs(board, word, index + 1, row, col + 1);\n        board[row][col] = board_val;\n\n        return result;\n    }\n};\n```\n\n### 二叉树\n![](./算法刷题记录DAY1/Untitled%202.png)\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n#include<string>\n#include<vector>\n#include<stack>\nclass Solution {\npublic:\n    vector<string> ans;\n    vector<string> binaryTreePaths(TreeNode* root) {\n        vector<int> stk;\n        stk.push_back(root->val);\n        dfs(root,stk);\n        return ans;\n    }\n    void dfs(TreeNode* root, vector<int>& stk){\n        if(isleaf(root)!=0){\n            ans.push_back(copy(stk));\n            return;\n        }\n        if(root->left==nullptr){\n            stk.push_back(root->right->val);\n            dfs(root->right,stk);\n            stk.pop_back();\n        }else if(root->right==nullptr){\n            stk.push_back(root->left->val);\n            dfs(root->left,stk);\n            stk.pop_back();\n        }else {\n            stk.push_back(root->left->val);\n            dfs(root->left,stk);\n            stk.pop_back();\n\n            stk.push_back(root->right->val);\n            dfs(root->right,stk);\n            stk.pop_back();\n        }\n    }\n    string copy(vector<int>& stk){\n        string ans=\"\";\n        for(int i=0;i<stk.size();i++){\n            if(i!=0) ans+=\"->\";\n            ans+=to_string(stk[i]);\n        }\n        return ans;\n    }\n    int isleaf(TreeNode* root){\n        if(root==nullptr) return -1;\n        if(root->right==nullptr&&root->left==nullptr) return 1;\n        return 0;\n    }\n    \n};\n```\n\n## BFS\n\n### 迷宫\n\n![](./算法刷题记录DAY1/Untitled.jpeg)\n\n![](./算法刷题记录DAY1/Untitled%201.jpeg)\n\n![](./算法刷题记录DAY1/Untitled%202.jpeg)\n\n\n### 二叉树层序遍历\n\n![](./算法刷题记录DAY1/Untitled%204.png)\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\n#include<vector>\n#include<queue>\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> ans;\n        queue<pair<int,TreeNode*>> q;\n        if(root==nullptr) return ans;\n        q.push(make_pair(0,root));\n        while(q.size()){\n            pair<int,TreeNode*> t=q.front();q.pop();\n            int level=t.first;\n            TreeNode* node=t.second;\n            if(level<ans.size()){\n                ans[level].push_back(node->val);\n            }else{\n                vector<int> next(1,node->val);\n                ans.push_back(next);\n            }\n            if(node->left!=nullptr){\n                q.push(make_pair(level+1,node->left));\n            }\n            if(node->right!=nullptr){\n                q.push(make_pair(level+1,node->right));\n            }\n        }\n        return ans;\n    }\n};\n```\n\n### N叉树层序遍历\n\n![](./算法刷题记录DAY1/Untitled%205.png)\n\n![](./算法刷题记录DAY1/Untitled%206.png)\n\n```cpp\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n#include<queue>\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(Node* root) {\n        vector<vector<int>> ans;\n        queue<pair<int,Node*>> q;\n        if(root==nullptr) return ans;\n        q.push(make_pair(0,root));\n        while(q.size()){\n            pair<int,Node*> t=q.front();q.pop();\n            int level=t.first;\n            Node* node=t.second;\n            if(level<ans.size()){\n                ans[level].push_back(node->val);\n            }else{\n                vector<int> next(1,node->val);\n                ans.push_back(next);\n            }\n            vector<Node*> cld=node->children;\n            for(int i=0;i<cld.size();i++){\n                if(cld[i]!=nullptr){\n                    q.push(make_pair(level+1,cld[i]));\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n# 贪心\n## 心算挑战\n![](./算法刷题记录DAY1/Untitled%207.png)\n\n这题一开始没想到：\n\n**排序先取最大的cnt个数，如果它们的和是偶数直接输出，不然就找一个已取的最小的奇数换成剩下未取的最大的偶数，或者找一个已取的最小的偶数换成剩下未取的最大奇数**\n\n看看大佬答案：\n\n```cpp\nclass Solution {\npublic:\n    int maxmiumScore(vector<int>& cards, int cnt) {\n        sort(cards.begin(), cards.end(), greater<int>());\n        int res = 0, lastodd = 0, lasteven = 0;\n        for (int i = 0; i < cnt; i++)\n        {\n            res += cards[i];\n            if (cards[i] % 2 == 1) lastodd = cards[i];\n            else lasteven = cards[i];\n        }\n        if (res % 2 == 0) return res;\n\n        int max1 = 0, max2 = 0;\n        for (int i = cnt; i < cards.size(); i++)\n        {\n            if (lasteven && max1 == 0 && cards[i]%2) max1 = res - lasteven + cards[i];\n            if (lastodd && max2 == 0 && cards[i]%2 == 0) max2 = res - lastodd + cards[i];\n        }\n        return max(max1, max2);\n    }\n};\n```\n## 硬币问题\n![](./算法刷题记录%20DAY1_pic_merged_1718006386488.jpg)\n\n优先使用大面值的硬币：\n\n```cpp\nconst int V[6]={1, 5, 10, 50, 100, 500};\nint C[6];//\nint A;\n\nvoid solve(){\n\tint ans=0;\n\tfor(int i=5;i>=0;i++){\n\t\tint t = min(A/V[i], C[i]);\n\t\tA -= t*V[i];\n\t\tans+=t;\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n}\n```\n## 字典序最小\n![](./算法刷题记录%20DAY1_pic_merged_1718006622569.jpg)\n\n![](./算法刷题记录%20DAY1_pic_merged_1718006677452.jpg)\n\n![](./算法刷题记录%20DAY1_pic_merged_1718006696584.jpg)\n\n![](./算法刷题记录%20DAY1_pic_merged_1718006711202.jpg)\n\n## 哈夫曼编码\n\n![](./算法刷题记录%20DAY1_pic_merged_1718006911989.jpg)\n\n```cpp\n#include<iostream>\n#include <queue>\n#include<vector>\nusing namespace std;\ntypedef long long ll;//开ll才不会溢出\nint main(){\n    priority_queue<ll,vector<ll>,greater<ll> > q;\n    int n;\n    cin>>n;\n    ll x;\n    for(int i=0;i<n;i++){\n        cin>>x;\n        q.push(x);\n    }\n    ll ans=0;\n    while(q.size()>1){\n        // ans+=q.front();\n        ll y1=q.top();\n        q.pop();\n        ll y2=q.top();\n        q.pop();\n        ans+=(y1+y2);\n        q.push(y1+y2);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n```\n\n动态规划先不看\n\n先看数学：\n# 数学\n## 辗转相除法\n\n![](./算法刷题记录%20DAY1_pic_merged_1718008211277.jpg)\n\n鬼能看出这题是求最大公约数\n\n$$\n答案就是|x_1-x_2|和|y_1-y2|的最大公约数-1！！！！\n$$\n\n现在问题来到计算最大公约数：\n\n### 辗转相除法\n\n```cpp\nint gcd(int a, int b) {\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\n```\n\n$$\n时间复杂度：O(log max(a,b))以内\n$$\n\n还有一些比较低效的方法：https://blog.csdn.net/Brilliance_panpan/article/details/88372432\n\n### 扩展欧几里得算法\n\n$$\n求整数x和y使得ax+by=1\n$$\n\n可以发现，如果gcd(a,b)不等于1，无解；如果gcd(a,b)=1,就可以通过扩展原来的辗转相除法来求解。事实上，一定存在整数对（x,y）使得ax+by=gcd(a,b)。\n\n![](./算法刷题记录DAY1/Untitled%208.png)\n\n代码：\n\n```cpp\nint extgcd(int a,int b,int& x,int& y){\n\tint d=a;\n\tif(b){\n\t\td=extgcd(b,a%b,y,x);\n\t\ty-=(a/b)*x;\n\t}else{\n\t\tx=1;y=0;\n\t}\n\treturn d;\n}\n```\n\n## 素数\n\n### 素性检验\n\n$$\n给定整数n，判断n是不是素数(1\\leq n \\leq 10^9)\n$$\n\n想到的最直接的方法就是从2到n-1遍历，能整除就不是素数，但是时间复杂度太大；实际上我们只需要检查2~根号n的整数就可以。\n\n```cpp\nint n;\nvoid solve(){\n\tif(n==2){\n\t\tprintf(\"Yes\\n\");\n\t\treturn;\n\t}\n\tfor(int i=2;i*i<=n;i++){\n\t\tif(n%i==0){\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tprintf(\"Yes\\n\");\n}\n```\n\n$$\n给定整数n,请问n以内有多少个素数？（n \\leq 10^6）\n$$\n\n### 埃氏筛法\n\n首先把2到n范围内的所有整数谢下来，最小的数组2是素数，将表中所有2的倍数划去，然后是3（素数），将3的倍数全部划去，以此类推。\n\n![](./算法刷题记录%20DAY1_pic_merged_1718012475501.jpg)\n\n\n![](./算法刷题记录DAY1/Untitled%2015.png)\n\n```cpp\n#include<vector>\nclass Solution {\npublic:\n    int countPrimes(int n) {\n        if(n<2) return 0;\n        vector<bool> isPrime(n,true);\n        isPrime[0]=false;\n        isPrime[1]=false;\n        int ans=0;\n        for(int i=2;i<n;i++){\n            if(isPrime[i]){\n                ans++;\n                if(2*i<n){\n                    for(int j=2*i;j<n;j+=i){\n                        isPrime[j]=false;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n### 区间筛法\n\n![](./算法刷题记录%20DAY1_pic_merged_1718012639631.jpg)\n\n![](./算法刷题记录%20DAY1_pic_merged_1718012675564.jpg)\n\n![](./算法刷题记录%20DAY1_pic_merged_1718012812983.jpg)\n\n### 快速幂运算\n\n![](./算法刷题记录%20DAY1_pic_merged_1718012862839.jpg)\n\n思路：\n\n![](./算法刷题记录%20DAY1_pic_merged_1718013054084.jpg)\n\n代码1：\n\n![](./算法刷题记录%20DAY1_pic_merged_1718013072543.jpg)\n\n代码2（递归）：\n\n![](./算法刷题记录%20DAY1_pic_merged_1718013088936.jpg)\n\n# 贪心\n## 救生艇\n![](./算法刷题记录DAY1/Untitled%209.png)\n\n思路：先把people排序，每次均从头和从尾各选取一个人凑在一条船上，能凑上就凑，凑不上就放大的。\n\n```cpp\n#include<vector>\n#include<algorithm>\nclass Solution {\npublic:\n    int numRescueBoats(vector<int>& people, int limit) {\n        sort(people.begin(),people.end());//从小到大排序\n        int ans=0;\n        int pbig=people.size()-1;\n        int psml=0;\n        while(pbig>psml){\n            int big=people[pbig];\n            int small=people[psml];\n            if(big+small<=limit) {\n                ans++;\n                psml++;\n                pbig--;\n            }\n            else{\n                ans++;\n                pbig--;\n            }\n        }\n        if(pbig==psml) ans++;\n        return ans;\n    }\n};\n```\n## 最大数\n![](./算法刷题记录DAY1/Untitled%2010.png)\n\n![](./算法刷题记录DAY1/Untitled%2011.png)\n\n```cpp\n#include <vector>\n#include <algorithm>\ntypedef unsigned long long ll;\nll pingjie(ll a, ll b)\n{\n    ll x = b;\n    if (x == 0)\n        return a * 10;\n    while (x > 0)\n    {\n        a = a * 10;\n        x /= 10;\n    }\n    a += b;\n    return a;\n}\nbool cmp(int a, int b)\n{\n    ll ab = pingjie(a, b);\n    ll ba = pingjie(b, a);\n    return ab > ba;\n}\n\nclass Solution\n{\npublic:\n    string largestNumber(vector<int> &nums)\n    {\n        sort(nums.begin(), nums.end(), cmp);\n        if(nums[0]==0) return \"0\";\n        string ans;\n        for (int i = 0; i < nums.size(); i++)\n        {\n            ans += to_string(nums[i]);\n        }\n        return ans;\n    }\n};\n```\n\n可以优化比较方法：c++中，sort中自定义的比较函数可以直接用字符串比较\n\n```cpp\nsort(nums.begin(), nums.end(), [](const int &x, const int &y) {\n\treturn to_string(x) + to_string(y) > to_string(y) + to_string(x);\n});\n```\n## 加油站\n![](./算法刷题记录DAY1/Untitled%2012.png)\n\n![](./算法刷题记录DAY1/Untitled%2013.png)\n\n```cpp\n/*\n\t这题一开始暴力，没有优化，TLK了，后面看了答案优化了过了。\n\t**关键点：我们首先检查第 000 个加油站，并试图判断能否环绕一周；\n\t\t\t\t\t如果不能，就从第一个无法到达的加油站开始继续检查。**\n*/\n#include<vector>\n#include<set>\nclass Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int n=gas.size();\n        set<int> st;\n        int begin_index=-1;\n        for(int i=0;i<gas.size();i++){\n            if(gas[i]-cost[i]>=0) {\n                begin_index=i;\n                break;\n            }\n        }\n        if(begin_index==-1) return -1;\n        int bugindex=-1;\n        st.insert(begin_index);\n        for(;begin_index<n;){\n            int total=gas[begin_index]-cost[begin_index];\n            for(int j=(begin_index+1)%n;j!=begin_index;j=(j+1)%n){\n                total+=(gas[j]-cost[j]);\n                if(total<0) {\n                    bugindex=j;\n                    break;\n                }\n            }\n            if(total>=0) return begin_index;\n            else{\n                int k;\n                for(k=bugindex;;k=(k+1)%n){\n                    if(gas[k]>=cost[k]) {\n                        break;\n                    }\n                }\n                begin_index=k;\n                if(st.count(begin_index)) return -1;\n                else st.insert(begin_index);\n            }\n        }\n        return -1;\n    }\n};\n```\n\n## 经典跳跃游戏\n\n初级版\n\n![](./算法刷题记录DAY1/Untitled%2014.png)\n\n```cpp\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int maxindex=0;\n        for(int i=0;i<=maxindex&&i<nums.size();i++){\n            maxindex=max(maxindex,i+nums[i]);\n        }\n        return maxindex>=nums.size()-1;\n    }\n};\n```\n\n# 动态规划\n## 最小路径和\n![](./算法刷题记录DAY1/Untitled%2016.png)\n\n```cpp\nclass Solution {\npublic:\n    int dp[201][201];\n    int minimumTotal(vector<vector<int>>& triangle) {\n        memset(dp,-1,sizeof dp);\n        dp[0][0]=triangle[0][0];\n        for(int i=1;i<triangle.size();i++){\n            for(int j=0;j<=i;j++){\n                if(i==j){\n                    dp[i][j]=dp[i-1][j-1]+triangle[i][j];\n                }else if(j==0){\n                    dp[i][j]=dp[i-1][j]+triangle[i][j];\n                }else{\n                    dp[i][j]=min(dp[i-1][j-1],dp[i-1][j])+triangle[i][j];\n                }\n            }\n        }\n        int min=dp[triangle.size()-1][0];\n        for(int i=1;i<triangle.size();i++){\n            if(min>dp[triangle.size()-1][i])\n                min=dp[triangle.size()-1][i];\n        }\n        return min;\n    }\n};\n```\n\n**压缩后：**\n\n```cpp\nclass Solution {\npublic:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        int n = triangle.size();\n        vector<vector<int>> f(2, vector<int>(n));\n        f[0][0] = triangle[0][0];\n        for (int i = 1; i < n; ++i) {\n            int curr = i % 2;\n            int prev = 1 - curr;\n            f[curr][0] = f[prev][0] + triangle[i][0];\n            for (int j = 1; j < i; ++j) {\n                f[curr][j] = min(f[prev][j - 1], f[prev][j]) + triangle[i][j];\n            }\n            f[curr][i] = f[prev][i - 1] + triangle[i][i];\n        }\n        return *min_element(f[(n - 1) % 2].begin(), f[(n - 1) % 2].end());\n    }\n};\n\n// 作者：力扣官方题解\n// 链接：https://leetcode.cn/problems/IlPe0q/solutions/1036365/san-jiao-xing-zhong-zui-xiao-lu-jing-zhi-srun/\n// 来源：力扣（LeetCode）\n// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n## leetcode 2849\n![](./算法刷题记录DAY1/Untitled%2017.png)\n\n![](./算法刷题记录DAY1/Untitled%2018.png)\n\n题解：\n\n![](./算法刷题记录DAY1/Untitled%2019.png)\n\n```cpp\nclass Solution {\npublic:\n    bool isReachableAtTime(int sx, int sy, int fx, int fy, int t) {\n        if(sx==fx&&sy==fy) return t!=1;\n        return t>=max(abs(sx-fx),abs(sy-fy));\n    }\n};\n```\n## 分糖果I\n![](./算法刷题记录DAY1/Untitled%2020.png)\n\n```cpp\nclass Solution {\npublic:\n    int distributeCandies(int n, int limit) {\n        int ans=0;\n        for(int i=0;i<=limit;i++){\n            for(int j=0;j<=n-i&&j<=limit;j++){\n                if(n-i-j<=limit) ans++;\n            }\n        }\n        return ans;\n    }\n};\n```\n## 分糖果II\n![](./算法刷题记录DAY1/Untitled%2021.png)\n\n```cpp\nclass Solution {\npublic:\n    long long distributeCandies(int n, int limit) {\n        if(limit<n/3) return 0;\n        long long ans=0;\n        for(int i=max(0,n-2*limit);i<=limit&&n-i>=0;i++){\n            int k=n-i;\n            if(k<limit) ans+=k+1;\n            else ans+=limit-(k-limit)+1;\n        }\n        return ans;\n    }\n};\n```\n# 杂题\n## 删除重复项\n![](./算法刷题记录DAY1/Untitled%2022.png)\n\n![](./算法刷题记录DAY1/Untitled%2023.png)\n\n```cpp\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int n=nums.size();\n        int cnt=0;\n        for(int i=0;i<n;i++){\n            if(i>0&& nums[i]!=nums[i-1]) cnt=1;\n            else cnt++;\n            if(cnt==3){\n                remove(nums,i,n);\n                n--;\n                cnt--;\n                i--;\n            }\n        }\n        return n;\n    }\n    void remove(vector<int>& nums,int index,int end){\n        for(int i=index;i<end-1;i++){\n            nums[i]=nums[i+1];\n        }\n    }\n};\n```","categories":["算法"]},{"title":"排序算法","url":"/2024/08/01/排序算法/","content":"\n> **排序是指重新排列列表中的元素，使表中的元素按照关键字有序的过程**\n\n# 分类\n\n- 按照稳定性分类\n  \n  ![](./排序算法/Untitled.png)\n    \n- 内部排序与外部排序\n    - 内部排序：数据都在内存中（考虑时间复杂度和空间复杂度）\n    - 外部排序：数据太多，无法全部放入内存（还需要考虑读写磁盘次数）\n\n**[可视化]([Comparison Sorting Visualization (usfca.edu)](https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html))**\n\n# 插入排序（稳定的）\n\n算法思想：每次将一个待排序的记录按照其关键字大小插入到前面已经排行的子序列中，知道全部记录插入完成。\n\n```java\npublic static void insertSortAsc(int[] arr){\n    int n=arr.length;\n    int i,j;\n    for (i=1;i<n;i++){\n        if (arr[i]<arr[i-1]){\n            int temp=arr[i];\n            for (j=i-1;j>=0&&temp<arr[j];j--){\n                arr[j+1]=arr[j];\n            }\n            arr[j+1]=temp;\n        }\n    }\n}\n```\n\n> **代码思路：**从第二个元素开始遍历，当当前元素的关键字与前一个元素的关键字不满足规定的排序方式时，这个时候，当前元素要插入前面已经排好序的序列之中，操作如下：用一个变量存储当前元素，对于前面已经排好的序列中的元素，从后往前遍历，每遇到一个比需要插入的元素的关键字小（或大，更精确的描述应该是不满足规定的排序方式）的元素，就将该元素后移一格，直到遇到满足规定排序方式的元素，将暂存变量的值赋值给改元素后一个格子的位置。\n\n## review\n\n```java\npublic static void insertSort(Element[] elements){\n    int i,j;\n    for (i=1;i<elements.length;i++){\n        if (elements[i].getKey()<elements[i-1].getKey()){\n            Element tmp=elements[i];\n            for (j=i-1;j>=0&&elements[j].getKey()>tmp.getKey();j--){\n                elements[j+1]=elements[j];\n            }\n            elements[j+1]=tmp;\n        }\n    }\n}\n```\n\n# 选择排序（不稳定的）\n\n算法思想：每次从未排序好中的序列中选择一个关键字最大（最小）的元素放入到排序好序列的后面即可\n\n```java\n//不稳定的排序\npublic static void selectSort(Element[] elements){\n    int start=0;\n    for (;start<elements.length;start++){\n        int minIndex=start;\n        for (int i=start+1;i<elements.length;i++){\n            if (elements[i].getKey()<elements[minIndex].getKey()){\n                minIndex=i;\n            }\n        }\n        swap(elements,minIndex,start);\n    }\n}\n```\n\n# 冒泡排序（稳定的）\n\n算法思想：每迭代一轮都比较相邻俩元素大小，不满足排序规则则交换他们\n\n```java\n//稳定的排序\npublic static void bobbleSort(Element[] elements){\n    //从前往后冒泡,使得末尾的序列元素必然是排好的\n    for (int end=elements.length-1;end>=0;end--){\n        for (int i=0;i<end;i++){\n            if (elements[i].getKey()>elements[i+1].getKey()){\n                swap(elements,i,i+1);\n            }\n        }\n    }\n}\n```\n\n# 希尔排序\n\n算法思想：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录\"基本有序\"时，再对全体记录进行依次直接插入排序。\n\n大概意思就是，先等间隔分组，分好组后组内先排序，然后再等间隔分组（间隔减半），再组内排序，循环迭代，直到间隔为1并排行序号。\n\n利用的原理是，先分组排序，利用插入排序的优势：当序列较为有序时，算法效率高。\n\n```java\nprivate static void insertSortHelper(Element[] elements,int gap,int start){\n    int i,j;\n    for (i=start+gap;i<elements.length;i++){\n        if (elements[i].getKey()<elements[i-gap].getKey()){\n            Element tmp=elements[i];\n            for (j=i-gap;j>=0&&elements[j].getKey()>tmp.getKey();j=j-gap) {\n                elements[j+gap]=elements[j];\n            }\n            elements[j+gap]=tmp;\n        }\n    }\n}\n\npublic static void shellSort(Element[] elements){\n    int gap=elements.length/2;\n    while (gap>0){\n        for (int i = 0; i < gap ; i++) {\n            insertSortHelper(elements,gap,i);\n        }\n        gap/=5;\n    }\n}\n```\n\n# 归并排序\n\n算法思路：先分再合，分：等分序列；合：排序合并序列（使用双指针）\n\n![](./排序算法/Untitled%201.png)\n\n```java\nprivate static void integerite(Element[] elements,int left1,int right1,int left2,int right2){\n    int index1=left1;\n    int index2=left2;\n    int currIndex=left1;\n    while (currIndex<=right2){\n        int compare= 0;\n        if (index1>right1) compare=1;\n        else if (index2>right2) compare=-1;\n        else compare=elements[index1].getKey()-elements[index2].getKey();\n        if (compare>0){\n            elements[currIndex++]=elements[index2++];\n        } else {\n            elements[currIndex++]=elements[index1++];\n        }\n    }\n}\n\nprivate static void mergeSortHelper(Element[] elements,int left,int right){\n    if (left>=right) return;\n    int mid=(left+right)/2;\n    mergeSortHelper(elements,left,mid);\n    mergeSortHelper(elements,mid+1,right);\n    integerite(elements,left,mid,mid+1,right);\n}\n\npublic static void mergeSort(Element[] elements){\n    mergeSortHelper(elements,0,elements.length-1);\n}\n```\n\n时间复杂度分析：$O(nlogn)$\n\n# 快速排序\n\n算法思想：分治思想，取一个基准值，让比基准值小的放一边，比基准值大的放一边（双指针实现）。\n\n**一定要先移动右指针！！！**\n\n```cpp\nvoid Sort::quick_sort(vector<int> &nums) {\n    quick_sort_helper(nums,0,nums.size()-1);\n}\n\nvoid Sort::quick_sort_helper(vector<int> &nums,\n                             int start, int end) {\n    if (start>=end) return;\n    int pivot=nums[start];\n    int left=start;\n    int right=end;\n    while (left<right){\n        //先移动right\n        while (right>left&&nums[right]>=pivot){\n            right--;\n        }\n        while (right>left&&nums[left]<=pivot){\n            left++;\n        }\n        swap(nums[left],nums[right]);\n    }\n    nums[right]=pivot;\n    quick_sort_helper(nums,start,right-1);\n    quick_sort_helper(nums,right+1,end);\n}\n```","categories":["算法"]}]