[{"title":"中缀表达式","url":"/2024/09/06/中缀表达式/","content":"\n# 三种表达式\n对表达式的记法，因此也被称为前缀记法、中缀记法和后缀记法。它们之间的区别在于运算符相对与操作数的位置不同：前缀表达式的运算符位于与其相关的操作数之前；中缀和后缀同理。\n\n> 举例：\n> (3 + 4) × 5 - 6 就是中缀表达式   \n> × + 3 4 5 6 前缀表达式   \n> 3 4 + 5 × 6 - 后缀表达式  \n\n# 中缀表达式转后缀表达式\n## 转换步骤\n1. 定义优先级\n   `(` < `+`、`-` < `*`、`\\\\` < `)` \n2. 对中缀表达式从左往右遍历\n   1. 如果遇到数字，直接添加到后缀表达式末尾；\n   2. 如果遇到运算符`+`、`-`、`*`、`\\\\`\n      先判断栈是否为空。若是，则直接将此运算符压入栈。若不是，则查看当前栈顶元素。若栈顶元素优先级大于或等于此操作符级别，则弹出栈顶元素，将栈顶元素添加到后缀表达式中，并继续进行上述判断。如果不满足上述判断或者栈为空，将这个运算符入栈。要注意的是，经过上述步骤，这个运算符最终一定会入栈。\n   3. 如果遇到括号\n      如果是左括号，直接入栈。如果是右括号，弹出栈中第一个左括号前所有的操作符，并将左括号弹出。（右括号别入栈）。\n   4. 字符串遍历结束后\n      如果栈不为空，则弹出栈中所有元素，将它们添加到后缀表达式的末尾，直到栈为空。\n\n## 代码实现\n\n```c++\nstring infixConvertToPostfix(string str){\n    stack<char> stk;\n    int n=str.size();\n    string res=\"\";\n    char c=0;\n    char top=0;\n    for(int i=0;i<n;i++){\n        c=str[i];\n        if(c==' ') continue;\n        if(c>='0'&&c<='9'){\n            res.push_back(c);\n        }else if(c== '+' || c== '-' || c == '*' || c == '/'){\n            if(stk.empty()){\n                stk.push(c);\n            }else{\n                while(!stk.empty()){\n                    top=stk.top();\n                    if(getPriority(top)>=getPriority(c)){\n                        res.push_back(top);\n                        stk.pop();\n                    }else break;\n                }\n                stk.push(c);\n            }\n        }else{\n            if(c=='(') stk.push(c);\n            else{\n                while (stk.top()!='(')\n                {\n                    res.push_back(stk.top());\n                    stk.pop();\n                }\n                stk.pop();\n            }\n        }\n    }\n    //遍历完后，若栈非空，弹出所有元素  \n    while(!stk.empty()){\n        res.push_back(stk.top());\n        stk.pop();\n    }\n    return res;\n}\n```\n# 后缀表达式的计算\n## 步骤\n准备一个数字栈。从左到右扫描后缀表达式，如果是数字，放入数字栈。如果是符号，从数字栈中弹出两个数字，第一个取出的数字为右运算数，第二个为左运算数，进行运算。然后将结果放进数字栈中。如此反复，直到读完整个表达式后，留在数字栈中的那个数字就是最终结果。\n\n## 代码实现\n```c++\nint calculatByInfix(string str){\n    stack<int> stk;\n    int n=str.size();\n    int num1, num2, num3;  \n    char c=0;\n    for (int i = 0; i < n; i++) {  \n        c=str[i];\n        if (c >= '0' && c <= '9') {  \n            stk.push(c - '0');  \n        }  \n        else {  \n            num2 = stk.top();  \n            stk.pop();  \n            num1 = stk.top();  \n            stk.pop();  \n            if (c == '+') {  \n                num3 = num1 + num2;  \n            }  \n            else if (c == '-') {  \n                num3 = num1 - num2;  \n            }  \n            else if (c == '*') {  \n                num3 = num1 * num2;  \n            }  \n            else if (c == '/') {  \n                num3 = num1 / num2;  \n            }  \n            stk.push(num3);  \n        }  \n    }  \n    return stk.top();  \n}\n```\n\n# 中缀表达式的计算\n## 步骤\n将前面的两步结合起来，就可以得到直接计算的方法。\n准备一个数字栈和一个符号栈，从左到右遍历中缀表达式。如果遇到数字，入数字栈。\n如果遇到符号（四个运算符以及括号），跟前面的“中缀表达式转后缀表达式”过程一样，对符号栈进行处理。处理过程中，对每一个出栈的运算符：+ - * /，根据“计算后缀表达式”的方法，计算结果（跟数字栈配合）。\n如果遍历完中缀表达式后符号栈还非空，就继续出符号栈的运算符，计算，直到符号栈为空。最后数字栈剩下的数字就是结果。\n\n## 代码实现\n```c++\nint getPriority(char ch)  \n{  \n    //获取优先级  \n    if (ch == '(') return 1;  \n    else if (ch == '+' || ch == '-') return 2;  \n    else if (ch == '*' || ch == '/') return 3;  \n    else return 4;  \n}  \n  \nvoid calculate(stack<double> &stk, char operation)  \n{  \n    double num1, num2, num3;  \n    num2 = stk.top();  \n    stk.pop();  \n    num1 = stk.top();  \n    stk.pop();  \n    if (operation == '+') {  \n        num3 = num1 + num2;  \n    }  \n    else if (operation == '-') {  \n        num3 = num1 - num2;  \n    }  \n    else if (operation == '*') {  \n        num3 = num1 * num2;  \n    }  \n    else if (operation == '/') {  \n        num3 = num1 / num2;  \n    }  \n  \n    stk.push(num3);  \n}  \n  \ndouble calculator(string str)  \n{  \n    //计算中缀表达式,默认输入是合法的  \n    stack<double> stk_number;  \n    stack<char> stk_operation;  \n    int i = 0, j;  \n    int size = str.size();  \n    char tmp_operation;  \n    string tmp_num;  \n    while (i < size) {  \n        if (str[i] >= '0' && str[i] <= '9') {  \n            j = i;  \n            while (j < size && str[j] >= '0' && str[j] <= '9') { j++; }  \n            tmp_num = str.substr(i, j - i);  \n            stk_number.push(atoi(tmp_num.c_str()));  \n            i = j;  \n        }  \n        else if (str[i] == '+' || str[i] == '-' || str[i] == '*' || str[i] == '/') {  \n            if (stk_operation.empty()) {  \n                stk_operation.push(str[i]);  \n            }  \n            else {  \n                while (!stk_operation.empty()) {  \n                    tmp_operation = stk_operation.top();  \n                    if (getPriority(tmp_operation) >= getPriority(str[i])) {  \n                        //计算  \n                        calculate(stk_number, tmp_operation);  \n                        stk_operation.pop();  \n                    }  \n                    else break;  \n                }  \n                stk_operation.push(str[i]);  \n            }  \n            i++;  \n        }  \n        else {  \n            if (str[i] == '(') stk_operation.push(str[i]);  \n            else {  \n                while (stk_operation.top() != '(') {  \n                    tmp_operation = stk_operation.top();  \n                    //计算  \n                    calculate(stk_number, tmp_operation);  \n                    stk_operation.pop();  \n                }  \n                stk_operation.pop();  \n            }  \n            i++;  \n        }  \n  \n    }  \n    //遍历完后，若栈非空，弹出所有元素  \n    while (!stk_operation.empty()) {  \n        tmp_operation = stk_operation.top();  \n        //计算  \n        calculate(stk_number, tmp_operation);  \n        stk_operation.pop();  \n    }  \n    return stk_number.top();  \n}  \n```\n\n*代码默认中缀表达式中所有数字都是整数，并且都在0到9之间*\n\n# 参考\n[CSDN](https://blog.csdn.net/sinat_27908213/article/details/80273557)","categories":["算法"]},{"title":"算法刷题记录DAY9","url":"/2024/09/06/算法刷题记录DAY9/","content":"\n# 解数独\n\n<p>编写一个程序，通过填充空格来解决数独问题。</p>\n\n<p>数独的解法需<strong> 遵循如下规则</strong>：</p>\n\n<ol> \n <li>数字&nbsp;<code>1-9</code>&nbsp;在每一行只能出现一次。</li> \n <li>数字&nbsp;<code>1-9</code>&nbsp;在每一列只能出现一次。</li> \n <li>数字&nbsp;<code>1-9</code>&nbsp;在每一个以粗实线分隔的&nbsp;<code>3x3</code>&nbsp;宫内只能出现一次。（请参考示例图）</li> \n</ol>\n\n<p>数独部分空格内已填入了数字，空白格用&nbsp;<code>'.'</code>&nbsp;表示。</p>\n\n<p>&nbsp;</p>\n\n<div class=\"top-view__1vxA\"> \n <div class=\"original__bRMd\"> \n  <div> \n   <p><strong>示例 1：</strong></p> \n   <img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png\" style=\"height:250px; width:250px\" /> \n   <pre>\n<strong>输入：</strong>board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n<strong>输出：</strong>[[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\n<strong>解释：</strong>输入的数独如上图所示，唯一有效的解决方案如下所示：\n</pre>\n  </div>\n </div>\n</div>\n<img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714_solutionsvg.png\" style=\"height:250px; width:250px\" />\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul> \n <li><code>board.length == 9</code></li> \n <li><code>board[i].length == 9</code></li> \n <li><code>board[i][j]</code> 是一位数字或者 <code>'.'</code></li> \n <li>题目数据 <strong>保证</strong> 输入数独仅有一个解</li> \n</ul>\n\n<div><div>Related Topics</div><div><li>数组</li><li>哈希表</li><li>回溯</li><li>矩阵</li></div></div><br><div><li>👍 1855</li><li>👎 0</li></div>\n\n> 思路：dfs,扫到结果就结束了，不要继续回溯\n\n```cpp\nclass Solution\n{\npublic:\n    void solveSudoku(vector<vector<char>> &board)\n    {\n        dfs(board, 0);\n    }\n\nprivate:\n    bool dfs(vector<vector<char>> &board, int index)\n    {\n        if (index > 80)\n        {\n            return true;\n        }\n        int x = index / 9;\n        int y = index % 9;\n        if (board[x][y] != '.')\n        {\n            return dfs(board, index + 1);\n        }\n        else\n        {\n            bool b = false;\n            for (char i = '1'; i <= '9'; i++)\n            {\n                // 验证i能不能填这里\n                bool flag = true;\n                for (int k = 0; k < 9; k++)\n                {\n                    if (board[x][k] == i || board[k][y] == i)\n                    {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag)\n                {\n                    int posx = x / 3;\n                    int posy = y / 3;\n                    for (int j = 0; j < 3; j++)\n                    {\n                        for (int k = 0; k < 3; k++)\n                        {\n                            if (board[posx * 3 + j][posy * 3 + k] == i)\n                            {\n                                flag = false;\n                                break;\n                            }\n                        }\n                    }\n                }\n                if (flag)\n                {\n                    b = true;\n                    board[x][y] = i;\n                    if (!dfs(board, index + 1))\n                    {\n                        board[x][y] = '.';\n                    }\n                    else\n                    {\n                        return true;\n                    }\n                }\n            }\n            if (!b)\n            {\n                return false;\n            }\n        }\n        return false;\n    }\n};\n```\n","categories":["算法","搜索"]},{"title":"算法刷题记录DAY8","url":"/2024/09/05/算法刷题记录DAY8/","content":"\n# 分发饼干\n\n![](./算法刷题记录DAY8/1725540156324.png)\n\n> 先排序，然后让先拿尽量小的饼干满足胃口小的孩子。\n\n```cpp\nclass Solution {\npublic:\n    int findContentChildren(vector<int>& g, vector<int>& s) {\n        int res=0;\n        int n=g.size();\n        sort(g.begin(),g.end());sort(s.begin(),s.end());\n        int index=0;\n        int m=s.size();\n        for(int i=0;i<n;i++){\n            while(index<m&&s[index]<g[i]) index++;\n            if(index<m) {\n                res++;\n                index++;\n            }\n            else break;\n        }\n        return res;\n    }\n};\n```\n\n# 种花问题\n\n![](./算法刷题记录DAY8/1725541202614.png)\n\n> 遇到能种的地方就种，n减到0就返回true\n\n```cpp\nclass Solution {\npublic:\n    bool canPlaceFlowers(vector<int>& flowerbed, int n) {\n        if(n==0) return true;\n        for(int i=0;i<flowerbed.size();i++){\n            if(flowerbed[i]==1){\n                i++;\n            }else{\n                if((i==0||flowerbed[i-1]==0)&&(i==flowerbed.size()-1||flowerbed[i+1]==0)){\n                    flowerbed[i]=1;\n                    n--;\n                    if(n==0) return true;\n                    i++;\n                }\n            }\n\n        }\n        return false;\n    }\n};\n```\n\n# \n\n![](./算法刷题记录DAY8/1725545385062.png)\n\n```cpp\n// 力扣官方题解\nclass Solution {\npublic:\n    bool checkPalindrome(const string& s, int low, int high) {\n        for (int i = low, j = high; i < j; ++i, --j) {\n            if (s[i] != s[j]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    bool validPalindrome(string s) {\n        int low = 0, high = s.size() - 1;\n        while (low < high) {\n            char c1 = s[low], c2 = s[high];\n            if (c1 == c2) {\n                ++low;\n                --high;\n            } else {\n                return checkPalindrome(s, low, high - 1) || checkPalindrome(s, low + 1, high);\n            }\n        }\n        return true;\n    }\n};\n```\n\n# 柠檬水找零\n\n![](./算法刷题记录DAY8/1725545726514.png)\n\n\n```cpp\nclass Solution {\npublic:\n    bool lemonadeChange(vector<int>& bills) {\n        int cnt5=0,cnt10=0,cnt20=0;\n        for(int i=0;i<bills.size();i++){\n            if(bills[i]!=5){\n                if(bills[i]==10){\n                    if(cnt5){\n                        cnt5--;\n                    }else return false;\n                    cnt10++;\n                }else if(bills[i]==20){\n                    if(cnt10>=1&&cnt5>=1) {\n                        cnt10--;\n                        cnt5--;\n                    }else if(cnt5>=3) cnt5-=3;\n                    else return false;\n                    cnt20++;\n                }\n            }else{\n                cnt5++;\n            }\n        }\n        return true;\n    }\n};\n```\n\n# 增减字符串匹配\n\n![](./算法刷题记录DAY8/1725546330480.png)\n\n> 思路：$I$ 就放剩余数字中的最小数，$D$ 就放剩余数字中的最大数。\n\n```cpp\nclass Solution {\npublic:\n    vector<int> diStringMatch(string s) {\n        int n=s.size();\n        int lo=0,hi=n;\n        vector<int> res(n+1,0);\n        for(int i=0;i<n;i++){\n            res[i]=(s[i]=='I'?lo++:hi--);\n        }\n        res[n]=lo;\n        return res;\n    }\n};\n```\n\n# 三角形的最大周长\n\n![](./算法刷题记录DAY8/1725547202126.png)\n\n```cpp\nclass Solution {\npublic:\n    bool isTrangle(int a,int b,int c){\n        return a+b>c&&b+c>a&&a+c>b;\n    }\n    int largestPerimeter(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int res=0;\n        int n=nums.size();\n        for(int i=n-1;i>=2;i--){\n            for(int j=i-1;j>=1;j--){\n                int hi=nums[i]+nums[j]-1;\n                int lo=nums[i]-nums[j]+1;\n                if(nums[j-1]<lo||nums[0]>hi) continue;\n                else{\n                    res=max(res,nums[i]+nums[j]+nums[j-1]);\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n\n# K次取反后最大化的数组和\n\n![](./算法刷题记录DAY8/1725548308296.png)\n\n```cpp\nclass Solution {\npublic:\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\n        int sum=0;\n        vector<int> negative;\n        int min_postive=INT_MAX;\n        for(int i=0;i<nums.size();i++){\n            if(nums[i]<0) negative.push_back(nums[i]);\n            else if(nums[i]<min_postive) min_postive=nums[i];\n            sum+=nums[i];\n        }\n        sort(negative.begin(),negative.end());\n        int index=0;\n        while(k&&index<negative.size()){\n            negative[index]=-negative[index];\n            sum+=2*negative[index];\n            index++;\n            k--;\n        }\n        if(k%2){\n            if(negative.size()>0){\n                min_postive=min(min_postive,negative[negative.size()-1]);\n            }\n            sum-=2*min_postive;\n        }\n        return sum;\n    }\n};\n```\n\n# 将数组分成和相等的三个部分\n\n![](./算法刷题记录DAY8/1725549174475.png)\n\n```cpp\nclass Solution {\npublic:\n    bool canThreePartsEqualSum(vector<int>& arr) {\n        int n=arr.size();\n        int sum=0;\n        for(int i=0;i<n;i++){\n            sum+=arr[i];\n        }   \n        if(sum%3!=0) return false; \n        int left=0;\n        int right=n-1;\n        int s0=0,s1=0;\n        while(left<n){\n            s0+=arr[left];\n            if(s0==sum/3){\n                break;\n            }\n            left++;\n        }\n        while(right>=0){\n            s1+=arr[right];\n            if(s1==sum/3){\n                break;\n            }\n            right--;\n        }\n        return right>left+1;\n    }\n};\n```\n\n# 加油站\n\n<p>在一条环路上有 <code>n</code>&nbsp;个加油站，其中第 <code>i</code>&nbsp;个加油站有汽油&nbsp;<code>gas[i]</code><em>&nbsp;</em>升。</p>\n\n<p>你有一辆油箱容量无限的的汽车，从第<em> </em><code>i</code><em> </em>个加油站开往第<em> </em><code>i+1</code><em>&nbsp;</em>个加油站需要消耗汽油&nbsp;<code>cost[i]</code><em>&nbsp;</em>升。你从其中的一个加油站出发，开始时油箱为空。</p>\n\n<p>给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> gas = [1,2,3,4,5], cost = [3,4,5,1,2]\n<strong>输出:</strong> 3\n<strong>解释:\n</strong>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油\n开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油\n开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油\n开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油\n开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油\n开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。\n因此，3 可为起始索引。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> gas = [2,3,4], cost = [3,4,3]\n<strong>输出:</strong> -1\n<strong>解释:\n</strong>你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。\n我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油\n开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油\n开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油\n你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。\n因此，无论怎样，你都不可能绕环路行驶一周。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul> \n <li><code>gas.length == n</code></li> \n <li><code>cost.length == n</code></li> \n <li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li> \n <li><code>0 &lt;= gas[i], cost[i] &lt;= 10<sup>4</sup></code></li> \n</ul>\n\n<div><div>Related Topics</div><div><li>贪心</li><li>数组</li></div></div><br><div><li>👍 1674</li><li>👎 0</li></div>\n\n> 思路：就是从0开始遍历，在哪个位置出现了油不够，那下一个遍历的位置就从这里之后开始，找到第一个gas大于cost的位置\n> 注意：这里要把begin_index加入set，以此判断有没有重复遍历，有重复了就说明不存在解\n\n```c++\nclass Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int n=gas.size();\n        set<int> st;\n        int begin_index=-1;\n        for(int i=0;i<n;i++){\n            if(gas[i]-cost[i]>=0) {\n                begin_index=i;\n                break;\n            }\n        }\n        if(begin_index==-1) return -1;\n        int bug_index=-1;\n        st.insert(begin_index);\n        while(begin_index<n){\n            int total=gas[begin_index]-cost[begin_index];\n            for(int j=(begin_index+1)%n;j!=begin_index;j=(j+1)%n){\n                total+=(gas[j]-cost[j]);\n                if(total<0) {\n                    bug_index=j;\n                    break;\n                }\n            }\n            if(total>=0) return begin_index;\n            else{\n                int k;\n                for(k=bug_index;;k=(k+1)%n){\n                    if(gas[k]>=cost[k]) {\n                        break;\n                    }\n                }\n                begin_index=k;\n                if(st.count(begin_index)) return -1;\n                else st.insert(begin_index);\n            }\n        }\n        return -1;\n    }\n};\n```\n\n# 不含AAA或BBB的字符串\n\n<p>给定两个整数 <code>a</code>&nbsp;和 <code>b</code>&nbsp;，返回&nbsp;<strong>任意</strong>&nbsp;字符串 <code>s</code>&nbsp;，要求满足：</p>\n\n<ul> \n <li><code>s</code>&nbsp;的长度为 <code>a + b</code>，且正好包含&nbsp;<code>a</code>&nbsp;个 <code>'a'</code>&nbsp;字母与&nbsp;<code>b</code> 个 <code>'b'</code>&nbsp;字母；</li> \n <li>子串&nbsp;<code>'aaa'</code>&nbsp;没有出现在 <code>s</code>&nbsp;中；</li> \n <li>子串&nbsp;<code>'bbb'</code> 没有出现在 <code>s</code>&nbsp;中。</li> \n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 1, b = 2\n<strong>输出：</strong>\"abb\"\n<strong>解释：</strong>\"abb\", \"bab\" 和 \"bba\" 都是正确答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 4, b = 1\n<strong>输出：</strong>\"aabaa\"</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul> \n <li><code>0 &lt;= a, b&nbsp;&lt;= 100</code></li> \n <li>对于给定的 <code>a</code> 和 <code>b</code>，保证存在满足要求的 <code>s</code>&nbsp;</li> \n</ul> \n<span style=\"display:block\"><span style=\"height:0px\"><span style=\"position:absolute\">​​​</span></span></span>\n\n<div><div>Related Topics</div><div><li>贪心</li><li>字符串</li></div></div><br><div><li>👍 94</li><li>👎 0</li></div>\n\n> 思路：先初始化一个全部是数量更大的字符的字符串串，长度为 $a+b$ ，然后用另一个字符去填，该位置满足条件就能填，填完为止\n\n```c++\nclass Solution {\nprivate:\n    bool isOk(string& s, int index, char now, char change) {\n        s[index]=change;\n        int begin=(index>=2?index-2:0);\n        bool flag=(s[begin  ]==change&&s[begin+1]==change&&s[begin+2]==change)||\n                  (s[begin+1]==change&&s[begin+2]==change&&s[begin+3]==change)||\n                  (s[begin+2]==change&&s[begin+3]==change&&s[begin+4]==change);\n        s[index]=now;\n        return !flag;\n    }\n\npublic:\n    string strWithout3a3b(int a, int b) {\n        string res = \"\";\n        char before = 'a';\n        if (a > b)\n            before = 'a';\n        else\n            before = 'b';\n        for (int i = 0; i < a + b; i++)\n            res += before;\n        char after = (before == 'a' ? 'b' : 'a');\n        int cnt = (after == 'a' ? a : b);\n        for (int i = 2; i < a + b && cnt;) {\n            res[i] = after;\n            i += 3;\n            cnt--;\n        }\n        if (cnt) {\n            for (int i = 0; i < a + b && cnt; i++) {\n                if (res[i] == after) {\n                    continue;\n                }\n                if (isOk(res, i, res[i], after)) {\n                    res[i]=after;\n                    cnt--;\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n\n# \n","categories":["算法","贪心"]},{"title":"算法刷题记录DAY7","url":"/2024/09/04/算法刷题记录DAY7/","content":"\n# 删除并获得点数\n\n![](./算法刷题记录DAY7/1725509700859.png)\n\n```cpp\nclass Solution {\npublic:\n    int deleteAndEarn(vector<int>& nums) {\n        int maxx=0;\n        for(int i=0;i<nums.size();i++){\n            if(nums[i]>maxx) maxx=nums[i];\n        }\n        vector<int> arr(maxx+1,0);\n        vector<int> dp(maxx+1);\n        for(int i=0;i<nums.size();i++){\n            arr[nums[i]]++;\n        }\n        cout<<endl;\n        dp[0]=0;\n        dp[1]=arr[1];\n        for(int i=2;i<=maxx;i++){\n            dp[i]=max(dp[i-1],i*arr[i]+dp[i-2]);\n        }\n        return dp[maxx];\n    }\n};\n```\n\n# 三角形最小路径和\n\n![](./算法刷题记录DAY7/1725518563150.png)\n\n```cpp\nclass Solution {\n    public:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        vector<vector<int>> dp(triangle.size(),vector<int>(triangle.size(),0));\n        dp[0][0]=triangle[0][0];\n        for(int i=1;i<triangle.size();i++){\n            for(int j=0;j<=i;j++){\n                if(j==0){\n                    dp[i][j]=dp[i-1][j]+triangle[i][j];\n                }else if(j==i){\n                    dp[i][j]=dp[i-1][j-1]+triangle[i][j];\n                }else{\n                    dp[i][j]=min(dp[i-1][j],dp[i-1][j-1])+triangle[i][j];\n                }\n            }\n        }\n        int res=INT_MAX;\n        for(int i=0;i<triangle.size();i++){\n            cout<<dp[triangle.size()-1][i]<<endl;\n            res=min(res,dp[triangle.size()-1][i]);\n        }\n        return res;\n    }\n};\n\n```\n\n# 下降路径最小和\n\n![](./算法刷题记录DAY7/1725520304584.png)\n\n```cpp\n#define min_(a,b,c) min(min((a),(b)),(c))\n\nclass Solution {\npublic:\n    int minFallingPathSum(vector<vector<int>>& matrix) {\n        int n=matrix.size();\n        vector<vector<int>> dp(n,vector<int>(n));\n        for(int i=0;i<n;i++) dp[0][i]=matrix[0][i];\n        for(int i=1;i<n;i++){\n            for(int j=0;j<n;j++) { \n                dp[i][j]=min_(j==0?INT_MAX:dp[i-1][j-1],dp[i-1][j],j==n-1?INT_MAX:dp[i-1][j+1])+matrix[i][j];\n            }\n        }\n        int res=INT_MAX;\n        for(int i=0;i<n;i++) res=min(res,dp[n-1][i]);\n        return res;\n    }\n};\n```\n\n# 完全平方数 \n\n![](./算法刷题记录DAY7/1725523032217.png)\n\n```cpp\nclass Solution {\npublic:\n    bool isT(int n){\n        int i= (int)sqrt(n);\n        return i*i==n;\n    }\n    int numSquares(int n) {\n        if(n<4) return n;\n        if(isT(n)) return 1;\n        vector<int> dp(n+1,0);\n        dp[0]=0;\n        dp[1]=1;\n        dp[2]=2;\n        dp[3]=3;\n        for(int i=4;i<=n;i++){\n            if(isT(i)) dp[i]=1;\n            else{\n                int mincnt=INT_MAX;\n                for(int t=1;i-t*t>0;t++){\n                    mincnt=min(dp[i-t*t]+1,mincnt);\n                }\n                dp[i]=mincnt;\n            }\n        }\n        return dp[n];\n    }\n};\n```\n\n# 零钱兑换 II\n\n![](./算法刷题记录DAY7/1725524143689.png)\n\n> 思路：\n> ![](./算法刷题记录DAY7/1725524204542.png)\n\n```cpp\nclass Solution {\npublic:\n    int change(int amount, vector<int>& coins) {\n        vector<int> dp(amount+1,0);\n        dp[0]=1;\n        for(int i=0;i<coins.size();i++){\n            for(int j=coins[i];j<=amount;j++){\n                dp[j]+=dp[j-coins[i]];\n            }\n        }\n        return dp[amount];\n    }\n};\n```\n\n# 组合总和 IV\n\n![](./算法刷题记录DAY7/1725525116192.png)\n\n```cpp\n// 一定要开ull\ntypedef unsigned long long ull;\nclass Solution {\npublic:\n    int combinationSum4(vector<int>& nums, int target) {\n        vector<ull> dp(target+1,0);\n        dp[0]=1;\n        for(int i=1;i<=target;i++){\n            for(int j=0;j<nums.size();j++){\n                if(i-nums[j]>=0) dp[i]+=dp[i-nums[j]];\n            }\n        }\n        return (int)dp[target];\n    }\n};\n```\n\n","categories":["算法","动态规划"]},{"title":"网络安全复习-第二章","url":"/2024/09/04/网络安全复习-第二章/","content":"\n\n","categories":["网络信息安全"]},{"title":"网络安全复习-第一章","url":"/2024/09/03/网络安全复习-第一章/","content":"\n# 关键性的安全概念 **CIAAA**\n- C:机密性，对信息资源访问，，开放的限制比如访问控制，加密等\n- I：完整性。保证信息未被不恰当的更改与破坏。\n- A：可用性。合法的访问能够及时有效地得到实施\n- Authenticity (Authentication)：真实性。鉴别(认证)还有翻译成可控。指特性(身份)等可验证，可信\n- Accountability：可审计性。可说明性指实体行为前唯一性的追踪我们书上的描述是不可否认性(non-repudication)\n\n# 安全攻击\n- 被动攻击：被动攻击从本质上是在传输中的偷听或监视，其目的是从传输中获得信息。可分为以下两种：\n> 1、析出消息release of message contens：知道消息内容。\n> \n> 2、通信量分析traffic analysis：不知道具体的消息，但是可以通过消息发送的量来攻击。该方法比较难检测，应对方法是防止而不是检测。——通信量填充来解决 \n![](./网络安全复习-第一章/1.png)\n\n- 主动攻击：主动攻击涉及某些数据流的篡改或一个虚假流的产生可进一步划分为：伪装，重放，篡改消息和拒绝服务。分类：\n> 1. 伪装就是一个实体假装为另一个实体\n>\n> 2. 重放涉及一个数据单元被动获取及后继的重传，以产生一个未授权的效果\n>\n> 3. 消息篡改意味着、一个合法消息的部分被改变，或消息被延迟或改变次序，以产生一个未授权的效果\n>\n> 4. 拒绝服务防止或禁止通信设施的正常使用或管理：Ddos\n>\n> ![](./网络安全复习-第一章/2.png)\n\n# 安全服务\n> CIAAA+访问控制\n> 访问控制：在网络环境中，访问控制是限制和控制经通信链路对主机系统和应用程序进行访问的能力\n\n**越往上定制性越好，越往下透明性越好**\n\n# 安全机制\n\n**密码学是许多安全机制的基础**\n\n1. 特定的安全机制：加密，签名，完整性检验，认证，流量填充等\n> 针对特定攻击方式\n2. 被动的安全机制：信任机制，安全级别，事件检测，安全追踪，安全恢复\n> 不针对某个特定的威胁","categories":["网络信息安全"]},{"title":"算法刷题记录DAY6","url":"/2024/09/02/算法刷题记录DAY6/","content":"\n# [NOIP2002 普及组] 过河卒\n\n## 题目描述\n\n棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。\n\n棋盘用坐标表示，$A$ 点 $(0, 0)$、$B$ 点 $(n, m)$，同样马的位置坐标是需要给出的。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ipmwl52i.png)\n\n现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。\n\n## 输入格式\n\n一行四个正整数，分别表示 $B$ 点坐标和马的坐标。\n\n## 输出格式\n\n一个整数，表示所有的路径条数。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n6 6 3 3\n```\n\n### 样例输出 #1\n\n```\n6\n```\n\n## 提示\n\n对于 $100 \\%$ 的数据，$1 \\le n, m \\le 20$，$0 \\le$ 马的坐标 $\\le 20$。\n\n**【题目来源】**\n\nNOIP 2002 普及组第四题\n\n## 代码\n\n> dp即可，得开long long才能过。\n\n```cpp\n#include<iostream>\n#include<vector>\ntypedef long long ll;\nusing namespace std;\nconst int MAX_N=20,MAX_M=20;\n\nll dp[MAX_N+1][MAX_M+1];\nint n,m;\nint x,y;\nbool checkIsControl(int r,int c){\n  if((r==x&&c==y)||((r-x)*(r-x)+(c-y)*(c-y)==5)) {\n    return true;\n    }\n  return false;\n}\nint main(){\n  cin>>n>>m;\n  cin>>x>>y;\n  dp[0][0]=1;\n  for(int i=0;i<=n;i++){\n    for(int j=0;j<=m;j++){\n      if(i==0&&j==0) continue;\n      if(checkIsControl(i,j)) dp[i][j]=0;\n      else dp[i][j]=((i==0?0:dp[i-1][j])+(j==0?0:dp[i][j-1]));\n    }\n  }\n  cout<<dp[n][m];\n  return 0;\n}\n```\n\n# [NOIP2011 提高组] 铺地毯\n\n## 题目描述\n\n为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。\n\n地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。\n\n## 输入格式\n\n输入共 $n + 2$ 行。\n\n第一行，一个整数 $n$，表示总共有 $n$ 张地毯。\n\n接下来的 $n$ 行中，第 $i+1$ 行表示编号 $i$ 的地毯的信息，包含四个整数 $a ,b ,g ,k$，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标 $(a, b)$ 以及地毯在 $x$ 轴和 $y$ 轴方向的长度。\n\n第 $n + 2$ 行包含两个整数 $x$ 和 $y$，表示所求的地面的点的坐标 $(x, y)$。\n\n## 输出格式\n\n输出共 $1$ 行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出 `-1`。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n3\n1 0 2 3\n0 2 3 3\n2 1 3 3\n2 2\n```\n\n### 样例输出 #1\n\n```\n3\n```\n\n## 样例 #2\n\n### 样例输入 #2\n\n```\n3\n1 0 2 3\n0 2 3 3\n2 1 3 3\n4 5\n```\n\n### 样例输出 #2\n\n```\n-1\n```\n\n## 提示\n\n【样例解释 1】\n\n如下图，$1$ 号地毯用实线表示，$2$ 号地毯用虚线表示，$3$ 号用双实线表示，覆盖点 $(2,2)$ 的最上面一张地毯是 $3$ 号地毯。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q4izfzpb.png)\n\n【数据范围】\n\n对于 $30\\%$ 的数据，有 $n \\le 2$。  \n对于 $50\\%$ 的数据，$0 \\le a, b, g, k \\le 100$。  \n对于 $100\\%$ 的数据，有 $0 \\le n \\le 10^4$, $0 \\le a, b, g, k \\le {10}^5$。   \n\nnoip2011 提高组 day1 第 $1$ 题。\n\n## 代码\n\n> 暴力\n\n```cpp\n#include<iostream>\n#include<vector>\nusing namespace std;\nconst int MAX_N=10000;\nint a[MAX_N+1],b[MAX_N+1],g[MAX_N+1],k[MAX_N+1];\nint n;\nint main(){\n  cin>>n;\n  int res=-1;\n  for(int i=0;i<n;i++){\n    cin>>a[i]>>b[i]>>g[i]>>k[i];\n  }\n  int x,y;\n  cin>>x>>y;\n  for(int i=0;i<n;i++){\n    if(x>=a[i]&&y>=b[i]&&a[i]+g[i]>=x&&b[i]+k[i]>=y) res=i+1;\n  }\n  cout<<res<<endl;\n  return 0;\n}\n```\n\n# 魔族密码\n\n## 题目背景\n\n风之子刚走进他的考场，就……\n\n花花：当当当当~~偶是魅力女皇——花花！！^^（华丽出场，礼炮，鲜花）\n\n风之子：我呕……（杀死人的眼神）快说题目！否则……-\\_-###\n\n## 题目描述\n\n花花：……咦~~好冷~~我们现在要解决的是魔族的密码问题（自我陶醉：搞不好魔族里面还会有人用密码给我和菜虫写情书咧，哦活活，当然是给我的比较多拉\\*^\\_^\\*）。\n\n魔族现在使用一种新型的密码系统。每一个密码都是一个给定的仅包含小写字母的英文单词表，每个单词至少包含 $1$ 个字母，至多 $75$ 个字母。如果在一个由一个词或多个词组成的表中，除了最后一个以外，每个单词都被其后的一个单词所包含，即前一个单词是后一个单词的前缀，则称词表为一个词链。例如下面单词组成了一个词链：\n\n- $\\verb!i!$；\n- $\\verb!int!$；\n- $\\verb!integer!$。\n\n但下面的单词不组成词链：\n\n- $\\verb!integer!$；\n- $\\verb!intern!$。\n\n现在你要做的就是在一个给定的单词表中取出一些词，组成最长的词链，就是包含单词数最多的词链。将它的单词数统计出来，就得到密码了。\n\n风之子：密码就是最长词链所包括的单词数阿……\n\n## 输入格式\n\n这些文件的格式是，第一行为单词表中的单词数 $N$（$1 \\le N \\le 2000$），下面每一行有一个单词，按字典顺序排列，中间也没有重复的单词。\n\n## 输出格式\n\n输出共一行，一个整数，表示密码。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n5\ni\nint\ninteger\nintern\ninternet\n```\n\n### 样例输出 #1\n\n```\n4\n```\n\n## 代码\n\n> 构建字典树\n\n```cpp\n#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nstruct TrirNode\n{\n    bool isWord;\n    vector<TrirNode*> children;\n    TrirNode(): children(26) ,isWord(false) {}\n}*trie;\n\nvoid createTrie(){\n    trie=new TrirNode();\n}\n\nvoid insertHelper(string& word,int index,TrirNode* node){\n    if(index==word.size()) return;\n    int i=word[index]-'a';\n    if(node->children[i]==nullptr){\n        node->children[i]=new TrirNode();\n    }\n    if(node->children[i]->isWord==false) node->children[i]->isWord=(index==word.size()-1);\n    insertHelper(word,index+1,node->children[i]);\n}\n\nvoid insert(string& word){\n    if(word.size()==0) return;\n    insertHelper(word,0,trie);\n}\n\nint res=0;\n\nint findHeight(TrirNode* node){\n    if(node==nullptr) return 0;\n    int maxHeight=0;\n    for(int i=0;i<node->children.size();i++){\n        maxHeight=max(maxHeight,findHeight(node->children[i]));\n    }\n    return maxHeight+(node->isWord?1:0);\n}\n\nvoid findMaxHeight(){\n    res=findHeight(trie);\n}\n\nint main(){\n    int n;\n    string word;\n    cin>>n;\n    createTrie();\n    while (n--)\n    {\n        cin>>word;\n        insert(word);\n    }\n    findMaxHeight();\n    cout<<res<<endl;\n    return 0;\n}\n```\n\n# [NOIP1998 普及组] 阶乘之和\n\n## 题目描述\n\n用高精度计算出 $S = 1! + 2! + 3! + \\cdots + n!$（$n \\le 50$）。\n\n其中 `!` 表示阶乘，定义为 $n!=n\\times (n-1)\\times (n-2)\\times \\cdots \\times 1$。例如，$5! = 5 \\times 4 \\times 3 \\times 2 \\times 1=120$。\n\n## 输入格式\n\n一个正整数 $n$。\n\n## 输出格式\n\n一个正整数 $S$，表示计算结果。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n3\n```\n\n### 样例输出 #1\n\n```\n9\n```\n\n## 提示\n\n**【数据范围】**\n\n对于 $100 \\%$ 的数据，$1 \\le n \\le 50$。\n\n**【其他说明】**\n\n注，《深入浅出基础篇》中使用本题作为例题，但是其数据范围只有 $n \\le 20$，使用书中的代码无法通过本题。\n\n如果希望通过本题，请继续学习第八章高精度的知识。\n\nNOIP1998 普及组 第二题\n\n## 代码\n\n```cpp\n// 20以内能过，大了就错\n#include<iostream>\n\ntypedef long long ll;\n\nusing namespace std;\n\nconst int MAX_N=50;\nvector<ll> nums(MAX_N+1,0);\nnums[0]=1;\nnums[1]=1;\nll func(int n){\n  if(n==0||n==1) return 1;\n  if(nums[n-1]==0){\n    nums[n-1]=func(n-1);\n  }\n  nums[n]=nums[n-1]*n;\n  return nums[n];\n}\nint main(){\n  int n;\n  cin>>n;\n  ll s=0;\n  for(int i=1;i<=n;i++){\n    s+=func(i);\n  }\n  cout<<s;\n  return 0;\n}\n\n```\n\n```cpp\n//题解\n#include<iostream>\n#include<cstdio>\nusing namespace std;\nint n,a[101]={0},s[101]={0};\nvoid change(int x)\n{\n\tint g=0;\n\tfor(int i=100;i>=0;i--)\n\t{\n\t\ta[i]=a[i]*x+g;\n\t\tg=a[i]/10;\n\t\ta[i]=a[i]%10;\n\t}\n}\nvoid qh()\n{\n\tint g=0;\n\tfor(int i=100;i>=0;i--)\n\t{\n\t\ts[i]=s[i]+a[i]+g;\n\t\tg=s[i]/10;\n\t\ts[i]=s[i]%10;\n\t}\n}\nvoid sc()\n{\n\tint w;\n\tfor(int i=0;i<=100;i++)\n\t{\n\t\tif(s[i]!=0)\n\t\t{\n\t\t\tw=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=w;i<=100;i++)\n\t   printf(\"%d\",s[i]);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts[100]=a[100]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tchange(i);\n\t\tqh();\n\t}\n\tsc();\n\treturn 0;\n}\n```\n\n\n","categories":["算法"]},{"title":"算法刷题记录DAY5","url":"/2024/08/13/算法刷题记录DAY5/","content":"\n# 最常见的单词\n\n![](./算法刷题记录DAY5/1723534648949.png)\n\n> 思路：暴力，先将paragraph的`\"!?',;.\"`全部改为空格，然后分隔字符串后依次遍历，判断每个字符串是不是在banned中。\n\n```java\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nclass Solution {\n    public String mostCommonWord(String paragraph, String[] banned) {\n        paragraph=paragraph.replace('!',' ').replace('?',' ').replace('\\'',' ')\n                .replace(',',' ').replace(';',' ').replace('.',' ');\n        String[] split = paragraph.split(\" \");\n        String ans=null;\n        int max=0;\n        Map<String,Integer> map=new HashMap();\n        Set<String> set=new HashSet();\n        for (int i = 0; i < banned.length; i++) {\n            set.add(banned[i]);\n        }\n        for (int i = 0; i < split.length; i++) {\n            String str=split[i].trim().toLowerCase();\n            if((!str.equals(\"\"))&&(!set.contains(str))){\n                System.out.println(str);\n                map.put(str,map.getOrDefault(str,0)+1);\n            }\n        }\n        for (Map.Entry<String, Integer> entry : map.entrySet()) {\n            String key = entry.getKey();\n            Integer value = entry.getValue();\n            if (max<value){\n                max=value;\n                ans=key;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n# 设计哈希集合\n\n![](./算法刷题记录DAY5/1723536250704.png)\n\n> 思路，用取模运算作为散列函数，并且使用追加链表解决哈希冲突\n\n```java\nclass MyHashSet {\n    private final int DEFAULT_SIZE=10;\n\n    private Item[] items;\n\n    public MyHashSet() {\n        items=new Item[DEFAULT_SIZE];\n    }\n\n    public void add(int key) {\n        if(contains(key)) return;\n        int index=key%DEFAULT_SIZE;\n        if(items[index]==null){\n            items[index]=new Item();\n            items[index].value=key;\n        }else{\n            if(items[index].list==null){\n                items[index].list=new LinkedList();\n            }\n            items[index].list.add(key);\n        }\n    }\n\n    public void remove(int key) {\n        int index=key%DEFAULT_SIZE;\n        if(items[index]==null) return;\n        if(items[index].value==key){\n            List<Integer> list = items[index].list;\n            if(list==null||list.isEmpty()){\n                items[index]=null;\n            }else{\n                int lastValue=list.get(list.size()-1);\n                items[index].value=lastValue;\n                list.remove(list.size()-1);\n                if(list.isEmpty()) items[index].list=null;\n            }\n        }else{\n            List<Integer> list=items[index].list;\n            if(list==null) return;\n            int findIndex=-1;\n            for (int i = 0; i < list.size(); i++) {\n                if(list.get(i).equals(key)){\n                    findIndex=i;\n                }\n            }\n            if(findIndex!=-1){\n                list.remove(findIndex);\n                if(list.isEmpty()) items[index].list=null;\n            }\n        }\n    }\n\n    public boolean contains(int key) {\n        int index=key%DEFAULT_SIZE;\n        if(items[index]==null) return false;\n        else{\n            if(items[index].value==key) return true;\n            List<Integer> list = items[index].list;\n            if(list==null) return false;\n            for (int i = 0; i < list.size(); i++) {\n                if(list.get(i).equals(key)) return true;\n            }\n            return false;\n        }\n    }\n\n    public static void main(String[] args) {\n        MyHashSet myHashSet = new MyHashSet();\n        myHashSet.add(1);      // set = [1]\n        myHashSet.add(2);      // set = [1, 2]\n        myHashSet.contains(1); // 返回 True\n        myHashSet.contains(3); // 返回 False ，（未找到）\n        myHashSet.add(2);      // set = [1, 2]\n        myHashSet.contains(2); // 返回 True\n        myHashSet.remove(2);   // set = [1]\n        myHashSet.contains(2); // 返回 False ，（已移除）\n    }\n}\n\nclass Item{\n    int value;\n    List<Integer> list;\n}\n```\n\n","categories":["算法"]},{"title":"算法刷题记录DAY4","url":"/2024/08/11/算法刷题记录DAY4/","content":"\n# 字母异位分词\n\n![](./算法刷题记录DAY4/1723365543223.png)\n\n> 思路：用一个count记录p中26个字母出现的频率，再遍历s，用数组cnt记录s中从i到i+len-1中各字母出现的频率，重点是cnt数组的更新：i迭代时，不需要再重新遍历i到i+len-1，只需要更新一头一尾的字母频率。\n\n```cpp\nclass Solution {\npublic:\n    vector<int> findAnagrams(string s, string p) {\n        vector<int> res;\n        int len=p.size();\n        int n=s.size();\n        vector<int> count(26,0);\n        for(int i=0;i<len;i++){\n            count[p[i]-'a']++;\n        }\n        vector<int> cnt(26,0);\n        for(int i=0;i<=n-len;i++){\n            if(i==0){\n                for(int j=0;j<len;j++){\n                    cnt[s[i+j]-'a']++;\n                }\n            }\n            bool flag=true;\n            for(int k=0;k<26;k++){\n                if(cnt[k]!=count[k]) {\n                    flag=false;\n                    break;\n                }\n            }\n            if(flag){\n                res.push_back(i);\n            }\n            if(i!=n-len){\n                cnt[s[i]-'a']--;\n            cnt[s[i+len]-'a']++;\n            }\n        }\n        return res;\n    }\n};\n```\n\n# 合并区间\n\n![](./算法刷题记录DAY4/1723367494958.png)\n\n> 思路：排序即可：先按start升序排序，start值相同的区间end值大的在前；排序好后遍历区间即可。\n\n```java\nclass Solution {\n    public int[][] merge(int[][] intervals) {\n        Arrays.sort(intervals, new Comparator<int[]>() {\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                if(o1[0]>o2[0]) return 1;\n                else if(o1[0]<o2[0]) return -1;\n                else{\n                    if(o1[1]<o2[1]) return 1;\n                    else if(o1[1]>o2[1]) return -1;\n                    return 0;\n                }\n            }\n        });\n        List<int[]> res=new LinkedList();\n        int begin=0;\n        int end=0;\n        for(int i=0;i<intervals.length;i++){\n            if(i==0){\n                begin=intervals[0][0];\n                end=intervals[0][1];\n            }else{\n                if(end>=intervals[i][0]&&end<intervals[i][1]){\n                    end=intervals[i][1];\n                }else if(end>=intervals[i][1]){\n                    \n                }else if(end<intervals[i][0]){\n                    res.add(new int[]{begin,end});\n                    begin=intervals[i][0];\n                    end=intervals[i][1];\n                }\n            }\n            if(i==intervals.length-1){\n                res.add(new int[]{begin,end});\n            }\n        }\n        int[][] ans=new int[res.size()][2];\n        int index=0;\n        for (int[] re : res) {\n            ans[index][0]=re[0];\n            ans[index][1]=re[1];\n            index++;\n        }\n        return ans;\n    }\n}\n```\n\n> **STL自定义排序**\n\n由于我对这个不是特别熟悉，这里记录一下\n\n1. sort简介\n- 内部实现方法类似于快排，时间复杂度为$nlog2(n)$\n- 需要引入头文件 `#include<algorithm>`\n\n2. sort使用方法\n- 调用形式：`sort(first,last,cmp)` 其中，first是元素的起始地址，last是结束地址，cmp是排序的方式。对[first，last)（一定要注意这里的区间是左闭又开）区间内数据根据cmp的方式进行排序。也可以不写第三个参数，此时按默认排序，从小到大进行排序。\n\n3. 自定义排序\n- 自定义比较函数cmp\n```cpp\nbool cmp(vector<int> nums1,vector<int> nums2){\n    if(nums1[0]>nums2[0]) return true;\n    else if(nums1[0]<nums2[0]) return false;\n    else{\n        if(nums1[1]<nums2[1]) return false;\n        else if(nums1[1]>nums2[1]) return false;\n        return true;\n    }\n}\n```\n**传入的参数类型和需要排序的数据类型一致**\n- 重载比较运算符“<”\n```cpp\nbool operator< (const Student& s1, const Student& s2)\n{\n    if(s1.age==s2.age) return s1.name <s2.name;//年龄相同时，按姓名小到大排\n    else return s1.age > s2.age; //从年龄大到小排序\n}\nsort(a,a+n);\n```\n**参数类型如果是自定义类型，比如自己定义的结构体，类，尽管sort函数默认是从小到大排列，但是这里必须要重载比较运算符“<”!!!**\n\n- 声明比较类\n```cpp\nstruct cmp\n{\n    bool operator() (const Student& s1, const Student& s2)\n    {\n        if(s1.age==s2.age) return s1.name <s2.name;\n        else  return s1.age < s2.age;\n    }\n};\nsort(a,a+n,cmp());\n```\n\n**[参考](https://blog.csdn.net/weixin_41588502/article/details/86620305)**\n\n# 除自身以外数组的乘积\n\n![](./算法刷题记录DAY4/1723450251113.png)\n\n```cpp\nclass Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        int n=nums.size();\n        vector<int> prefix(n,1);\n        vector<int> endfix(n,1);\n        prefix[0]=nums[0];\n        for(int i=1;i<n;i++){\n           prefix[i]=prefix[i-1]*nums[i];\n        }\n        endfix[n-1]=nums[n-1];\n        for(int i=n-2;i>=0;i--){\n            endfix[i]=endfix[i+1]*nums[i];\n        }\n        vector<int> ans(n,0);\n        for(int i=0;i<n;i++){\n            ans[i]=(i>0?prefix[i-1]:1)*(i<n-1?endfix[i+1]:1);\n        }\n        return ans;\n    }\n};\n```\n\n> 优化：从左往右遍历时使用answer数组进行计算，而从右往左遍历时只使用一个变量进行记录即可减小空间复杂度。\n\n```cpp\nclass Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        int length = nums.size();\n        vector<int> answer(length);\n\n        // answer[i] 表示索引 i 左侧所有元素的乘积\n        // 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1\n        answer[0] = 1;\n        for (int i = 1; i < length; i++) {\n            answer[i] = nums[i - 1] * answer[i - 1];\n        }\n\n        // R 为右侧所有元素的乘积\n        // 刚开始右边没有元素，所以 R = 1\n        int R = 1;\n        for (int i = length - 1; i >= 0; i--) {\n            // 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R\n            answer[i] = answer[i] * R;\n            // R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上\n            R *= nums[i];\n        }\n        return answer;\n    }\n};\n\n// 作者：力扣官方题解\n// 链接：https://leetcode.cn/problems/product-of-array-except-self/solutions/272369/chu-zi-shen-yi-wai-shu-zu-de-cheng-ji-by-leetcode-/\n// 来源：力扣（LeetCode）\n// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n# 岛屿数量\n\n![](./算法刷题记录DAY4/1723389400817.png)\n\n> 思路：对二维数组使用dfs，使用了多少次dfs则代表有多少个岛屿\n\n```cpp\nclass Solution {\npublic:\n    int m,n;\n    int dir[4][2]={\n        {-1,0},\n        {1,0},\n        {0,-1},\n        {0,1}\n    };\n    int numIslands(vector<vector<char>>& grid) {\n        m=grid.size();\n        n=grid[0].size();\n        int ans=0;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(grid[i][j]=='1'){\n                    ans++;\n                    dfs(grid,i,j);\n                }\n            }\n        }\n        return ans;\n    }\n    void dfs(vector<vector<char>> &grid,int row,int col){\n        if(row<0||row>=m||col<0||col>=n) return;\n        if(grid[row][col]=='0') return;\n        grid[row][col]='0';\n        for(int i=0;i<4;i++){\n            int nx=row+dir[i][0];\n            int ny=col+dir[i][1];\n            dfs(grid,nx,ny);\n        }\n    }\n};\n```\n\n# 括号生成\n\n![](./算法刷题记录DAY4/1723390811334.png)\n\n> 思路：暴力，每个位置只有`'('`和`')'`两种可能，总共有 $4^n$ 种可能，n最大为8，可能会超时，优化一下：依据左右括号数目应该相同，进行减枝。\n\n```cpp\n#include<stack>\nclass Solution {\npublic:\n    vector<string> ans;\n    vector<string> generateParenthesis(int n) {\n        dfs(\"\",n,0);\n        return ans;\n    }\n    void dfs(string s,int n,int lcnt){\n        if(s.size()==2*n&&lcnt==n&&check(s)){\n            ans.push_back(s);\n            return;\n        }\n        int rcnt=s.size()-lcnt;\n        if(rcnt<n){\n            dfs(s+')',n,lcnt);\n        }\n        if(lcnt<n){\n            dfs(s+'(',n,lcnt+1);\n        }\n    }\n    bool check(string s){\n        stack<char> stk;\n        for(int i=0;i<s.size();i++){\n            if(s[i]=='(') stk.push(s[i]);\n            else{\n                if(stk.size()==0) return false;\n                if(stk.top()=='('){\n                    stk.pop();\n                }else return false;\n            }\n        }\n        return stk.size()==0;\n    }\n};\n```\n","categories":["算法"]},{"title":"算法刷题记录DAY3","url":"/2024/08/08/算法刷题记录DAY3/","content":"\n# 位运算的奇巧淫技\n\n- 判断奇偶数\n`x&1=1`为奇数，`x&1=0`为偶数\n\n- 获取二进制位是1还是0\n左移后和1作&运算\n\n- 交换两个整数变量的值\n```cpp\nx=x^y;\ny=x^y;\nx=x^y;\n```\n- 不用判断语句，求整数的绝对值\n\n## 异或性质\n\n![](./算法刷题记录DAY3/1723186263238.png)\n\n# 找出唯一成对的数\n\n![](./算法刷题记录DAY3/1723186362438.png)\n\n> 思路：可以利用set，也可以单独开一个长度1000的数组，但是都不符合题意；这个时候可以利用`^`运算：\n```\nA^A=0;\nA^A^B^C^C=B;\nA^A^A=A;\n```\n即奇数个一样的数异或等于它本身。\n\n```cpp\nint slove(vector<int> &nums){\n    int n=1000;\n    int number=0;\n    number=number^nums[0];\n    for(int i=1;i<=n;i++){\n        number=number^i;\n        number=number^nums[i];\n    }\n    return number;\n}\n```\n\n# 二进制中1的个数\n\n![](./算法刷题记录DAY3/1723187280829.png)\n\n> 思路1：获取到该数中二进制的每一位，计算为1的个数\n\n```cpp\nint slove(int n){\n    int ans=0;\n    while(n){\n        ans+=(n&1);\n        n>>1;\n    }\n    return ans;\n}\n```\n\n> 思路2：x&(x-1)可以将x中最低位的1变成0，循环操作即可，循环次数即为1的个数\n\n```cpp\nint solve(int n){\n    int ans=0;\n    while(n){\n        n=n&(n-1);\n        ans++;\n    }\n    return ans;\n}\n```\n\n# 是不是2的整数次方\n\n用1条语句判断一个整数是不是2的整数次方\n\n> 思路：x&(x-1)之后可以将x最低位的1变成0，如果x是2的整数次方，则x二进制中只有一个1，与x-1作&运算之后将变为0；\n\n```cpp\nbool slove(int n){\n    return x&(x-1) ==0 ;\n}\n```\n\n# 将整数的奇偶位互换\n\n> 思路：![](./算法刷题记录DAY3/1723188154647.png)\n![](./算法刷题记录DAY3/1723188213237.png)\n然后将c左移一位、d右移一位，拼接在一起即可\n\n```cpp\nint slove(int n){\n    int a=0x55555555;\n    int b=0xaaaaaaaa;\n    int c=a&n;\n    int d=b&n;\n    return (c<<1)|(d>>1);\n}\n```\n\n# 0~1间浮点实数的二进制表示\n\n![](./算法刷题记录DAY3/1723188474391.png)\n\n> 思路：依次小数*2取整数位即可。\n\n```cpp\n#include<string>\nvoid slove(double a){\n    string ans=\"0.\";\n    int count=0;\n    while(a>0&&count<32){\n        a=a*2;\n        if(a>=1) {\n            ans+=\"1\";\n            a-=1;\n        }else{\n            ans+=\"0\";\n        }\n        count++;\n    }\n    if(a>0) cout<<\"ERROR\"<<endl;\n    else cout<<ans<<endl;\n}\n```\n\n# 出现K次与出现1次\n\n![](./算法刷题记录DAY3/1723188840312.png)\n\n> 思路：k个相同的数作k进制下的不进位加和结果为0，所以只需要这些数全部作k进制下的不进位加和，将结果还原即为答案。\n\n```cpp\nint slove(vector<int> &nums,int k){\n    vector<vector<int>> numskradix(nums.size(),vector<int>());\n    //求每个数的k进制表示\n    int maxlen=0;\n    for(int i=0;i<nums.size();i++){\n        int t=nums[i];\n        while(t){\n            numskradix[i].push_back(t%k);\n            t=t/k;\n        }\n        maxlen=max(maxlen,numskradix[i].size());\n    }\n\n    //计算\n    vector<int> arr(maxlen,0);\n    for(int i=0;i<maxlen;i++){\n        for(int j=0;j<nums.size();j++){\n            if(i<numskradix[j].size()){\n                arr[i]=(arr[i]+numskradix[j][i])%k;\n            }\n        }\n    }\n\n    //复原\n    int ans=0;\n    int m=1;\n    for(int i=0;i<maxlen;i++){\n        ans+=arr[i]*m;\n        m=m*k;\n    }\n    return ans;\n}\n```\n","categories":["算法","位运算"]},{"title":"sql递归查询","url":"/2024/08/07/sql递归查询/","content":"\n# 前言\n\n之前在南大夏令营笔试遇到一题SQL递归查询的，当时空在那，现在补一下\n\n# MySQL with Recursive\nMySQL with Recursive是一种基于递归思想的MySQL查询方式，可以实现对数据的递归查询和处理，返回符合条件的数据。在MySQL 8.0版本中，该功能被正式引入。\n\n> WITH RECURSIVE 语句包含两部分：\n> - 递归部分: 定义了如何递归查询数据;\n> - 终止条件部分: 定义了递归查询何时停止。\n\n## 语法\n\n```sql\nWITH RECURSIVE recursive_query_name (col1, col2, ..., coln) AS (\n    -- 递归部分\n    SELECT \n\t\t\tinitial_query_result_col1, \n\t\t\tinitial_query_result_col2, \n\t\t\t...,\n\t\t\tinitial_query_result_coln\n    FROM initial_query\n    UNION ALL\n    SELECT \n\t\t\trecursive_query_result_col1,\n\t\t\trecursive_query_result_col2, \n\t\t\t..., \n\t\t\trecursive_query_result_coln\n    FROM recursive_query_name, recursive_query\n    WHERE recursive_query_condition\n)\n-- 终止条件部分\nSELECT * FROM recursive_query_name ;\n```\n\n![](./sql递归查询/1.png)\n\n### 案例\n\n![](./sql递归查询/image.png)\n\n![](./sql递归查询/04ecb3374db9d50e65baea1384bb6cbc.png)\n\n> 分析：`SELECT p.* FROM course_category p WHERE p.id = '1' ` 这个sql结果赋值给t1;然后通过这个初次查询结果的t1表继续去跟course_category联查,符合where条件的再赋值给t1;直至没有符合条件的;最后需要的数据都在t1表里了,只需要查询t1表即可;\n\n# 参考\n[CSDN](https://blog.csdn.net/djdjfjf1/article/details/134808935)\n","categories":["sql"]},{"title":"codeforces-964-div4","url":"/2024/08/07/codeforces-964-div4/","content":"\n# 前言\n\n本想先拿div4的难度入个门，没想到只会签到题，还是太菜了。。。\n\n# A. A+B\n\n![](./codeforces-964-div4/1723016317231.png)\n\n```cpp\n#include<iostream>\n\nusing namespace std;\n\nint main(){\n    int t;\n    cin>>t;\n    int a;\n    while(t--){\n        cin>>a;\n        cout<<a/10+a%10<<endl;\n    }\n    return 0;\n}\n```\n\n# B. Card Game\n\n![](./codeforces-964-div4/1723016430524.png)\n![](./codeforces-964-div4/1723016563903.png)\n\n> 思路：情况很少，枚举出来就行\n\n```cpp\n#include<iostream>\n\nusing namespace std;\n\nint func(int a1,int a2,int b1,int b2){\n    int ans=0;\n    //a1-b1 a2-b2\n    if(a1>b1&&a2>b2) ans+=2;\n    else if(a1>b1&&a2==b2) ans+=2;\n    else if(a1==b1&&a2>b2) ans+=2;\n\n    //a1-b2 a2-b1\n    if(a1>b2&&a2>b1) ans+=2;\n    else if(a1>b2&&a2==b1) ans+=2;\n    else if(a1==b2&&a2>b1) ans+=2;\n    return ans;\n}\nint main(){\n    int t;\n    cin>>t;\n    int a1,a2,b1,b2;\n    while(t--){\n        cin>>a1>>a2>>b1>>b2;\n        cout<<func(a1,a2,b1,b2)<<endl;\n    }\n    return 0;\n}\n```\n\n# C. Showering\n\n![](./codeforces-964-div4/1723016780857.png)\n![](./codeforces-964-div4/1723016998339.png)\n\n> 思路：计算区间间距，大于s就可以\n\n```cpp\n#include<iostream>\n#include<vector>\n\nusing namespace std;\nbool func(int n,int s,int m,vector<pair<int,int>> &nums){\n    int before=0;\n    if(m-nums[n-1].second>=s) return true;\n    for(int i=0;i<n;i++){\n        if(nums[i].first-before>=s) return true;\n        else{\n            before=nums[i].second;\n        }\n    }\n    return false;\n}\nint main(){\n    int t;\n    cin>>t;\n    int a;\n    int n,s,m;\n    while(t--){\n        cin>>n>>s>>m;\n        vector<pair<int,int>> nums(n);\n        for(int i=0;i<n;i++){\n            cin>>nums[i].first>>nums[i].second;\n        }\n        if(func(n,s,m,nums)){\n            cout<<\"YES\"<<endl;\n        }else{\n            cout<<\"NO\"<<endl;\n        }\n    }\n    return 0;\n}\n```\n\n# D. Slavic's Exam\n\n![](./codeforces-964-div4/1723016954808.png)\n![](./codeforces-964-div4/1723017090563.png)\n\n> 思路：\n\n\n# E. Triple Operations\n\n![](./codeforces-964-div4/image.png)\n\n> 思路：\n\n\n# F. Expected Median\n\n![](./codeforces-964-div4/1723017618441.png)\n\n![](./codeforces-964-div4/1723017667456.png)\n\n> 思路：\n\n\n# G1. Ruler (easy version)\n\n![](./codeforces-964-div4/1723017842288.png)\n![](./codeforces-964-div4/1723017873538.png)\n![](./codeforces-964-div4/1723017899752.png)\n\n> 思路：\n\n# G2. Ruler (hard version)\n\n![](./codeforces-964-div4/1723017988966.png)\n![](./codeforces-964-div4/1723018030170.png)\n![](./codeforces-964-div4/1723018053558.png)\n\n> 思路：\n\n","categories":["算法"]},{"title":"数学","url":"/2024/08/05/数学/","content":"\n[参考](https://www.bilibili.com/video/BV1Ei4y137gj/?spm_id_from=333.337.search-card.all.click&vd_source=1e4dde82b17a014f17a01a1aada081b1)\n\n# 集卡片 [原题链接](http://acm.hdu.edu.cn/showproblem.php?pid=1099)\n![](./数学/image.png)\n\n> 关键思想：知道此处期望是概率的倒数即可，<br>\n> 比如有5张卡片，<br>\n- 第一步你获得想要卡片的概率是1，倒数为1；<br>\n- 第二步你获得想要卡片的概率是4/5，倒数为5/4；<br>\n- 第三步你获得想要卡片的概率是3/5，倒数为5/3；<br>\n……累加即为结果\n\n```cpp\n#include <iostream>\nusing namespace std;\n\ntypedef long long ll;\n\nll GCD(ll a,ll b){\n    if(a==0||b==0)return 1; \n    return a%b==0?b:GCD(b,a%b);\n}\n\nint digits(ll n){\n    int d=0;\n    while(n){\n        n/=10;\n        d++;\n    }\n    return d;\n}\n\nint main(){\n    int n;\n    ll num,deno,inte;//分子分母整数部分 \n    while(scanf(\"%d\",&n)!=EOF){\n        num=0,deno=1,inte=1;\n        for(int i=1;i<=n-1;i++){ \n            num=num*i+deno*n;\n            deno=deno*i;\n            ll gcd=GCD(num,deno);//约分 \n            num/=gcd;\n            deno/=gcd; \n        } \n        inte+=num/deno;//整数部分 \n        num=num%deno;//分数部分 \n        if(num==0)printf(\"%lld\\n\",inte);//若能整除 \n        else{//格式化输出 \n            for(int i=0;i<=digits(inte);i++)printf(\" \"); \n            printf(\"%lld\\n\",num);\n            printf(\"%lld \",inte);\n            for(int i=0;i<digits(deno);i++)printf(\"-\");\n            printf(\"\\n\");\n            for(int i=0;i<=digits(inte);i++)printf(\" \");\n            printf(\"%lld\\n\",deno);\n        }\n\n    }\n    return 0;\n}\n```\n\n[来源](https://www.cnblogs.com/G-M-WuJieMatrix/p/7400401.html)\n\n# 随机数生成器\n\n![](./数学/1722852855899.png)\n\n> 使用","categories":["算法","数学"]},{"title":"力扣热题100","url":"/2024/08/04/力扣热题100/","content":"# 两数之和\n> easy\n\n![](./力扣热题100/image.png)\n\n> 用哈希存储遍历过的元素即可\n\n```cpp\n#include<vector>\n#include<map>\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        vector<int> ans;\n        map<int,int> mp;\n        for(int i=0;i<nums.size();i++){\n            if(mp[target-nums[i]]!=0){\n                ans.push_back(mp[target-nums[i]]-1);\n                ans.push_back(i);\n                return ans;\n            }else{\n                mp[nums[i]]=i+1;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n# 字母异位词分组\n> medium\n\n![](./力扣热题100/1722785853405.png)\n\n> 一开始的思路是计算每个字符串的哈希值，两个异位词的哈希值相同，但是想不出怎么计算比较合适，于是改成直接排序字符串\n\n```cpp\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<map>\n\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        vector<vector<string>> ans;\n        map<string,int> mp;\n        for(int i=0;i<strs.size();i++){\n            string ss=sort_(strs[i]);\n            auto fd=mp.find(ss);\n            if(fd!=mp.end()){\n                int index=mp[ss];\n                ans[index].push_back(strs[i]);\n            }else{\n                mp[ss]=ans.size();\n                ans.push_back(vector<string>(1,strs[i]));\n            }\n        }\n        return ans;\n    }\n\n    string sort_(string str){\n        sort(str.begin(),str.end());\n        return str;\n    }\n};\n```\n\n> 官方题解中另一种方法是用字符和该字符出现的次数拼接成字符串作为哈希map的键，感觉也大差不差\n![](./力扣热题100/1722787345351.png)\n\n```java\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        Map<String, List<String>> map = new HashMap<String, List<String>>();\n        for (String str : strs) {\n            int[] counts = new int[26];\n            int length = str.length();\n            for (int i = 0; i < length; i++) {\n                counts[str.charAt(i) - 'a']++;\n            }\n            // 将每个出现次数大于 0 的字母和出现次数按顺序拼接成字符串，作为哈希表的键\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < 26; i++) {\n                if (counts[i] != 0) {\n                    sb.append((char) ('a' + i));\n                    sb.append(counts[i]);\n                }\n            }\n            String key = sb.toString();\n            List<String> list = map.getOrDefault(key, new ArrayList<String>());\n            list.add(str);\n            map.put(key, list);\n        }\n        return new ArrayList<List<String>>(map.values());\n    }\n}\n```\n\n> 作者：[力扣官方题解](https://leetcode.cn/problems/group-anagrams/solutions/520469/zi-mu-yi-wei-ci-fen-zu-by-leetcode-solut-gyoc/)\n来源：力扣（LeetCode）\n\n# 最长连续序列\n\n![](./力扣热题100/1723019783568.png)\n\n> 思路：先用set存好数，然后用每个数去匹配，这样大概是$O(n^2)$复杂度，改进：遍历set中的数，每对一个数进行匹配，当前数num的前驱num-1不能在set中。\n\n```cpp\n#include<vector>\n#include<set>\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        set<int> st;\n        int n=nums.size();\n        for(int i=0;i<n;i++){\n            st.insert(nums[i]);\n        }\n        int ans=0;\n        for(int num:st){\n            if(!st.count(num-1)){\n                int cur=num;\n                int len=1;\n                while(st.count(cur+1)){\n                    cur++;\n                    len++;\n                }\n                ans=max(ans,len);\n            }\n        }\n        return ans;\n    }\n};\n```\n\n# 盛最多水的容器\n\n> medium\n\n![](./力扣热题100/1723020925708.png)\n![](./力扣热题100/1723020968959.png)\n![](./力扣热题100/1723021071234.png)\n\n> 思路：双指针法，从两边向中间遍历，每次移动那个height值更小的位置指针，因为如果移动更大的指针，则之后面积一定会比当前的面积更小。**短板效应**\n\n```cpp\nclass Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        int left=0;\n        int right=height.size()-1;\n        int ans=0;\n        int s=0;\n        while(left<right){\n            s=(right-left)*min(height[left],height[right]);\n            ans=max(ans,s);\n            if(height[left]<height[right]) left++;\n            else right--;\n        }\n        return ans;\n    }\n};\n```\n\n# 缺失的第一个正数\n\n<p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p> 请你实现时间复杂度为 \n<code>O(n)</code> 并且只使用常数级别额外空间的解决方案。\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,0]\n<strong>输出：</strong>3\n<strong>解释：</strong>范围 [1,2] 中的数字都在数组中。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,4,-1,1]\n<strong>输出：</strong>2\n<strong>解释：</strong>1 在数组中，但 2 没有。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [7,8,9,11,12]\n<strong>输出：</strong>1\n<strong>解释：</strong>最小的正数 1 没有出现。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul> \n <li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li> \n <li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li> \n</ul>\n\n<div><div>Related Topics</div><div><li>数组</li><li>哈希表</li></div></div><br><div><li>👍 2187</li><li>👎 0</li></div>\n\n> 思路：用set存下每个大于0的数，然后遍历，这里因为set是升序的，所以容易找到缺了哪个\n\n```c++\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        set<int> st;\n        for (int num:nums) {\n            if(num>0) st.insert(num);\n        }\n        int res=0;\n        for(int num:st){\n            if(num==res+1) res++;\n            else return res+1;\n        }\n        return res+1;\n    }\n};\n```\n","categories":["算法","Leetcode热题100"]},{"title":"算法刷题记录DAY2","url":"/2024/08/04/算法刷题记录DAY2/","content":"\n# 华为2016研发工程师编程题 [牛客网](https://www.nowcoder.com/exam/test/81883766/detail?pid=710802&examPageSource=Company&testCallback=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fcompany%3FcurrentTab%3Drecommand%26jobId%3D100%26selectStatus%3D0%26tagIds%3D239&testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91)\n\n## 删数\n![](./算法刷题记录DAY2/image.png)\n\n> 思路：用计数器计数即可\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\nvoid solve(int n) {\n    stack<int> stk;\n    vector<bool> nums(n, true);\n    int count = 0;\n    int index = 0;\n    while (stk.size() < n) {\n        if (nums[index] && count == 2) {\n            nums[index] = false;\n            stk.push(index);\n            count = 0;\n            index = (index + 1) % n;\n        } else if (!nums[index]) {\n            index = (index + 1) % n;\n        } else {\n            index = (index + 1) % n;\n            count++;\n        }\n    }\n    cout << stk.top() << endl;\n}\nint main() {\n    int n;\n    while(cin>>n){\n        solve(n);\n    }\n    return 0;\n}\n// 64 位输出请用 printf(\"%lld\")\n```\n\n## 字符集合\n![](./算法刷题记录DAY2/image1.png)\n\n> 思路：用set记录之前出现过的字符即可\n\n```cpp\n#include <iostream>\n#include <set>\n#include <string>\nusing namespace std;\n\nvoid solve(string &s){\n    set<char> st;\n    for(int i=0;i<s.length();i++){\n        if(st.count(s[i])) continue;\n        else{\n            st.insert(s[i]);\n            cout<<s[i];\n        }\n    }\n    cout<<endl;\n}\nint main() {\n    string s;\n    while(cin>>s){\n        solve(s);\n    }\n    return 0;\n}\n// 64 位输出请用 printf(\"%lld\")\n```\n\n## 数独\n![](./算法刷题记录DAY2/image3.png)\n\n> 思路：使用回溯法，一行一行的进行搜索<br>\n注意：不需要用数组存储该位置可以放的数\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <set>\n#define SIZE 9\n\nusing namespace std;\n\nvector<vector<int>> map(SIZE, vector<int>(SIZE));\n// int cnt = 0;\nint notzerocnt = 0;\nbool check(int row, int col, int num)\n{\n    for (int i = 0; i < SIZE; i++)\n    {\n        if (map[row][i] == num || map[i][col] == num)\n            return false;\n    }\n    int rb = (row / 3) * 3;\n    int cb = (col / 3) * 3;\n    for (int i = rb; i < rb + 3; i++)\n    {\n        for (int j = cb; j < cb + 3; j++)\n        {\n            if (map[i][j] == num)\n                return false;\n        }\n    }\n    return true;\n}\nvoid print()\n{\n    for (int i = 0; i < 9; i++)\n    {\n        for (int j = 0; j < 9; j++)\n        {\n            cout << map[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\nvoid backtrace(int n, int notzerocnt)\n{\n    int row = n / 9;\n    int col = n % 9;\n    if (n == 81 || notzerocnt == 81)\n    {\n        print();\n        return;\n    }\n    if (map[row][col] != 0)\n    {\n\n        if (col < SIZE - 1)\n        {\n            backtrace(++n, notzerocnt);\n        }\n        else\n        {\n            backtrace(++n, notzerocnt);\n        }\n    }\n    else\n    {\n        for (int i = 1; i <= SIZE; i++)\n        {\n\n            if (check(row, col, i))\n            {\n                map[row][col]=i;\n                backtrace(n+1, notzerocnt+1);\n                map[row][col]=0;\n            }\n        }\n    }\n}\nint main()\n{\n\n    for (int i = 0; i < SIZE; i++)\n    {\n        for (int j = 0; j < SIZE; j++)\n        {\n            cin >> map[i][j];\n            if (map[i][j] != 0)\n                notzerocnt++;\n        }\n    }\n    backtrace(0, notzerocnt);\n}\n```","categories":["算法"]},{"title":"CSAPP-Lab1-data","url":"/2024/08/04/CSAPP-Lab1-data/","content":"\n\n# 实验准备\n\n> 了解! ~ & ^ | + << >> 运算符\n**&（按位与）、|（按位或）、^（按位异或）、~（按位取反）和<<（左移）、>>（右移）都是直接在整数的补码表示上进行运算。**\n\n1. ! 运算符\n    - 若对布尔值进行运算非false则true，非true则false。\n    - 若对整数进行运算，C语言中的整数可以直接在逻辑表达式中隐式地转换为布尔值，其中非零整数转换为 true，零整数转换为 false，计算规则同上。\n2. ~ 运算符 \n    对操作数的每一位进行取反。在补码表示中，按位取反然后加1等价于取一个数的二进制补码。但是，~ 运算符本身不涉及补码转换，它只是简单地翻转每一位。\n3. & 运算符\n\t对两个操作数的对应位进行逻辑与操作。由于操作数已经是补码形式，直接进行位运算。\n4. ^ 运算符\n\t对两个操作数的对应位进行逻辑异或操作。与 & 类似，直接在补码形式上进行。\n5. | 运算符\n\t对两个操作数的对应位进行逻辑或操作，同样直接在补码形式上进行。\n6. \\+ 运算符\n\t加法运算符在补码表示上直接进行。如果操作数是整数，它们已经是补码形式，加法运算会考虑溢出。\n7. << 、>>运算符\n    - 左移运算符将操作数的所有位向左移动指定的位数，空出的位填充为0。\n    - 右移运算符将操作数的所有位向右移动指定的位数。\n        - 逻辑右移用0填充空出的位；\n        - 算术右移用符号位填充空出的位。\n\n\n# 1-bitXor\n\n> 要求：\n bitXor - x^y using only ~ and & \n Example: bitXor(4, 5) = 1\n Legal ops: ~ &\n Max ops: 14\n Rating: 1\n \n 代码\n```c\nint bitXor(int x, int y) {\n  int ans=~((~((~x)&y))&(~(x&(~y))));\n  return ans;\n}\n```\n\n# 1-tmin\n\n> 要求：\ntmin - return minimum two's complement integer \nLegal ops: ! ~ & ^ | + << >>\nMax ops: 4\nRating: 1\n\n代码：\n```c\nint tmin(void) {\n  int ans=1<<31;\n  return ans;\n}\n```\n\n# 2-isTmax\n\n> 要求：\n  isTmax - returns 1 if x is the maximum, two's complement number,\n  and 0 otherwise \n  Legal ops: ! ~ & ^ | +\n  Max ops: 10\n \n 代码：\n```c\nint isTmax(int x) {\n  int plus1=x+1;\n  plus1=(plus1^x);\n  int tmp=((plus1>>31)&1);\n  int ans=tmp&(!(x>>31)&1);\n  return ans;\n}\n```\n\n# 2-allOddBits\n\n> 要求：\nallOddBits - return 1 if all odd-numbered bits in word set to 1\n  where bits are numbered from 0 (least significant) to 31 (most significant)\n  Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1\n  Legal ops: ! ~ & ^ | + << >>\n  Max ops: 12\n  Rating: 2\n\n```c\nint allOddBits(int x) {\n  /*\n   */\n  int t1=(x&0xAA)^0xAA;\n  int t2=((x>>8)&0xAA)^0xAA;\n  int t3=((x>>16)&0xAA)^0xAA;\n  int t4=((x>>24)&0xAA)^0xAA;\n  int t=!(t1+t2+t3+t4);\n  return t;\n}\n```\n","categories":["计算机基础","CSAPP"]},{"title":"CSAPP-Lab0-环境搭建","url":"/2024/08/04/CSAPP-Lab0-环境搭建/","content":"\n# 使用工具\nWindows 11，WSL，VScode，GCC编译套装\n\n# 安装步骤\n## WSL安装Ubuntu\n\n参考：**[安装WSL](https://blog.csdn.net/weixin_57367513/article/details/135001273)**\n\n## VScode配置WSL插件\nvscode搜索如下插件进行安装：![alt text](./CSAPP-Lab0-环境搭建/image.png)\n参考：**[安装WSL插件](https://blog.csdn.net/yanbober/article/details/138245581)**\n\n## 安装GCC编译套装\n打开WSL命令行窗口，输入 `sudo apt-get update` \n然后输入下面三条指令：\n```shell\nsudo apt-get install build-essential\nsudo apt-get install gcc-multilib\nsudo apt-get install gdb\n```\n参考：**[GCC编译套装的安装](https://blog.csdn.net/qq_45703010/article/details/120897185)**","categories":["计算机基础","CSAPP"]},{"title":"树","url":"/2024/08/04/树/","content":"\n\n# 树的定义\n\n![](树/Untitled.png)\n\n![](树/Untitled%201.png)\n\n![](树/Untitled%202.png)\n\n![](树/Untitled%203.png)\n\n## 树的性质\n\n![](树/Untitled%204.png)\n\n# 二叉树\n\n二叉树是另一种树形结构，其特点是每个结点至多只有两棵子树( 即二叉树中不存在度大于2的结点)，并且二叉树的子树有左右之分，其次序不能任意颠倒。\n\n![](树/Untitled%205.png)\n\n![](树/Untitled%206.png)\n\n## 满二叉树\n\n每个节点要么是叶节点，要么是有两个子节点的节点\n\n## 完全二叉树\n\n每一层都从左往右尽量铺满\n\n## 二叉树的实现\n\n```java\nimport java.util.*;\n\n/**\n * 二叉检索树：对任意一个节点，\n *      左子树上的节点的值均小于该节点的值\n *      右子树上的节点的值均不小于该节点的值\n */\npublic class MyBST<K extends Comparable<K> ,V> implements BST<K,V>{\n\n    private BinNode<K,V> root;\n    public MyBST(){\n        root=null;\n    }\n    @Override\n    public void insert(K key, V value) {\n        if (key==null){\n            try {\n                throw new Exception(\"key is null.\");\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return;\n        }\n        root=insertHelper(key,value,root);\n    }\n\n    private BinNode<K,V> insertHelper(K key,V value,BinNode<K,V> root){\n        if (root==null){\n            return new BinNode<>(key,value);\n        }\n        int res=root.getKey().compareTo(key);\n        if (res<=0){//root更小 插入右子树\n            root.setRight(insertHelper(key,value,root.getRight()));\n        }else{\n            root.setLeft(insertHelper(key,value,root.getLeft()));\n        }\n        return root;\n    }\n\n    @Override\n    public V remove(K key) {\n        if (key==null) {\n            try {\n                throw new Exception(\"key is null.\");\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n        V val=search(key);\n        if (val!=null) removeHelper(key,root);\n        return val;\n    }\n\n    private BinNode<K,V> findMin(BinNode<K,V> root){\n        if (root==null) return null;\n        if (root.getLeft()==null) return root;\n        return findMin(root.getRight());\n    }\n\n    private BinNode<K,V> removeHelper(K key,BinNode<K,V> root){\n        if (root==null) return null;\n        int res=root.getKey().compareTo(key);\n        if (res>0){\n            root.setLeft(removeHelper(key,root.getLeft()));\n        } else if (res<0) {\n            root.setRight(removeHelper(key,root.getRight()));\n        }else{\n            //恰好是这个节点需要删除\n            V val=root.getValue();\n            if (root.getLeft()==null){\n                root=root.getRight();\n            }else if (root.getRight()==null){\n                root=root.getLeft();\n            }else{\n                //找到右子树中最大的节点\n                BinNode<K, V> min = findMin(root);\n                root.setKey(min.getKey());\n                root.setValue(min.getValue());\n                root.setRight(min);\n            }\n        }\n        return root;\n    }\n\n    private void deleteMaxHelper(BinNode<K,V> root){\n        if (root==null) return;\n        if (root.getRight()==null) return;\n        if (root.getRight().getRight()==null){\n            root.getRight().setRight(null);\n        }else{\n            deleteMaxHelper(root.getRight());\n        }\n    }\n    @Override\n    public V search(K key) {\n        if (key==null) {\n            try {\n                throw new Exception(\"key is null.\");\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n        return searchHelper(key,root);\n    }\n\n    private V searchHelper(K key, BinNode<K,V> root){\n        if (root==null) return null;\n        int res=root.getKey().compareTo(key);\n        if (res==0) return root.getValue();\n        else if (res>0) return searchHelper(key,root.getLeft());\n        else return searchHelper(key,root.getRight());\n    }\n\n    @Override\n    public boolean update(K key, V value) {\n        if (key==null) {\n            try {\n                throw new Exception(\"key is null.\");\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return false;\n        }\n        return updateHelper(key,value,root);\n    }\n\n    private boolean updateHelper(K key, V value, BinNode<K,V> root){\n        if (root==null) return false;\n        int res=root.getKey().compareTo(key);\n        if (res==0) {\n            root.setValue(value);\n            return true;\n        }else if (res>0) return updateHelper(key,value,root.getLeft());\n        else return updateHelper(key,value,root.getRight());\n    }\n    @Override\n    public boolean isEmpty() {\n        return root==null;\n    }\n\n    @Override\n    public void clear() {\n        root=null;\n    }\n\n    @Override\n    public void travelPrev() {\n        travelPrev(root);\n    }\n\n    private void travelPrev(BinNode<K,V> root){\n        System.out.println(\"先序遍历\");\n        if (root==null) return;\n        System.out.print(root);\n        travelPrev(root.getLeft());\n        travelPrev(root.getRight());\n    }\n\n    @Override\n    public void travelMid() {\n        travelMid(root);\n    }\n    private void travelMid(BinNode<K,V> root){\n//        System.out.println(\"中序遍历\");\n        if (root==null) return;\n        travelMid(root.getLeft());\n        System.out.print(root);\n        travelMid(root.getRight());\n    }\n\n    @Override\n    public void travelLast() {\n\n        travelLast(root);\n    }\n\n    private void travelLast(BinNode<K,V> root){\n        System.out.println(\"后序遍历\");\n        if (root==null) return;\n        travelLast(root.getLeft());\n        travelLast(root.getRight());\n        System.out.print(root);\n    }\n\n    @Override//层序遍历，也就是广度优先遍历\n    public void travel() {\n        System.out.println(\"层序遍历\");\n        Map<Integer, List<BinNode<K,V>>> map=new HashMap();\n        class MyQueue{\n            class BinNodeWithLevel{\n                int level;\n                BinNode<K,V> binNode;\n                BinNodeWithLevel next;\n                BinNodeWithLevel(int level,BinNode<K,V> binNode,BinNodeWithLevel next){\n                    this.level=level;\n                    this.binNode=binNode;\n                    this.next=next;\n                }\n            }\n            int size;\n            BinNodeWithLevel top;\n            MyQueue(){\n                top=null;\n                size=0;\n            }\n            public void push(int level,BinNode<K,V> node){\n                top=new BinNodeWithLevel(level,node,top);\n                size++;\n            }\n            public BinNodeWithLevel pop(){\n                if (this.isEmpty()) return null;\n                BinNodeWithLevel res=top;\n                top=top.next;\n                size--;\n                return res;\n            }\n            public boolean isEmpty(){\n                return size==0;\n            }\n        }\n        MyQueue queue=new MyQueue();\n        queue.push(0,root);\n        while (!queue.isEmpty()){\n            MyQueue.BinNodeWithLevel pop = queue.pop();\n            int level=pop.level;\n            BinNode<K,V> node=pop.binNode;\n            List<BinNode<K,V>> list=map.get(level);\n            if (list==null){\n                list=new LinkedList<>();\n                list.add(node);\n                map.put(level,list);\n            }else{\n                list.add(node);\n            }\n            System.out.print(node);\n            if (node.getLeft()!=null) queue.push(level+1,node.getLeft());\n            if (node.getRight()!=null) queue.push(level+1,node.getRight());\n        }\n        System.out.print(map);\n    }\n}\n```\n完美解决！\n\n# AVL树\n\n![](树/Untitled%207.png)\n\n查找效率提高\n\n将二叉检索树转变为AVL树\n\n![](树/Untitled%208.png)\n\n![](树/Untitled%209.png)\n\n![](树/Untitled%2010.png)\n\n**在插入和删除节点时会出现失衡**\n\n- **插入**\n\n  - LL型\n\n  ![](树/Untitled%2011.png)\n\n  - LR型\n\n  ![](树/Untitled%2012.png)\n\n  1. 先对root的左子树进行一个左旋\n\n     ![](树/Untitled%2013.png)\n\n     ![](树/Untitled%2014.png)\n\n  2. 对roo右旋\n\n     ![](树/Untitled%2015.png)\n\n  - RR型\n\n    ![](树/Untitled%2016.png)\n\n  - RL型\n\n    1. 先对root的右子树进行一个右旋\n\n    ![](树/Untitled%2017.png)\n\n    ![](树/Untitled%2018.png)\n\n    1. 对root进行左旋\n\n    ![](树/Untitled%2019.png)\n\n  **删除基本相同，删除后判断是哪种类型，进行相应处理**","categories":["算法","数据结构","树"]},{"title":"算法渐进分析","url":"/2024/08/04/算法渐进分析/","content":"\n# 三个符号\n\n$O(n)$:上界。相当于\"<=”\n\n![](./算法渐进分析/Untitled.png)\n\n$o(n)$:非紧的上界。相当于\"<”\n\n![](./算法渐进分析/Untitled%201.png)\n\n$Ω(n)$:下界。相当于\">=”\n\n![](./算法渐进分析/Untitled%202.png)\n\n$w(n)$:非紧的下界。 相当于\">”\n\n![](./算法渐进分析/Untitled%203.png)\n\n$θ(n)$:紧确界。相当于\"=”\n\n![](./算法渐进分析/Untitled%204.png)\n\n注解：渐近非负的意思是“当n趋于无穷大时，f(n)和g(n)都非负”。\n\n- 如果$f(n)=Θ(g(n))$,则$f(n)=O(g(n))$且$f(n)=Ω(g(n))$。\n- 如果$f(n)=o(g(n))$,则$f(n)=O(g(n))$。\n- 如果$f(n)=ω(g(n))$，则$f(n)=Ω(g(n))$。\n\n[参考](https://blog.csdn.net/gaoxiangnumber1/article/details/45066841)\n\n## 用集合描述\n\n$f(n)∈ O(g(n))$\n\n举例：\n\n![](./算法渐进分析/Untitled%205.png)\n\n如果$f(n)=O(g(n))$,则要么是$f(n)=o(g(n))$，要么是$f(n)=Θ(g(n))$。\n\n## 性质（没啥用）\n\n1. 传递性：一条链上的都是同一个符号\n\n![](./算法渐进分析/Untitled%206.png)\n\n2. 自反性：带等号的\n\n![](./算法渐进分析/Untitled%207.png)\n\n3. 对称性\n\n![](./算法渐进分析/Untitled%208.png)\n\n4. 单调性\n\n![](./算法渐进分析/Untitled%209.png)\n\n5. 多部份决策：通俗点来说来说就是当算法由两个连续执行部分组成时，该算法的整体效率由具有较大增长次数的那部分所决定，即效率较差的部分决定。\n\n![](./算法渐进分析/Untitled%2010.png)\n\n## 例题\n\n![](./算法渐进分析/Untitled%2011.png)","categories":["算法","基础知识"]},{"title":"网络安全大作业","url":"/2024/08/03/网络安全大作业/","content":"{% pdf 安全通信软件的设计与实现.pdf %} ","categories":["课程学习","网络信息安全"]},{"title":"计算机网络课程设计","url":"/2024/08/03/计算机网络课程设计/","content":"{% pdf 计算机网络课程设计项目报告.pdf %} \n","categories":["课程学习","计算机网络"]},{"title":"算法刷题记录DAY1","url":"/2024/08/03/算法刷题记录DAY1/","content":"\n先从暴力开始吧\n\n# 暴力\n\n## 三角形\n\n![](./算法刷题记录DAY1/qq_pic_merged_1717912944477.jpg)\n\n这个暴力就行\n\n```cpp\n#include<stdio.h>\nint max(int a,int b){\n\treturn a>b?a:b;\n}\nint check(int a,int b,int c){\n\tif(a+b>c&&a+c>b&&b+c>a) return 1;\n\treturn 0;\n}\nint main(){\n\tint ans=0;\n\tint n;\n\tscanf(\"%d\",&n);\n\tint len[n];\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&len[i]);\n\t}\n\tfor(int i=0;i<n-2;i++){\n\t\tfor(int j=i+1;j<n-1;j++){\n\t\t\tfor(int k=j+1;k<n;k++){\n\t\t\t\tif(check(len[i],len[j],len[k]){\n\t\t\t\t\tans=max(ans,len[i]+len[j]+len[k]);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n\n下面这个有技巧：\n\n## Ants\n\n题目链接：[1852 -- Ants (poj.org)](http://poj.org/problem?id=1852)\n\n![](./算法刷题记录DAY1/qq_pic_merged_1717913392418.jpg)\n\n题目中说的不能交错通过，相遇之后会各自反向，这和相遇之后不改变方向的情况的时间是一样的，所以只需要扫描一遍。\n\n```c\n#include<stdio.h>\nint max(int a,int b){\n    return a>b?a:b;\n}\nint min(int a,int b){\n    return a<b?a:b;\n}\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    int len,t;\n    int x;\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&len,&t);\n        int mid=len/2;\n        int mn=0,mx=0;\n        for(int j=0;j<t;j++){\n            scanf(\"%d\",&x);\n            if(x>mid){\n                mn=max(mn,len-x);\n                mx=max(mx,x);\n            }else{\n                mn=max(mn,x);\n                mx=max(mx,len-x);\n            }\n        }\n        printf(\"%d %d\\n\",mn,mx);\n    }\n    return 0;\n}\n```\n\n## 抽签\n\n![](./算法刷题记录%20DAY1_pic_merged_1717913706542.jpg)\n\n这题直接暴力：\n\n![](./算法刷题记录%20DAY1_pic_merged_1717913813520.jpg)\n\n$$\n进阶：n的限制条件改为1\\leq n \\leq 1000\n$$\n\n解法：二分搜索\n\n先排好序，然后查找m-ka-kb-kc(假设为x)，查找数组中间的元素\n\n- 如果它比x小，x只能在后半段\n- 如果它比x大，x只能在前半段\n\n$$\n总时间复杂度：O(n^3logn)\n$$\n\n```cpp\n//二分查找方法\nbool binary_search(vector<int> nums,int target){\n\tint l=0,r=nums.size()-1;\n\twhile(l<=r){\n\t\tint mid=l+(r-l)/2;\n\t\tint com=nums[mid]-target;\n\t\tif(com==0) return true;\n\t\telse if(com>0){\n\t\t\tr=mid-1;\n\t\t}else{\n\t\t\tl=mid+1;\n\t\t}\n\t}\n\treturn false;\n}\n```\n\n这样的时间复杂度还是太大，继续改进\n\n先枚举出$kc+kd$，然后寻找$kc+kd=m-ka-kb$\n\n时间复杂度： $排序O(n^2logn)+循环O(n^2logn)$\n\n![](./算法刷题记录%20DAY1_pic_merged_1717914931937.jpg)\n\n![](./算法刷题记录%20DAY1_pic_merged_1717914879578.jpg)\n\n## 二进制枚举法\n\n使用二进制与位运算\n\n![](./算法刷题记录%20DAY1_pic_merged_1717916148154.jpg)\n\n```c\ntypedef long long ll;\nint a[MAX_N];\nint n,k;\nvoid solve(){\n\tll mask=1<<n;\n\tfor(ll i=1;i<mask;i++){\n\t\tll t=i;\n\t\tint m=0;\n\t\tint sum=0;\n\t\twhile(t){\n\t\t\tif(t&1) sum+=a[m];\n\t\t\tm++;\n\t\t\tt>>1;\n\t\t}\n\t\tif(sum==k){\n\t\t\tprintf(\"Yes\\n\");\n\t\t}\n\t}\n\tprintf(\"No\\n\");\n}\n```\n\n也可以用DFS（回溯法）\n\n```c\nint a[MAX_N];\nint n,k;\n\nbool dfs(int index,int sum){\n\tif(i==n) return sum==k;\n\tif(dfs(i+1,sum)) return true;\n\tif(dfs(i+1,sum+a[i])) return true;\n\treturn false;\n}\nvoid solve(){\n\tif(dfs(0,0)) printf(\"Yes\\n\");\n\telse printf(\"No\\n\");\n}\n```\n\n## DFS\n### 连通域判断\n![](./算法刷题记录%20DAY1_pic_merged_1717939197339.jpg)\n\n```c\n#include<stdio.h>\nchar map[101][101];\nint m;\nint n;\nvoid dfs(int x,int y){\n\tmap[x][y]='.';\n\tfor(int dx=-1;dx<=1;dx++){\n\t\tfor(int dy=-1;dy<=1;dy++){\n\t\t\tint nx=x+dx;\n\t\t\tint ny=y+dy;\n\t\t\tif(nx>=0&&nx<n&&ny>=0&&ny<m&&map[nx][ny]=='W'){\n\t\t\t\tdfs(nx,ny);\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%s\",map[i]);\n\t}\n\tint ans=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(map[i][j]=='W'){\n\t\t\t\tdfs(i,j);\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n\n\n还有道力扣：\n### 字母迷宫\n![](./算法刷题记录DAY1/Untitled.png)\n![](./算法刷题记录DAY1/Untitled%201.png)\n\n```cpp\n#include<vector>\n#include<string>\nusing namespace std;\nclass Solution {\npublic:\n    bool wordPuzzle(vector<vector<char>>& grid, string target) {\n        vector<vector<bool>> used(grid.size(),vector<bool>(grid[0].size(),false));\n        for(int i=0;i<grid.size();i++){\n            for(int j=0;j<grid[i].size();j++){\n                used[i][j]=true;\n                if(dfs(grid,target,0,i,j,used)) return true;\n                used[i][j]=false;\n            }\n        }\n        return false;\n    }\n    int dirx[4]={-1,0,0,1};\n    int diry[4]={0,1,-1,0};\n    bool dfs(vector<vector<char>>& grid,string target,int index,int x,int y,vector<vector<bool>> used){\n        if(index==target.length()-1) \n            return target.at(index)==grid[x][y];\n        if(target.at(index)!=grid[x][y]) return false;\n        for(int i=0;i<4;i++){\n            int nx=x+dirx[i];\n            int ny=y+diry[i];\n            if(nx>=0&&nx<grid.size()&&ny>=0&&ny<grid[0].size()&&used[nx][ny]==false){\n                used[nx][ny]=true;\n                bool res=dfs(grid,target,index+1,nx,ny,used);\n                used[nx][ny]=false;\n                if(res) return true;\n            }\n        }\n        return false;\n    }\n};\n```\n\n这里有一个大佬的解：\n\n```cpp\nclass Solution {\npublic:\n    bool exist(vector<vector<char>>& board, string word) {\n        int rows = board.size(), cols = board[0].size();\n\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++) {\n                if (board[r][c] == word[0] && dfs(board, word, 0, r, c)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    bool dfs(vector<vector<char>>& board, string& word, int index, int row, int col) {\n        if (index == word.size()) {\n            return true;\n        }\n\n        if (row < 0 || col < 0 || row >= board.size() || col >= board[0].size()) {\n            return false;\n        }\n\n        if (board[row][col] != word[index]) {\n            return false;\n        }\n    \n        auto board_val = board[row][col];\n        board[row][col] = '0';//用当前数组代替了used\n        bool result = dfs(board, word, index + 1, row - 1, col);\n        result = result || dfs(board, word, index + 1, row + 1, col);\n        result = result || dfs(board, word, index + 1, row, col - 1);\n        result = result || dfs(board, word, index + 1, row, col + 1);\n        board[row][col] = board_val;\n\n        return result;\n    }\n};\n```\n\n### 二叉树\n![](./算法刷题记录DAY1/Untitled%202.png)\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n#include<string>\n#include<vector>\n#include<stack>\nclass Solution {\npublic:\n    vector<string> ans;\n    vector<string> binaryTreePaths(TreeNode* root) {\n        vector<int> stk;\n        stk.push_back(root->val);\n        dfs(root,stk);\n        return ans;\n    }\n    void dfs(TreeNode* root, vector<int>& stk){\n        if(isleaf(root)!=0){\n            ans.push_back(copy(stk));\n            return;\n        }\n        if(root->left==nullptr){\n            stk.push_back(root->right->val);\n            dfs(root->right,stk);\n            stk.pop_back();\n        }else if(root->right==nullptr){\n            stk.push_back(root->left->val);\n            dfs(root->left,stk);\n            stk.pop_back();\n        }else {\n            stk.push_back(root->left->val);\n            dfs(root->left,stk);\n            stk.pop_back();\n\n            stk.push_back(root->right->val);\n            dfs(root->right,stk);\n            stk.pop_back();\n        }\n    }\n    string copy(vector<int>& stk){\n        string ans=\"\";\n        for(int i=0;i<stk.size();i++){\n            if(i!=0) ans+=\"->\";\n            ans+=to_string(stk[i]);\n        }\n        return ans;\n    }\n    int isleaf(TreeNode* root){\n        if(root==nullptr) return -1;\n        if(root->right==nullptr&&root->left==nullptr) return 1;\n        return 0;\n    }\n    \n};\n```\n\n## BFS\n\n### 迷宫\n\n![](./算法刷题记录DAY1/Untitled.jpeg)\n\n![](./算法刷题记录DAY1/Untitled%201.jpeg)\n\n![](./算法刷题记录DAY1/Untitled%202.jpeg)\n\n\n### 二叉树层序遍历\n\n![](./算法刷题记录DAY1/Untitled%204.png)\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\n#include<vector>\n#include<queue>\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> ans;\n        queue<pair<int,TreeNode*>> q;\n        if(root==nullptr) return ans;\n        q.push(make_pair(0,root));\n        while(q.size()){\n            pair<int,TreeNode*> t=q.front();q.pop();\n            int level=t.first;\n            TreeNode* node=t.second;\n            if(level<ans.size()){\n                ans[level].push_back(node->val);\n            }else{\n                vector<int> next(1,node->val);\n                ans.push_back(next);\n            }\n            if(node->left!=nullptr){\n                q.push(make_pair(level+1,node->left));\n            }\n            if(node->right!=nullptr){\n                q.push(make_pair(level+1,node->right));\n            }\n        }\n        return ans;\n    }\n};\n```\n\n### N叉树层序遍历\n\n![](./算法刷题记录DAY1/Untitled%205.png)\n\n![](./算法刷题记录DAY1/Untitled%206.png)\n\n```cpp\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n#include<queue>\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(Node* root) {\n        vector<vector<int>> ans;\n        queue<pair<int,Node*>> q;\n        if(root==nullptr) return ans;\n        q.push(make_pair(0,root));\n        while(q.size()){\n            pair<int,Node*> t=q.front();q.pop();\n            int level=t.first;\n            Node* node=t.second;\n            if(level<ans.size()){\n                ans[level].push_back(node->val);\n            }else{\n                vector<int> next(1,node->val);\n                ans.push_back(next);\n            }\n            vector<Node*> cld=node->children;\n            for(int i=0;i<cld.size();i++){\n                if(cld[i]!=nullptr){\n                    q.push(make_pair(level+1,cld[i]));\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n# 贪心\n## 心算挑战\n![](./算法刷题记录DAY1/Untitled%207.png)\n\n这题一开始没想到：\n\n**排序先取最大的cnt个数，如果它们的和是偶数直接输出，不然就找一个已取的最小的奇数换成剩下未取的最大的偶数，或者找一个已取的最小的偶数换成剩下未取的最大奇数**\n\n看看大佬答案：\n\n```cpp\nclass Solution {\npublic:\n    int maxmiumScore(vector<int>& cards, int cnt) {\n        sort(cards.begin(), cards.end(), greater<int>());\n        int res = 0, lastodd = 0, lasteven = 0;\n        for (int i = 0; i < cnt; i++)\n        {\n            res += cards[i];\n            if (cards[i] % 2 == 1) lastodd = cards[i];\n            else lasteven = cards[i];\n        }\n        if (res % 2 == 0) return res;\n\n        int max1 = 0, max2 = 0;\n        for (int i = cnt; i < cards.size(); i++)\n        {\n            if (lasteven && max1 == 0 && cards[i]%2) max1 = res - lasteven + cards[i];\n            if (lastodd && max2 == 0 && cards[i]%2 == 0) max2 = res - lastodd + cards[i];\n        }\n        return max(max1, max2);\n    }\n};\n```\n## 硬币问题\n![](./算法刷题记录%20DAY1_pic_merged_1718006386488.jpg)\n\n优先使用大面值的硬币：\n\n```cpp\nconst int V[6]={1, 5, 10, 50, 100, 500};\nint C[6];//\nint A;\n\nvoid solve(){\n\tint ans=0;\n\tfor(int i=5;i>=0;i++){\n\t\tint t = min(A/V[i], C[i]);\n\t\tA -= t*V[i];\n\t\tans+=t;\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n}\n```\n## 字典序最小\n![](./算法刷题记录%20DAY1_pic_merged_1718006622569.jpg)\n\n![](./算法刷题记录%20DAY1_pic_merged_1718006677452.jpg)\n\n![](./算法刷题记录%20DAY1_pic_merged_1718006696584.jpg)\n\n![](./算法刷题记录%20DAY1_pic_merged_1718006711202.jpg)\n\n## 哈夫曼编码\n\n![](./算法刷题记录%20DAY1_pic_merged_1718006911989.jpg)\n\n```cpp\n#include<iostream>\n#include <queue>\n#include<vector>\nusing namespace std;\ntypedef long long ll;//开ll才不会溢出\nint main(){\n    priority_queue<ll,vector<ll>,greater<ll> > q;\n    int n;\n    cin>>n;\n    ll x;\n    for(int i=0;i<n;i++){\n        cin>>x;\n        q.push(x);\n    }\n    ll ans=0;\n    while(q.size()>1){\n        // ans+=q.front();\n        ll y1=q.top();\n        q.pop();\n        ll y2=q.top();\n        q.pop();\n        ans+=(y1+y2);\n        q.push(y1+y2);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n```\n\n动态规划先不看\n\n先看数学：\n# 数学\n## 辗转相除法\n\n![](./算法刷题记录%20DAY1_pic_merged_1718008211277.jpg)\n\n鬼能看出这题是求最大公约数\n\n$$\n答案就是|x_1-x_2|和|y_1-y2|的最大公约数-1！！！！\n$$\n\n现在问题来到计算最大公约数：\n\n### 辗转相除法\n\n```cpp\nint gcd(int a, int b) {\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\n```\n\n$$\n时间复杂度：O(log max(a,b))以内\n$$\n\n还有一些比较低效的方法：https://blog.csdn.net/Brilliance_panpan/article/details/88372432\n\n### 扩展欧几里得算法\n\n$$\n求整数x和y使得ax+by=1\n$$\n\n可以发现，如果gcd(a,b)不等于1，无解；如果gcd(a,b)=1,就可以通过扩展原来的辗转相除法来求解。事实上，一定存在整数对（x,y）使得ax+by=gcd(a,b)。\n\n![](./算法刷题记录DAY1/Untitled%208.png)\n\n代码：\n\n```cpp\nint extgcd(int a,int b,int& x,int& y){\n\tint d=a;\n\tif(b){\n\t\td=extgcd(b,a%b,y,x);\n\t\ty-=(a/b)*x;\n\t}else{\n\t\tx=1;y=0;\n\t}\n\treturn d;\n}\n```\n\n## 素数\n\n### 素性检验\n\n$$\n给定整数n，判断n是不是素数(1\\leq n \\leq 10^9)\n$$\n\n想到的最直接的方法就是从2到n-1遍历，能整除就不是素数，但是时间复杂度太大；实际上我们只需要检查2~根号n的整数就可以。\n\n```cpp\nint n;\nvoid solve(){\n\tif(n==2){\n\t\tprintf(\"Yes\\n\");\n\t\treturn;\n\t}\n\tfor(int i=2;i*i<=n;i++){\n\t\tif(n%i==0){\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tprintf(\"Yes\\n\");\n}\n```\n\n$$\n给定整数n,请问n以内有多少个素数？（n \\leq 10^6）\n$$\n\n### 埃氏筛法\n\n首先把2到n范围内的所有整数谢下来，最小的数组2是素数，将表中所有2的倍数划去，然后是3（素数），将3的倍数全部划去，以此类推。\n\n![](./算法刷题记录%20DAY1_pic_merged_1718012475501.jpg)\n\n\n![](./算法刷题记录DAY1/Untitled%2015.png)\n\n```cpp\n#include<vector>\nclass Solution {\npublic:\n    int countPrimes(int n) {\n        if(n<2) return 0;\n        vector<bool> isPrime(n,true);\n        isPrime[0]=false;\n        isPrime[1]=false;\n        int ans=0;\n        for(int i=2;i<n;i++){\n            if(isPrime[i]){\n                ans++;\n                if(2*i<n){\n                    for(int j=2*i;j<n;j+=i){\n                        isPrime[j]=false;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n### 区间筛法\n\n![](./算法刷题记录%20DAY1_pic_merged_1718012639631.jpg)\n\n![](./算法刷题记录%20DAY1_pic_merged_1718012675564.jpg)\n\n![](./算法刷题记录%20DAY1_pic_merged_1718012812983.jpg)\n\n### 快速幂运算\n\n![](./算法刷题记录%20DAY1_pic_merged_1718012862839.jpg)\n\n思路：\n\n![](./算法刷题记录%20DAY1_pic_merged_1718013054084.jpg)\n\n代码1：\n\n![](./算法刷题记录%20DAY1_pic_merged_1718013072543.jpg)\n\n代码2（递归）：\n\n![](./算法刷题记录%20DAY1_pic_merged_1718013088936.jpg)\n\n# 贪心\n## 救生艇\n![](./算法刷题记录DAY1/Untitled%209.png)\n\n思路：先把people排序，每次均从头和从尾各选取一个人凑在一条船上，能凑上就凑，凑不上就放大的。\n\n```cpp\n#include<vector>\n#include<algorithm>\nclass Solution {\npublic:\n    int numRescueBoats(vector<int>& people, int limit) {\n        sort(people.begin(),people.end());//从小到大排序\n        int ans=0;\n        int pbig=people.size()-1;\n        int psml=0;\n        while(pbig>psml){\n            int big=people[pbig];\n            int small=people[psml];\n            if(big+small<=limit) {\n                ans++;\n                psml++;\n                pbig--;\n            }\n            else{\n                ans++;\n                pbig--;\n            }\n        }\n        if(pbig==psml) ans++;\n        return ans;\n    }\n};\n```\n## 最大数\n![](./算法刷题记录DAY1/Untitled%2010.png)\n\n![](./算法刷题记录DAY1/Untitled%2011.png)\n\n```cpp\n#include <vector>\n#include <algorithm>\ntypedef unsigned long long ll;\nll pingjie(ll a, ll b)\n{\n    ll x = b;\n    if (x == 0)\n        return a * 10;\n    while (x > 0)\n    {\n        a = a * 10;\n        x /= 10;\n    }\n    a += b;\n    return a;\n}\nbool cmp(int a, int b)\n{\n    ll ab = pingjie(a, b);\n    ll ba = pingjie(b, a);\n    return ab > ba;\n}\n\nclass Solution\n{\npublic:\n    string largestNumber(vector<int> &nums)\n    {\n        sort(nums.begin(), nums.end(), cmp);\n        if(nums[0]==0) return \"0\";\n        string ans;\n        for (int i = 0; i < nums.size(); i++)\n        {\n            ans += to_string(nums[i]);\n        }\n        return ans;\n    }\n};\n```\n\n可以优化比较方法：c++中，sort中自定义的比较函数可以直接用字符串比较\n\n```cpp\nsort(nums.begin(), nums.end(), [](const int &x, const int &y) {\n\treturn to_string(x) + to_string(y) > to_string(y) + to_string(x);\n});\n```\n## 加油站\n![](./算法刷题记录DAY1/Untitled%2012.png)\n\n![](./算法刷题记录DAY1/Untitled%2013.png)\n\n```cpp\n/*\n\t这题一开始暴力，没有优化，TLK了，后面看了答案优化了过了。\n\t**关键点：我们首先检查第 000 个加油站，并试图判断能否环绕一周；\n\t\t\t\t\t如果不能，就从第一个无法到达的加油站开始继续检查。**\n*/\n#include<vector>\n#include<set>\nclass Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int n=gas.size();\n        set<int> st;\n        int begin_index=-1;\n        for(int i=0;i<gas.size();i++){\n            if(gas[i]-cost[i]>=0) {\n                begin_index=i;\n                break;\n            }\n        }\n        if(begin_index==-1) return -1;\n        int bugindex=-1;\n        st.insert(begin_index);\n        for(;begin_index<n;){\n            int total=gas[begin_index]-cost[begin_index];\n            for(int j=(begin_index+1)%n;j!=begin_index;j=(j+1)%n){\n                total+=(gas[j]-cost[j]);\n                if(total<0) {\n                    bugindex=j;\n                    break;\n                }\n            }\n            if(total>=0) return begin_index;\n            else{\n                int k;\n                for(k=bugindex;;k=(k+1)%n){\n                    if(gas[k]>=cost[k]) {\n                        break;\n                    }\n                }\n                begin_index=k;\n                if(st.count(begin_index)) return -1;\n                else st.insert(begin_index);\n            }\n        }\n        return -1;\n    }\n};\n```\n\n## 经典跳跃游戏\n\n初级版\n\n![](./算法刷题记录DAY1/Untitled%2014.png)\n\n```cpp\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int maxindex=0;\n        for(int i=0;i<=maxindex&&i<nums.size();i++){\n            maxindex=max(maxindex,i+nums[i]);\n        }\n        return maxindex>=nums.size()-1;\n    }\n};\n```\n\n# 动态规划\n## 最小路径和\n![](./算法刷题记录DAY1/Untitled%2016.png)\n\n```cpp\nclass Solution {\npublic:\n    int dp[201][201];\n    int minimumTotal(vector<vector<int>>& triangle) {\n        memset(dp,-1,sizeof dp);\n        dp[0][0]=triangle[0][0];\n        for(int i=1;i<triangle.size();i++){\n            for(int j=0;j<=i;j++){\n                if(i==j){\n                    dp[i][j]=dp[i-1][j-1]+triangle[i][j];\n                }else if(j==0){\n                    dp[i][j]=dp[i-1][j]+triangle[i][j];\n                }else{\n                    dp[i][j]=min(dp[i-1][j-1],dp[i-1][j])+triangle[i][j];\n                }\n            }\n        }\n        int min=dp[triangle.size()-1][0];\n        for(int i=1;i<triangle.size();i++){\n            if(min>dp[triangle.size()-1][i])\n                min=dp[triangle.size()-1][i];\n        }\n        return min;\n    }\n};\n```\n\n**压缩后：**\n\n```cpp\nclass Solution {\npublic:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        int n = triangle.size();\n        vector<vector<int>> f(2, vector<int>(n));\n        f[0][0] = triangle[0][0];\n        for (int i = 1; i < n; ++i) {\n            int curr = i % 2;\n            int prev = 1 - curr;\n            f[curr][0] = f[prev][0] + triangle[i][0];\n            for (int j = 1; j < i; ++j) {\n                f[curr][j] = min(f[prev][j - 1], f[prev][j]) + triangle[i][j];\n            }\n            f[curr][i] = f[prev][i - 1] + triangle[i][i];\n        }\n        return *min_element(f[(n - 1) % 2].begin(), f[(n - 1) % 2].end());\n    }\n};\n\n// 作者：力扣官方题解\n// 链接：https://leetcode.cn/problems/IlPe0q/solutions/1036365/san-jiao-xing-zhong-zui-xiao-lu-jing-zhi-srun/\n// 来源：力扣（LeetCode）\n// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n## leetcode 2849\n![](./算法刷题记录DAY1/Untitled%2017.png)\n\n![](./算法刷题记录DAY1/Untitled%2018.png)\n\n题解：\n\n![](./算法刷题记录DAY1/Untitled%2019.png)\n\n```cpp\nclass Solution {\npublic:\n    bool isReachableAtTime(int sx, int sy, int fx, int fy, int t) {\n        if(sx==fx&&sy==fy) return t!=1;\n        return t>=max(abs(sx-fx),abs(sy-fy));\n    }\n};\n```\n## 分糖果I\n![](./算法刷题记录DAY1/Untitled%2020.png)\n\n```cpp\nclass Solution {\npublic:\n    int distributeCandies(int n, int limit) {\n        int ans=0;\n        for(int i=0;i<=limit;i++){\n            for(int j=0;j<=n-i&&j<=limit;j++){\n                if(n-i-j<=limit) ans++;\n            }\n        }\n        return ans;\n    }\n};\n```\n## 分糖果II\n![](./算法刷题记录DAY1/Untitled%2021.png)\n\n```cpp\nclass Solution {\npublic:\n    long long distributeCandies(int n, int limit) {\n        if(limit<n/3) return 0;\n        long long ans=0;\n        for(int i=max(0,n-2*limit);i<=limit&&n-i>=0;i++){\n            int k=n-i;\n            if(k<limit) ans+=k+1;\n            else ans+=limit-(k-limit)+1;\n        }\n        return ans;\n    }\n};\n```\n# 杂题\n## 删除重复项\n![](./算法刷题记录DAY1/Untitled%2022.png)\n\n![](./算法刷题记录DAY1/Untitled%2023.png)\n\n```cpp\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int n=nums.size();\n        int cnt=0;\n        for(int i=0;i<n;i++){\n            if(i>0&& nums[i]!=nums[i-1]) cnt=1;\n            else cnt++;\n            if(cnt==3){\n                remove(nums,i,n);\n                n--;\n                cnt--;\n                i--;\n            }\n        }\n        return n;\n    }\n    void remove(vector<int>& nums,int index,int end){\n        for(int i=index;i<end-1;i++){\n            nums[i]=nums[i+1];\n        }\n    }\n};\n```","categories":["算法"]},{"title":"排序算法","url":"/2024/08/01/排序算法/","content":"\n> **排序是指重新排列列表中的元素，使表中的元素按照关键字有序的过程**\n\n# 分类\n\n- 按照稳定性分类\n  \n  ![](./排序算法/Untitled.png)\n    \n- 内部排序与外部排序\n    - 内部排序：数据都在内存中（考虑时间复杂度和空间复杂度）\n    - 外部排序：数据太多，无法全部放入内存（还需要考虑读写磁盘次数）\n\n**[可视化]([Comparison Sorting Visualization (usfca.edu)](https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html))**\n\n# 插入排序（稳定的）\n\n算法思想：每次将一个待排序的记录按照其关键字大小插入到前面已经排行的子序列中，知道全部记录插入完成。\n\n```java\npublic static void insertSortAsc(int[] arr){\n    int n=arr.length;\n    int i,j;\n    for (i=1;i<n;i++){\n        if (arr[i]<arr[i-1]){\n            int temp=arr[i];\n            for (j=i-1;j>=0&&temp<arr[j];j--){\n                arr[j+1]=arr[j];\n            }\n            arr[j+1]=temp;\n        }\n    }\n}\n```\n\n> **代码思路：**从第二个元素开始遍历，当当前元素的关键字与前一个元素的关键字不满足规定的排序方式时，这个时候，当前元素要插入前面已经排好序的序列之中，操作如下：用一个变量存储当前元素，对于前面已经排好的序列中的元素，从后往前遍历，每遇到一个比需要插入的元素的关键字小（或大，更精确的描述应该是不满足规定的排序方式）的元素，就将该元素后移一格，直到遇到满足规定排序方式的元素，将暂存变量的值赋值给改元素后一个格子的位置。\n\n## review\n\n```java\npublic static void insertSort(Element[] elements){\n    int i,j;\n    for (i=1;i<elements.length;i++){\n        if (elements[i].getKey()<elements[i-1].getKey()){\n            Element tmp=elements[i];\n            for (j=i-1;j>=0&&elements[j].getKey()>tmp.getKey();j--){\n                elements[j+1]=elements[j];\n            }\n            elements[j+1]=tmp;\n        }\n    }\n}\n```\n\n# 选择排序（不稳定的）\n\n算法思想：每次从未排序好中的序列中选择一个关键字最大（最小）的元素放入到排序好序列的后面即可\n\n```java\n//不稳定的排序\npublic static void selectSort(Element[] elements){\n    int start=0;\n    for (;start<elements.length;start++){\n        int minIndex=start;\n        for (int i=start+1;i<elements.length;i++){\n            if (elements[i].getKey()<elements[minIndex].getKey()){\n                minIndex=i;\n            }\n        }\n        swap(elements,minIndex,start);\n    }\n}\n```\n\n# 冒泡排序（稳定的）\n\n算法思想：每迭代一轮都比较相邻俩元素大小，不满足排序规则则交换他们\n\n```java\n//稳定的排序\npublic static void bobbleSort(Element[] elements){\n    //从前往后冒泡,使得末尾的序列元素必然是排好的\n    for (int end=elements.length-1;end>=0;end--){\n        for (int i=0;i<end;i++){\n            if (elements[i].getKey()>elements[i+1].getKey()){\n                swap(elements,i,i+1);\n            }\n        }\n    }\n}\n```\n\n# 希尔排序\n\n算法思想：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录\"基本有序\"时，再对全体记录进行依次直接插入排序。\n\n大概意思就是，先等间隔分组，分好组后组内先排序，然后再等间隔分组（间隔减半），再组内排序，循环迭代，直到间隔为1并排行序号。\n\n利用的原理是，先分组排序，利用插入排序的优势：当序列较为有序时，算法效率高。\n\n```java\nprivate static void insertSortHelper(Element[] elements,int gap,int start){\n    int i,j;\n    for (i=start+gap;i<elements.length;i++){\n        if (elements[i].getKey()<elements[i-gap].getKey()){\n            Element tmp=elements[i];\n            for (j=i-gap;j>=0&&elements[j].getKey()>tmp.getKey();j=j-gap) {\n                elements[j+gap]=elements[j];\n            }\n            elements[j+gap]=tmp;\n        }\n    }\n}\n\npublic static void shellSort(Element[] elements){\n    int gap=elements.length/2;\n    while (gap>0){\n        for (int i = 0; i < gap ; i++) {\n            insertSortHelper(elements,gap,i);\n        }\n        gap/=5;\n    }\n}\n```\n\n# 归并排序\n\n算法思路：先分再合，分：等分序列；合：排序合并序列（使用双指针）\n\n![](./排序算法/Untitled%201.png)\n\n```java\nprivate static void integerite(Element[] elements,int left1,int right1,int left2,int right2){\n    int index1=left1;\n    int index2=left2;\n    int currIndex=left1;\n    while (currIndex<=right2){\n        int compare= 0;\n        if (index1>right1) compare=1;\n        else if (index2>right2) compare=-1;\n        else compare=elements[index1].getKey()-elements[index2].getKey();\n        if (compare>0){\n            elements[currIndex++]=elements[index2++];\n        } else {\n            elements[currIndex++]=elements[index1++];\n        }\n    }\n}\n\nprivate static void mergeSortHelper(Element[] elements,int left,int right){\n    if (left>=right) return;\n    int mid=(left+right)/2;\n    mergeSortHelper(elements,left,mid);\n    mergeSortHelper(elements,mid+1,right);\n    integerite(elements,left,mid,mid+1,right);\n}\n\npublic static void mergeSort(Element[] elements){\n    mergeSortHelper(elements,0,elements.length-1);\n}\n```\n\n时间复杂度分析：$O(nlogn)$\n\n# 快速排序\n\n算法思想：分治思想，取一个基准值，让比基准值小的放一边，比基准值大的放一边（双指针实现）。\n\n**一定要先移动右指针！！！**\n\n```cpp\nvoid Sort::quick_sort(vector<int> &nums) {\n    quick_sort_helper(nums,0,nums.size()-1);\n}\n\nvoid Sort::quick_sort_helper(vector<int> &nums,\n                             int start, int end) {\n    if (start>=end) return;\n    int pivot=nums[start];\n    int left=start;\n    int right=end;\n    while (left<right){\n        //先移动right\n        while (right>left&&nums[right]>=pivot){\n            right--;\n        }\n        while (right>left&&nums[left]<=pivot){\n            left++;\n        }\n        swap(nums[left],nums[right]);\n    }\n    nums[right]=pivot;\n    quick_sort_helper(nums,start,right-1);\n    quick_sort_helper(nums,right+1,end);\n}\n```","categories":["算法"]}]