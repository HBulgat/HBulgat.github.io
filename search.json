[{"title":"网络安全大作业","url":"/2024/08/03/网络安全大作业/","content":"{% pdf 安全通信软件的设计与实现.pdf %} ","categories":["课程学习","网络信息安全"]},{"title":"计算机网络课程设计","url":"/2024/08/03/计算机网络课程设计/","content":"{% pdf 计算机网络课程设计项目报告.pdf %} ","categories":["课程学习","计算机网络"]},{"title":"算法刷题记录","url":"/2024/08/03/算法刷题记录/","content":"\n先从暴力开始吧\n\n# 暴力\n\n## 三角形\n\n![](./算法刷题记录/qq_pic_merged_1717912944477.jpg)\n\n这个暴力就行\n\n```cpp\n#include<stdio.h>\nint max(int a,int b){\n\treturn a>b?a:b;\n}\nint check(int a,int b,int c){\n\tif(a+b>c&&a+c>b&&b+c>a) return 1;\n\treturn 0;\n}\nint main(){\n\tint ans=0;\n\tint n;\n\tscanf(\"%d\",&n);\n\tint len[n];\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&len[i]);\n\t}\n\tfor(int i=0;i<n-2;i++){\n\t\tfor(int j=i+1;j<n-1;j++){\n\t\t\tfor(int k=j+1;k<n;k++){\n\t\t\t\tif(check(len[i],len[j],len[k]){\n\t\t\t\t\tans=max(ans,len[i]+len[j]+len[k]);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n\n下面这个有技巧：\n\n## Ants\n\n题目链接：[1852 -- Ants (poj.org)](http://poj.org/problem?id=1852)\n\n![](./算法刷题记录/qq_pic_merged_1717913392418.jpg)\n\n题目中说的不能交错通过，相遇之后会各自反向，这和相遇之后不改变方向的情况的时间是一样的，所以只需要扫描一遍。\n\n```c\n#include<stdio.h>\nint max(int a,int b){\n    return a>b?a:b;\n}\nint min(int a,int b){\n    return a<b?a:b;\n}\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    int len,t;\n    int x;\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&len,&t);\n        int mid=len/2;\n        int mn=0,mx=0;\n        for(int j=0;j<t;j++){\n            scanf(\"%d\",&x);\n            if(x>mid){\n                mn=max(mn,len-x);\n                mx=max(mx,x);\n            }else{\n                mn=max(mn,x);\n                mx=max(mx,len-x);\n            }\n        }\n        printf(\"%d %d\\n\",mn,mx);\n    }\n    return 0;\n}\n```\n\n## 抽签\n\n![](./算法刷题记录/qq_pic_merged_1717913706542.jpg)\n\n这题直接暴力：\n\n![](./算法刷题记录/qq_pic_merged_1717913813520.jpg)\n\n$$\n进阶：n的限制条件改为1\\leq n \\leq 1000\n$$\n\n解法：二分搜索\n\n先排好序，然后查找m-ka-kb-kc(假设为x)，查找数组中间的元素\n\n- 如果它比x小，x只能在后半段\n- 如果它比x大，x只能在前半段\n\n$$\n总时间复杂度：O(n^3logn)\n$$\n\n```cpp\n//二分查找方法\nbool binary_search(vector<int> nums,int target){\n\tint l=0,r=nums.size()-1;\n\twhile(l<=r){\n\t\tint mid=l+(r-l)/2;\n\t\tint com=nums[mid]-target;\n\t\tif(com==0) return true;\n\t\telse if(com>0){\n\t\t\tr=mid-1;\n\t\t}else{\n\t\t\tl=mid+1;\n\t\t}\n\t}\n\treturn false;\n}\n```\n\n这样的时间复杂度还是太大，继续改进\n\n先枚举出$kc+kd$，然后寻找$kc+kd=m-ka-kb$\n\n时间复杂度： $排序O(n^2logn)+循环O(n^2logn)$\n\n![](./算法刷题记录/qq_pic_merged_1717914931937.jpg)\n\n![](./算法刷题记录/qq_pic_merged_1717914879578.jpg)\n\n## 二进制枚举法\n\n使用二进制与位运算\n\n![](./算法刷题记录/qq_pic_merged_1717916148154.jpg)\n\n```c\ntypedef long long ll;\nint a[MAX_N];\nint n,k;\nvoid solve(){\n\tll mask=1<<n;\n\tfor(ll i=1;i<mask;i++){\n\t\tll t=i;\n\t\tint m=0;\n\t\tint sum=0;\n\t\twhile(t){\n\t\t\tif(t&1) sum+=a[m];\n\t\t\tm++;\n\t\t\tt>>1;\n\t\t}\n\t\tif(sum==k){\n\t\t\tprintf(\"Yes\\n\");\n\t\t}\n\t}\n\tprintf(\"No\\n\");\n}\n```\n\n也可以用DFS（回溯法）\n\n```c\nint a[MAX_N];\nint n,k;\n\nbool dfs(int index,int sum){\n\tif(i==n) return sum==k;\n\tif(dfs(i+1,sum)) return true;\n\tif(dfs(i+1,sum+a[i])) return true;\n\treturn false;\n}\nvoid solve(){\n\tif(dfs(0,0)) printf(\"Yes\\n\");\n\telse printf(\"No\\n\");\n}\n```\n\n## DFS\n### 连通域判断\n![](./算法刷题记录/qq_pic_merged_1717939197339.jpg)\n\n```c\n#include<stdio.h>\nchar map[101][101];\nint m;\nint n;\nvoid dfs(int x,int y){\n\tmap[x][y]='.';\n\tfor(int dx=-1;dx<=1;dx++){\n\t\tfor(int dy=-1;dy<=1;dy++){\n\t\t\tint nx=x+dx;\n\t\t\tint ny=y+dy;\n\t\t\tif(nx>=0&&nx<n&&ny>=0&&ny<m&&map[nx][ny]=='W'){\n\t\t\t\tdfs(nx,ny);\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%s\",map[i]);\n\t}\n\tint ans=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(map[i][j]=='W'){\n\t\t\t\tdfs(i,j);\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n\n\n还有道力扣：\n### 字母迷宫\n![](./算法刷题记录/Untitled.png)\n![](./算法刷题记录/Untitled%201.png)\n\n```cpp\n#include<vector>\n#include<string>\nusing namespace std;\nclass Solution {\npublic:\n    bool wordPuzzle(vector<vector<char>>& grid, string target) {\n        vector<vector<bool>> used(grid.size(),vector<bool>(grid[0].size(),false));\n        for(int i=0;i<grid.size();i++){\n            for(int j=0;j<grid[i].size();j++){\n                used[i][j]=true;\n                if(dfs(grid,target,0,i,j,used)) return true;\n                used[i][j]=false;\n            }\n        }\n        return false;\n    }\n    int dirx[4]={-1,0,0,1};\n    int diry[4]={0,1,-1,0};\n    bool dfs(vector<vector<char>>& grid,string target,int index,int x,int y,vector<vector<bool>> used){\n        if(index==target.length()-1) \n            return target.at(index)==grid[x][y];\n        if(target.at(index)!=grid[x][y]) return false;\n        for(int i=0;i<4;i++){\n            int nx=x+dirx[i];\n            int ny=y+diry[i];\n            if(nx>=0&&nx<grid.size()&&ny>=0&&ny<grid[0].size()&&used[nx][ny]==false){\n                used[nx][ny]=true;\n                bool res=dfs(grid,target,index+1,nx,ny,used);\n                used[nx][ny]=false;\n                if(res) return true;\n            }\n        }\n        return false;\n    }\n};\n```\n\n这里有一个大佬的解：\n\n```cpp\nclass Solution {\npublic:\n    bool exist(vector<vector<char>>& board, string word) {\n        int rows = board.size(), cols = board[0].size();\n\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++) {\n                if (board[r][c] == word[0] && dfs(board, word, 0, r, c)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    bool dfs(vector<vector<char>>& board, string& word, int index, int row, int col) {\n        if (index == word.size()) {\n            return true;\n        }\n\n        if (row < 0 || col < 0 || row >= board.size() || col >= board[0].size()) {\n            return false;\n        }\n\n        if (board[row][col] != word[index]) {\n            return false;\n        }\n    \n        auto board_val = board[row][col];\n        board[row][col] = '0';//用当前数组代替了used\n        bool result = dfs(board, word, index + 1, row - 1, col);\n        result = result || dfs(board, word, index + 1, row + 1, col);\n        result = result || dfs(board, word, index + 1, row, col - 1);\n        result = result || dfs(board, word, index + 1, row, col + 1);\n        board[row][col] = board_val;\n\n        return result;\n    }\n};\n```\n\n### 二叉树\n![](./算法刷题记录/Untitled%202.png)\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n#include<string>\n#include<vector>\n#include<stack>\nclass Solution {\npublic:\n    vector<string> ans;\n    vector<string> binaryTreePaths(TreeNode* root) {\n        vector<int> stk;\n        stk.push_back(root->val);\n        dfs(root,stk);\n        return ans;\n    }\n    void dfs(TreeNode* root, vector<int>& stk){\n        if(isleaf(root)!=0){\n            ans.push_back(copy(stk));\n            return;\n        }\n        if(root->left==nullptr){\n            stk.push_back(root->right->val);\n            dfs(root->right,stk);\n            stk.pop_back();\n        }else if(root->right==nullptr){\n            stk.push_back(root->left->val);\n            dfs(root->left,stk);\n            stk.pop_back();\n        }else {\n            stk.push_back(root->left->val);\n            dfs(root->left,stk);\n            stk.pop_back();\n\n            stk.push_back(root->right->val);\n            dfs(root->right,stk);\n            stk.pop_back();\n        }\n    }\n    string copy(vector<int>& stk){\n        string ans=\"\";\n        for(int i=0;i<stk.size();i++){\n            if(i!=0) ans+=\"->\";\n            ans+=to_string(stk[i]);\n        }\n        return ans;\n    }\n    int isleaf(TreeNode* root){\n        if(root==nullptr) return -1;\n        if(root->right==nullptr&&root->left==nullptr) return 1;\n        return 0;\n    }\n    \n};\n```\n\n## BFS\n\n### 迷宫\n\n![](./算法刷题记录/Untitled.jpeg)\n\n![](./算法刷题记录/Untitled%201.jpeg)\n\n![](./算法刷题记录/Untitled%202.jpeg)\n\n\n### 二叉树层序遍历\n\n![](./算法刷题记录/Untitled%204.png)\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\n#include<vector>\n#include<queue>\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> ans;\n        queue<pair<int,TreeNode*>> q;\n        if(root==nullptr) return ans;\n        q.push(make_pair(0,root));\n        while(q.size()){\n            pair<int,TreeNode*> t=q.front();q.pop();\n            int level=t.first;\n            TreeNode* node=t.second;\n            if(level<ans.size()){\n                ans[level].push_back(node->val);\n            }else{\n                vector<int> next(1,node->val);\n                ans.push_back(next);\n            }\n            if(node->left!=nullptr){\n                q.push(make_pair(level+1,node->left));\n            }\n            if(node->right!=nullptr){\n                q.push(make_pair(level+1,node->right));\n            }\n        }\n        return ans;\n    }\n};\n```\n\n### N叉树层序遍历\n\n![](./算法刷题记录/Untitled%205.png)\n\n![](./算法刷题记录/Untitled%206.png)\n\n```cpp\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n#include<queue>\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(Node* root) {\n        vector<vector<int>> ans;\n        queue<pair<int,Node*>> q;\n        if(root==nullptr) return ans;\n        q.push(make_pair(0,root));\n        while(q.size()){\n            pair<int,Node*> t=q.front();q.pop();\n            int level=t.first;\n            Node* node=t.second;\n            if(level<ans.size()){\n                ans[level].push_back(node->val);\n            }else{\n                vector<int> next(1,node->val);\n                ans.push_back(next);\n            }\n            vector<Node*> cld=node->children;\n            for(int i=0;i<cld.size();i++){\n                if(cld[i]!=nullptr){\n                    q.push(make_pair(level+1,cld[i]));\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n# 贪心\n## 心算挑战\n![](./算法刷题记录/Untitled%207.png)\n\n这题一开始没想到：\n\n**排序先取最大的cnt个数，如果它们的和是偶数直接输出，不然就找一个已取的最小的奇数换成剩下未取的最大的偶数，或者找一个已取的最小的偶数换成剩下未取的最大奇数**\n\n看看大佬答案：\n\n```cpp\nclass Solution {\npublic:\n    int maxmiumScore(vector<int>& cards, int cnt) {\n        sort(cards.begin(), cards.end(), greater<int>());\n        int res = 0, lastodd = 0, lasteven = 0;\n        for (int i = 0; i < cnt; i++)\n        {\n            res += cards[i];\n            if (cards[i] % 2 == 1) lastodd = cards[i];\n            else lasteven = cards[i];\n        }\n        if (res % 2 == 0) return res;\n\n        int max1 = 0, max2 = 0;\n        for (int i = cnt; i < cards.size(); i++)\n        {\n            if (lasteven && max1 == 0 && cards[i]%2) max1 = res - lasteven + cards[i];\n            if (lastodd && max2 == 0 && cards[i]%2 == 0) max2 = res - lastodd + cards[i];\n        }\n        return max(max1, max2);\n    }\n};\n```\n## 硬币问题\n![](./算法刷题记录/qq_pic_merged_1718006386488.jpg)\n\n优先使用大面值的硬币：\n\n```cpp\nconst int V[6]={1, 5, 10, 50, 100, 500};\nint C[6];//\nint A;\n\nvoid solve(){\n\tint ans=0;\n\tfor(int i=5;i>=0;i++){\n\t\tint t = min(A/V[i], C[i]);\n\t\tA -= t*V[i];\n\t\tans+=t;\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n}\n```\n## 字典序最小\n![](./算法刷题记录/qq_pic_merged_1718006622569.jpg)\n\n![](./算法刷题记录/qq_pic_merged_1718006677452.jpg)\n\n![](./算法刷题记录/qq_pic_merged_1718006696584.jpg)\n\n![](./算法刷题记录/qq_pic_merged_1718006711202.jpg)\n\n## 哈夫曼编码\n\n![](./算法刷题记录/qq_pic_merged_1718006911989.jpg)\n\n```cpp\n#include<iostream>\n#include <queue>\n#include<vector>\nusing namespace std;\ntypedef long long ll;//开ll才不会溢出\nint main(){\n    priority_queue<ll,vector<ll>,greater<ll> > q;\n    int n;\n    cin>>n;\n    ll x;\n    for(int i=0;i<n;i++){\n        cin>>x;\n        q.push(x);\n    }\n    ll ans=0;\n    while(q.size()>1){\n        // ans+=q.front();\n        ll y1=q.top();\n        q.pop();\n        ll y2=q.top();\n        q.pop();\n        ans+=(y1+y2);\n        q.push(y1+y2);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n```\n\n动态规划先不看\n\n先看数学：\n# 数学\n## 辗转相除法\n\n![](./算法刷题记录/qq_pic_merged_1718008211277.jpg)\n\n鬼能看出这题是求最大公约数\n\n$$\n答案就是|x_1-x_2|和|y_1-y2|的最大公约数-1！！！！\n$$\n\n现在问题来到计算最大公约数：\n\n### 辗转相除法\n\n```cpp\nint gcd(int a, int b) {\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\n```\n\n$$\n时间复杂度：O(log max(a,b))以内\n$$\n\n还有一些比较低效的方法：https://blog.csdn.net/Brilliance_panpan/article/details/88372432\n\n### 扩展欧几里得算法\n\n$$\n求整数x和y使得ax+by=1\n$$\n\n可以发现，如果gcd(a,b)不等于1，无解；如果gcd(a,b)=1,就可以通过扩展原来的辗转相除法来求解。事实上，一定存在整数对（x,y）使得ax+by=gcd(a,b)。\n\n![](./算法刷题记录/Untitled%208.png)\n\n代码：\n\n```cpp\nint extgcd(int a,int b,int& x,int& y){\n\tint d=a;\n\tif(b){\n\t\td=extgcd(b,a%b,y,x);\n\t\ty-=(a/b)*x;\n\t}else{\n\t\tx=1;y=0;\n\t}\n\treturn d;\n}\n```\n\n## 素数\n\n### 素性检验\n\n$$\n给定整数n，判断n是不是素数(1\\leq n \\leq 10^9)\n$$\n\n想到的最直接的方法就是从2到n-1遍历，能整除就不是素数，但是时间复杂度太大；实际上我们只需要检查2~根号n的整数就可以。\n\n```cpp\nint n;\nvoid solve(){\n\tif(n==2){\n\t\tprintf(\"Yes\\n\");\n\t\treturn;\n\t}\n\tfor(int i=2;i*i<=n;i++){\n\t\tif(n%i==0){\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tprintf(\"Yes\\n\");\n}\n```\n\n$$\n给定整数n,请问n以内有多少个素数？（n \\leq 10^6）\n$$\n\n### 埃氏筛法\n\n首先把2到n范围内的所有整数谢下来，最小的数组2是素数，将表中所有2的倍数划去，然后是3（素数），将3的倍数全部划去，以此类推。\n\n![](./算法刷题记录/qq_pic_merged_1718012475501.jpg)\n\n\n![](./算法刷题记录/Untitled%2015.png)\n\n```cpp\n#include<vector>\nclass Solution {\npublic:\n    int countPrimes(int n) {\n        if(n<2) return 0;\n        vector<bool> isPrime(n,true);\n        isPrime[0]=false;\n        isPrime[1]=false;\n        int ans=0;\n        for(int i=2;i<n;i++){\n            if(isPrime[i]){\n                ans++;\n                if(2*i<n){\n                    for(int j=2*i;j<n;j+=i){\n                        isPrime[j]=false;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n### 区间筛法\n\n![](./算法刷题记录/qq_pic_merged_1718012639631.jpg)\n\n![](./算法刷题记录/qq_pic_merged_1718012675564.jpg)\n\n![](./算法刷题记录/qq_pic_merged_1718012812983.jpg)\n\n### 快速幂运算\n\n![](./算法刷题记录/qq_pic_merged_1718012862839.jpg)\n\n思路：\n\n![](./算法刷题记录/qq_pic_merged_1718013054084.jpg)\n\n代码1：\n\n![](./算法刷题记录/qq_pic_merged_1718013072543.jpg)\n\n代码2（递归）：\n\n![](./算法刷题记录/qq_pic_merged_1718013088936.jpg)\n\n# 贪心\n## 救生艇\n![](./算法刷题记录/Untitled%209.png)\n\n思路：先把people排序，每次均从头和从尾各选取一个人凑在一条船上，能凑上就凑，凑不上就放大的。\n\n```cpp\n#include<vector>\n#include<algorithm>\nclass Solution {\npublic:\n    int numRescueBoats(vector<int>& people, int limit) {\n        sort(people.begin(),people.end());//从小到大排序\n        int ans=0;\n        int pbig=people.size()-1;\n        int psml=0;\n        while(pbig>psml){\n            int big=people[pbig];\n            int small=people[psml];\n            if(big+small<=limit) {\n                ans++;\n                psml++;\n                pbig--;\n            }\n            else{\n                ans++;\n                pbig--;\n            }\n        }\n        if(pbig==psml) ans++;\n        return ans;\n    }\n};\n```\n## 最大数\n![](./算法刷题记录/Untitled%2010.png)\n\n![](./算法刷题记录/Untitled%2011.png)\n\n```cpp\n#include <vector>\n#include <algorithm>\ntypedef unsigned long long ll;\nll pingjie(ll a, ll b)\n{\n    ll x = b;\n    if (x == 0)\n        return a * 10;\n    while (x > 0)\n    {\n        a = a * 10;\n        x /= 10;\n    }\n    a += b;\n    return a;\n}\nbool cmp(int a, int b)\n{\n    ll ab = pingjie(a, b);\n    ll ba = pingjie(b, a);\n    return ab > ba;\n}\n\nclass Solution\n{\npublic:\n    string largestNumber(vector<int> &nums)\n    {\n        sort(nums.begin(), nums.end(), cmp);\n        if(nums[0]==0) return \"0\";\n        string ans;\n        for (int i = 0; i < nums.size(); i++)\n        {\n            ans += to_string(nums[i]);\n        }\n        return ans;\n    }\n};\n```\n\n可以优化比较方法：c++中，sort中自定义的比较函数可以直接用字符串比较\n\n```cpp\nsort(nums.begin(), nums.end(), [](const int &x, const int &y) {\n\treturn to_string(x) + to_string(y) > to_string(y) + to_string(x);\n});\n```\n## 加油站\n![](./算法刷题记录/Untitled%2012.png)\n\n![](./算法刷题记录/Untitled%2013.png)\n\n```cpp\n/*\n\t这题一开始暴力，没有优化，TLK了，后面看了答案优化了过了。\n\t**关键点：我们首先检查第 000 个加油站，并试图判断能否环绕一周；\n\t\t\t\t\t如果不能，就从第一个无法到达的加油站开始继续检查。**\n*/\n#include<vector>\n#include<set>\nclass Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int n=gas.size();\n        set<int> st;\n        int begin_index=-1;\n        for(int i=0;i<gas.size();i++){\n            if(gas[i]-cost[i]>=0) {\n                begin_index=i;\n                break;\n            }\n        }\n        if(begin_index==-1) return -1;\n        int bugindex=-1;\n        st.insert(begin_index);\n        for(;begin_index<n;){\n            int total=gas[begin_index]-cost[begin_index];\n            for(int j=(begin_index+1)%n;j!=begin_index;j=(j+1)%n){\n                total+=(gas[j]-cost[j]);\n                if(total<0) {\n                    bugindex=j;\n                    break;\n                }\n            }\n            if(total>=0) return begin_index;\n            else{\n                int k;\n                for(k=bugindex;;k=(k+1)%n){\n                    if(gas[k]>=cost[k]) {\n                        break;\n                    }\n                }\n                begin_index=k;\n                if(st.count(begin_index)) return -1;\n                else st.insert(begin_index);\n            }\n        }\n        return -1;\n    }\n};\n```\n\n## 经典跳跃游戏\n\n初级版\n\n![](./算法刷题记录/Untitled%2014.png)\n\n```cpp\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int maxindex=0;\n        for(int i=0;i<=maxindex&&i<nums.size();i++){\n            maxindex=max(maxindex,i+nums[i]);\n        }\n        return maxindex>=nums.size()-1;\n    }\n};\n```\n\n# 动态规划\n## 最小路径和\n![](./算法刷题记录/Untitled%2016.png)\n\n```cpp\nclass Solution {\npublic:\n    int dp[201][201];\n    int minimumTotal(vector<vector<int>>& triangle) {\n        memset(dp,-1,sizeof dp);\n        dp[0][0]=triangle[0][0];\n        for(int i=1;i<triangle.size();i++){\n            for(int j=0;j<=i;j++){\n                if(i==j){\n                    dp[i][j]=dp[i-1][j-1]+triangle[i][j];\n                }else if(j==0){\n                    dp[i][j]=dp[i-1][j]+triangle[i][j];\n                }else{\n                    dp[i][j]=min(dp[i-1][j-1],dp[i-1][j])+triangle[i][j];\n                }\n            }\n        }\n        int min=dp[triangle.size()-1][0];\n        for(int i=1;i<triangle.size();i++){\n            if(min>dp[triangle.size()-1][i])\n                min=dp[triangle.size()-1][i];\n        }\n        return min;\n    }\n};\n```\n\n**压缩后：**\n\n```cpp\nclass Solution {\npublic:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        int n = triangle.size();\n        vector<vector<int>> f(2, vector<int>(n));\n        f[0][0] = triangle[0][0];\n        for (int i = 1; i < n; ++i) {\n            int curr = i % 2;\n            int prev = 1 - curr;\n            f[curr][0] = f[prev][0] + triangle[i][0];\n            for (int j = 1; j < i; ++j) {\n                f[curr][j] = min(f[prev][j - 1], f[prev][j]) + triangle[i][j];\n            }\n            f[curr][i] = f[prev][i - 1] + triangle[i][i];\n        }\n        return *min_element(f[(n - 1) % 2].begin(), f[(n - 1) % 2].end());\n    }\n};\n\n// 作者：力扣官方题解\n// 链接：https://leetcode.cn/problems/IlPe0q/solutions/1036365/san-jiao-xing-zhong-zui-xiao-lu-jing-zhi-srun/\n// 来源：力扣（LeetCode）\n// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n## leetcode 2849\n![](./算法刷题记录/Untitled%2017.png)\n\n![](./算法刷题记录/Untitled%2018.png)\n\n题解：\n\n![](./算法刷题记录/Untitled%2019.png)\n\n```cpp\nclass Solution {\npublic:\n    bool isReachableAtTime(int sx, int sy, int fx, int fy, int t) {\n        if(sx==fx&&sy==fy) return t!=1;\n        return t>=max(abs(sx-fx),abs(sy-fy));\n    }\n};\n```\n## 分糖果I\n![](./算法刷题记录/Untitled%2020.png)\n\n```cpp\nclass Solution {\npublic:\n    int distributeCandies(int n, int limit) {\n        int ans=0;\n        for(int i=0;i<=limit;i++){\n            for(int j=0;j<=n-i&&j<=limit;j++){\n                if(n-i-j<=limit) ans++;\n            }\n        }\n        return ans;\n    }\n};\n```\n## 分糖果II\n![](./算法刷题记录/Untitled%2021.png)\n\n```cpp\nclass Solution {\npublic:\n    long long distributeCandies(int n, int limit) {\n        if(limit<n/3) return 0;\n        long long ans=0;\n        for(int i=max(0,n-2*limit);i<=limit&&n-i>=0;i++){\n            int k=n-i;\n            if(k<limit) ans+=k+1;\n            else ans+=limit-(k-limit)+1;\n        }\n        return ans;\n    }\n};\n```\n# 杂题\n## 删除重复项\n![](./算法刷题记录/Untitled%2022.png)\n\n![](./算法刷题记录/Untitled%2023.png)\n\n```cpp\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int n=nums.size();\n        int cnt=0;\n        for(int i=0;i<n;i++){\n            if(i>0&& nums[i]!=nums[i-1]) cnt=1;\n            else cnt++;\n            if(cnt==3){\n                remove(nums,i,n);\n                n--;\n                cnt--;\n                i--;\n            }\n        }\n        return n;\n    }\n    void remove(vector<int>& nums,int index,int end){\n        for(int i=index;i<end-1;i++){\n            nums[i]=nums[i+1];\n        }\n    }\n};\n```","categories":["算法"]},{"title":"排序算法","url":"/2024/08/01/排序算法/","content":"\n> **排序是指重新排列列表中的元素，使表中的元素按照关键字有序的过程**\n\n# 分类\n\n- 按照稳定性分类\n  \n  ![](./排序算法/Untitled.png)\n    \n- 内部排序与外部排序\n    - 内部排序：数据都在内存中（考虑时间复杂度和空间复杂度）\n    - 外部排序：数据太多，无法全部放入内存（还需要考虑读写磁盘次数）\n\n**[可视化]([Comparison Sorting Visualization (usfca.edu)](https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html))**\n\n# 插入排序（稳定的）\n\n算法思想：每次将一个待排序的记录按照其关键字大小插入到前面已经排行的子序列中，知道全部记录插入完成。\n\n```java\npublic static void insertSortAsc(int[] arr){\n    int n=arr.length;\n    int i,j;\n    for (i=1;i<n;i++){\n        if (arr[i]<arr[i-1]){\n            int temp=arr[i];\n            for (j=i-1;j>=0&&temp<arr[j];j--){\n                arr[j+1]=arr[j];\n            }\n            arr[j+1]=temp;\n        }\n    }\n}\n```\n\n> **代码思路：**从第二个元素开始遍历，当当前元素的关键字与前一个元素的关键字不满足规定的排序方式时，这个时候，当前元素要插入前面已经排好序的序列之中，操作如下：用一个变量存储当前元素，对于前面已经排好的序列中的元素，从后往前遍历，每遇到一个比需要插入的元素的关键字小（或大，更精确的描述应该是不满足规定的排序方式）的元素，就将该元素后移一格，直到遇到满足规定排序方式的元素，将暂存变量的值赋值给改元素后一个格子的位置。\n\n## review\n\n```java\npublic static void insertSort(Element[] elements){\n    int i,j;\n    for (i=1;i<elements.length;i++){\n        if (elements[i].getKey()<elements[i-1].getKey()){\n            Element tmp=elements[i];\n            for (j=i-1;j>=0&&elements[j].getKey()>tmp.getKey();j--){\n                elements[j+1]=elements[j];\n            }\n            elements[j+1]=tmp;\n        }\n    }\n}\n```\n\n# 选择排序（不稳定的）\n\n算法思想：每次从未排序好中的序列中选择一个关键字最大（最小）的元素放入到排序好序列的后面即可\n\n```java\n//不稳定的排序\npublic static void selectSort(Element[] elements){\n    int start=0;\n    for (;start<elements.length;start++){\n        int minIndex=start;\n        for (int i=start+1;i<elements.length;i++){\n            if (elements[i].getKey()<elements[minIndex].getKey()){\n                minIndex=i;\n            }\n        }\n        swap(elements,minIndex,start);\n    }\n}\n```\n\n# 冒泡排序（稳定的）\n\n算法思想：每迭代一轮都比较相邻俩元素大小，不满足排序规则则交换他们\n\n```java\n//稳定的排序\npublic static void bobbleSort(Element[] elements){\n    //从前往后冒泡,使得末尾的序列元素必然是排好的\n    for (int end=elements.length-1;end>=0;end--){\n        for (int i=0;i<end;i++){\n            if (elements[i].getKey()>elements[i+1].getKey()){\n                swap(elements,i,i+1);\n            }\n        }\n    }\n}\n```\n\n# 希尔排序\n\n算法思想：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录\"基本有序\"时，再对全体记录进行依次直接插入排序。\n\n大概意思就是，先等间隔分组，分好组后组内先排序，然后再等间隔分组（间隔减半），再组内排序，循环迭代，直到间隔为1并排行序号。\n\n利用的原理是，先分组排序，利用插入排序的优势：当序列较为有序时，算法效率高。\n\n```java\nprivate static void insertSortHelper(Element[] elements,int gap,int start){\n    int i,j;\n    for (i=start+gap;i<elements.length;i++){\n        if (elements[i].getKey()<elements[i-gap].getKey()){\n            Element tmp=elements[i];\n            for (j=i-gap;j>=0&&elements[j].getKey()>tmp.getKey();j=j-gap) {\n                elements[j+gap]=elements[j];\n            }\n            elements[j+gap]=tmp;\n        }\n    }\n}\n\npublic static void shellSort(Element[] elements){\n    int gap=elements.length/2;\n    while (gap>0){\n        for (int i = 0; i < gap ; i++) {\n            insertSortHelper(elements,gap,i);\n        }\n        gap/=5;\n    }\n}\n```\n\n# 归并排序\n\n算法思路：先分再合，分：等分序列；合：排序合并序列（使用双指针）\n\n![](./排序算法/Untitled%201.png)\n\n```java\nprivate static void integerite(Element[] elements,int left1,int right1,int left2,int right2){\n    int index1=left1;\n    int index2=left2;\n    int currIndex=left1;\n    while (currIndex<=right2){\n        int compare= 0;\n        if (index1>right1) compare=1;\n        else if (index2>right2) compare=-1;\n        else compare=elements[index1].getKey()-elements[index2].getKey();\n        if (compare>0){\n            elements[currIndex++]=elements[index2++];\n        } else {\n            elements[currIndex++]=elements[index1++];\n        }\n    }\n}\n\nprivate static void mergeSortHelper(Element[] elements,int left,int right){\n    if (left>=right) return;\n    int mid=(left+right)/2;\n    mergeSortHelper(elements,left,mid);\n    mergeSortHelper(elements,mid+1,right);\n    integerite(elements,left,mid,mid+1,right);\n}\n\npublic static void mergeSort(Element[] elements){\n    mergeSortHelper(elements,0,elements.length-1);\n}\n```\n\n时间复杂度分析：$O(nlogn)$\n\n# 快速排序\n\n算法思想：分治思想，取一个基准值，让比基准值小的放一边，比基准值大的放一边（双指针实现）。\n\n**一定要先移动右指针！！！**\n\n```cpp\nvoid Sort::quick_sort(vector<int> &nums) {\n    quick_sort_helper(nums,0,nums.size()-1);\n}\n\nvoid Sort::quick_sort_helper(vector<int> &nums,\n                             int start, int end) {\n    if (start>=end) return;\n    int pivot=nums[start];\n    int left=start;\n    int right=end;\n    while (left<right){\n        //先移动right\n        while (right>left&&nums[right]>=pivot){\n            right--;\n        }\n        while (right>left&&nums[left]<=pivot){\n            left++;\n        }\n        swap(nums[left],nums[right]);\n    }\n    nums[right]=pivot;\n    quick_sort_helper(nums,start,right-1);\n    quick_sort_helper(nums,right+1,end);\n}\n```","categories":["算法"]}]