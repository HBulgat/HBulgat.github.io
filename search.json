[{"title":"实习准备DAY1","url":"/2024/09/26/实习准备DAY1/","content":"\n# 基础概念\n\n## Java特点\n\n1. 支持面向对象\n2. 跨平台\n3. 支持多线程\n4. 可靠（异常处理、自动内存管理）\n5. 安全（强类型、访问修饰符）\n6. 高效\n7. 支持网络编程\n8. 编译与解释并存（先编译成.class文件，然后class文件一行一行运行在JVM上）\n\n## Java SE与Java EE\n\n- Java SE：Java 平台标准版，Java 编程语言的基础，它包含了支持 Java 应用程序开发和运行的核心类库以及虚拟机等核心组件。Java SE 可以用于构建桌面应用程序或简单的服务器应用程序。\n- Java EE：Java 平台企业版，建立在 Java SE 的基础上，包含了支持企业级应用程序开发和部署的标准和规范（比如 Servlet、JSP、EJB、JDBC、JPA、JTA、JavaMail、JMS）。 Java EE 可以用于构建分布式、可移植、健壮、可伸缩和安全的服务端 Java 应用程序，例如 Web 应用程序。\n\n## JVM\n\n运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是**使用相同的字节码，它们都会给出相同的结果。**字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。\n\n![运行在 Java 虚拟机之上的编程语言](./实习准备DAY1/1.png)\n\n**JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。**\n\n## JDK与JRE\n\n1. JDK（Java Development Kit）是一个功能齐全的 Java 开发工具包，供开发者使用，用于创建和编译 Java 程序。它包含了 JRE（Java Runtime Environment），以及编译器 javac 和其他工具，如 javadoc（文档生成器）、jdb（调试器）、jconsole（监控工具）、javap（反编译工具）等。\n2. JRE 是运行已编译 Java 程序所需的环境，主要包含以下两个部分：\n   1. **JVM** : 也就是我们上面提到的 Java 虚拟机。\n   2. **Java 基础类库（Class Library）**：一组标准的类库，提供常用的功能和 API（如 I/O 操作、网络通信、数据结构等）。\n\n**JRE 只包含运行 Java 程序所需的环境和类库，而 JDK 不仅包含 JRE，还包括用于开发和调试 Java 程序的工具。**\n\n​\t\t某些需要 Java 特性的应用程序（如 JSP 转换为 Servlet 或使用反射）也可能需要 JDK 来编译和运行 Java 代码。因此，即使不进行 Java 开发工作，有时也可能需要安装 JDK。\n\n## 什么字节码?采用字节码的好处是什么\n\n在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 `.class` 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C、 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。\n\n![Java程序转变为机器代码的过程](./实习准备DAY1/2.png)\n\n需要格外注意的是 `.class->机器码` 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 **JIT（Just in Time Compilation）** 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 **Java 是编译与解释共存的语言** 。**（局部性原理？二八定律，90 10法则）**\n\n![Java程序转变为机器代码的过程](./实习准备DAY1/3.png)\n\n![JDK、JRE、JVM、JIT 这四者的关系](./实习准备DAY1/4.png)\n\n​\t\t\t\t\t\t\t\t\t\tJDK、JRE、JVM、JIT 这四者的关系\n\n## AOT\n\nJDK 9 引入了一种新的编译模式 **AOT(Ahead of Time Compilation)** 。和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。\n\n![JIT vs AOT](./实习准备DAY1/5.png)\n\nAOT 的主要优势在于启动时间、内存占用和打包体积。JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。\n\nAOT 更适合当下的云原生场景，对微服务架构的支持也比较友好。除此之外，AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。然而，很多框架和库（如 Spring、CGLIB）都用到了这些特性。如果只使用 AOT 编译，那就没办法使用这些框架和库了，或者说需要针对性地去做适配和优化。举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 `.class` 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。\n\n## Oracle JKD和OpenJDK的比较\n\n1. 是否开源\n2. 是否免费\n3. 功能性\n4. 稳定性（Oracle JDK>OpenJDK）\n5. 协议\n\n## Java和C++的比较\n\n相同点：都是面向对象的语言，支持封装继承多态\n\n不同点：\n\n- Java 不提供指针来直接访问内存，程序内存更加安全\n- Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。\n- Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。\n- C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。\n\n\n\n## 标识符和关键字的区别\n\n- **标识符就是一个名字**；（可以自己取名字）\n- **关键字是被赋予特殊含义的标识符** 。（不能自己取名字）\n\n **`true`, `false`, 和 `null` 看起来像关键字但实际上他们是字面值，同时你也不可以作为标识符来使用。** \n\n## 自增自减运算符\n\n**符号在前就先加/减，符号在后就后加/减**。\n\n## 移位运算符\n\n优点：\n\n1. **高效**：移位运算符直接对应于处理器的移位指令。现代处理器具有专门的硬件指令来执行这些移位操作，这些指令通常在一个时钟周期内完成。相比之下，乘法和除法等算术运算在硬件层面上需要更多的时钟周期来完成。\n2. **节省内存**：通过移位操作，可以使用一个整数（如 `int` 或 `long`）来存储多个布尔值或标志位，从而节省内存。\n\n`>>>`：无符号右移，忽略符号位，空位都以0补齐\n\n一般用在：\n\n- **位字段管理**：例如存储和操作多个布尔值。\n- **哈希算法和加密解密**：通过移位和与、或等操作来混淆数据。\n- **数据压缩**：例如霍夫曼编码通过移位运算符可以快速处理和操作二进制数据，以生成紧凑的压缩格式。\n- **数据校验**：例如 CRC（循环冗余校验）通过移位和多项式除法生成和校验数据完整性。。\n- **内存对齐**：通过移位操作，可以轻松计算和调整数据的对齐地址。\n\n**`double`，`float` 在二进制中的表现比较特殊，因此不能来进位操作符**\n\n**移位实际上支持的类型只有`int`和`long`，编译器在对`short`、`byte`、`char`类型进行移位前，都会将其转换为`int`类型再操作。**\n\n> **如果移位的位数超过数值所占有的位数会怎样？**\n>\n> 当 int 类型左移/右移位数大于等于 32 位操作时，会先求余（%）后再进行左移/右移操作。也就是说左移/右移 32 位相当于不进行移位操作（32%32=0），左移/右移 42 位相当于左移/右移 10 位（42%32=10）。当 long 类型进行左移/右移操作时，由于 long 对应的二进制是 64 位，因此求余操作的基数也变成了 64。\n>\n> 也就是说：`x<<42`等同于`x<<10`，`x>>42`等同于`x>>10`，`x >>>42`等同于`x >>> 10`。\n\n## 基本数据类型\n\nJava 中有 8 种基本数据类型，分别为：\n\n- 6 种数字类型： \n  - 4 种整数型：`byte`、`short`、`int`、`long`\n  - 2 种浮点型：`float`、`double`\n- 1 种字符类型：`char`\n- 1 种布尔型：`boolean`。\n\n<img src=\"./实习准备DAY1/1727350962789.png\" style=\"zoom: 80%;\" />\n\n对于 `boolean`，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。\n\nJava 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一。\n\n这八种基本类型都有对应的包装类分别为：`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`、`Boolean` 。\n\n## 基本数据类型VS包装类型\n\n- **用途**：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，**包装类型可用于泛型，而基本类型不可以**。\n- **存储方式**：**基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中**，**基本数据类型的成员变量（未被 `static` 修饰 ）存放在 Java 虚拟机的堆中**。包装类型属于对象类型，我们知道**几乎所有对象实例都存在于堆中。**\n- **占用空间**：相比于包装类型（对象类型）， **基本数据类型占用的空间往往非常小。**\n- **默认值**：成员变量包装类型不赋值就是 `null` ，而基本类型有默认值且不是 `null`。\n- **比较方式**：对于基本数据类型来说，`==` 比较的是值。对于包装数据类型来说，`==` 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 `equals()` 方法。\n\n**为什么说是几乎所有对象实例都存在于堆中呢？** 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存。\n\n⚠️ 注意：**基本数据类型存放在栈中是一个常见的误区！** 基本数据类型的存储位置取决于它们的**作用域和声明方式**。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆/方法区/元空间中。\n\n```java\npublic class Test {\n    // 成员变量，存放在堆中\n    int a = 10;\n    // 被 static 修饰的成员变量，JDK 1.7 及之前位于方法区，1.8 后存放于元空间，均不存放于堆中。\n    // 变量属于类，不属于对象。\n    static int b = 20;\n\n    public void method() {\n        // 局部变量，存放在栈中\n        int c = 30;\n        static int d = 40; // 编译错误，不能在方法中使用 static 修饰局部变量\n    }\n}\n```\n\n## 包装类型的缓存机制\n\nJava 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。\n\n`Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，`Character` 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。\n\n如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。\n\n两种浮点数类型的包装类 `Float`,`Double` 并没有实现缓存机制。\n\n```java\nInteger i1 = 33;\nInteger i2 = 33;\nSystem.out.println(i1 == i2);// 输出 true\n\nFloat i11 = 333f;\nFloat i22 = 333f;\nSystem.out.println(i11 == i22);// 输出 false\n\nDouble i3 = 1.2;\nDouble i4 = 1.2;\nSystem.out.println(i3 == i4);// 输出 false\n```\n\n```java\nInteger i1 = 40;\nInteger i2 = new Integer(40);\nSystem.out.println(i1==i2); \n/* Integer i1=40 这一行代码会发生装箱，\n也就是说这行代码等价于 Integer i1=Integer.valueOf(40) 。\n因此，i1 直接使用的是缓存中的对象。\n而Integer i2 = new Integer(40) 会直接创建新的对象。\n因此，答案是 false.\n*/\n```\n\n## 自动装箱与拆箱\n\n**什么是自动拆装箱？**\n\n- **装箱**：将基本类型用它们对应的引用类型包装起来；\n- **拆箱**：将包装类型转换为基本数据类型；\n\n```java\nInteger i = 10;  //装箱\nint n = i;   //拆箱\n```\n\n\n\n装箱其实就是调用了 包装类的`valueOf()`方法，拆箱其实就是调用了 `xxxValue()`方法。\n\n因此：\n\n- `Integer i = 10` 等价于 `Integer i = Integer.valueOf(10)`\n- `int n = i` 等价于 `int n = i.intValue()`;\n\n**频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。**\n\n\n\n### 浮点数\n\n浮点数运算可能会导致精度丢失，这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。\n\n### 如何解决精度丢失\n\n`BigDecimal` 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 `BigDecimal` 来做的。\n\n```java\nBigDecimal a = new BigDecimal(\"1.0\");\nBigDecimal b = new BigDecimal(\"1.00\");\nBigDecimal c = new BigDecimal(\"0.8\");\n\nBigDecimal x = a.subtract(c);\nBigDecimal y = b.subtract(c);\n\nSystem.out.println(x); /* 0.2 */\nSystem.out.println(y); /* 0.20 */\n// 比较内容，不是比较值\nSystem.out.println(Objects.equals(x, y)); /* false */\n// 比较值相等用相等compareTo，相等返回0\nSystem.out.println(0 == x.compareTo(y)); /* true */\n```\n\n\n\n## BigInteger类\n\n`BigInteger` 内部使用 `int[]` 数组来存储任意大小的整形数据。\n\n相对于常规整数类型的运算来说，`BigInteger` 运算的效率会相对较低。\n\n\n\n## 变量\n\n### 成员变量与局部变量的区别\n\n- **语法形式**：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 `public`,`private`,`static` 等修饰符所修饰，而局部变量不能被访问控制修饰符及 `static` 所修饰；但是，成员变量和局部变量都能被 `final` 所修饰。\n- **存储方式**：从变量在内存中的存储方式来看，如果成员变量是使用 `static` 修饰的，那么这个成员变量是属于类的，如果没有使用 `static` 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。\n- **生存时间**：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。\n- **默认值**：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 `final` 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。\n\n\n\n## 静态方法为什么不能调用非静态成员\n\n1. 静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。\n2. 在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。\n\n\n\n## 静态方法和实例方法有何不同\n\n- **调用静态方法可以无需创建对象** \n- 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。\n\n## 重载VS重写\n\n- 重载\n\n  发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。\n\n  重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。\n\n- 重写\n\n  重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。\n\n  1. 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。\n  2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 `static` 修饰的方法能够被再次声明。\n  3. 构造方法无法被重写\n\n  关于 **重写的返回值类型** 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果**方法的返回值是引用类型，重写时是可以返回该引用类型的子类的**。\n\n## 可变长参数\n\n Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面这个方法就可以接受 0 个或者多个参数。\n\n```java\npublic static void method1(String... args) {\n   //......\n}\n```\n\n可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。\n\n```java\npublic static void method2(String arg1, String... args) {\n   //......\n}\n```\n\n**遇到方法重载时，会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。**\n\n**调用一个被重载的方法时，如果此调用既能够和两个可变长参数的重载方法匹配，则编译出错。**：\n\n```java\npublic class Varargs {\n\n    public static void test(String... args) {\n        System.out.println(\"version 1\");\n    }\n\n    public static void test(String arg1, String... arg2) {\n        System.out.println(\"version 2\");\n    }\n    public static void main(String[] args) {\n        test(\"a\",\"b\");//Compile error\n    }\n}\n```\n\n\n\n**Java 的可变参数编译后实际会被转换成一个数组**\n\n\n\n# 参考\n\n[javaguide]([Java 面试指南 | JavaGuide](https://javaguide.cn/))","categories":["Java"]},{"title":"设计模式","url":"/2024/09/21/设计模式/","content":"\n# 单例模式\n## 什么是单例模式\n单例模式是一种创建型设计模式， 它的核心思想是保证一个类只有一个实例，并提供一个全局访问点来访问这个实例。\n- 只有一个实例的意思是，在整个应用程序中，只存在该类的一个实例对象，而不是创建多个相同类型的对象。\n- 全局访问点是指，为了让其他类能够获取到这个唯一实例，该类提供了一个全局访问点（通常是一个静态方法），通过这个方法就能获得实例。 \n\n## 单例模式的优点\n- 全局控制：保证只有一个实例，这样就可以严格的控制客户怎样访问它以及何时访问它，简单的说就是对唯一实例的受控访问（引用自《大话设计模式》第21章）\n- 节省资源：也正是因为只有一个实例存在，就避免多次创建了相同的对象，从而节省了系统资源，而且多个模块还可以通过单例实例共享数据。\n- 懒加载：单例模式可以实现懒加载，只有在需要时才进行实例化，这无疑会提高程序的性能。\n\n## 单例模式的基本要求\n- 私有的构造函数：防止外部代码直接创建类的实例\n- 私有的静态实例变量：保存该类的唯一实例\n- 公有的静态方法：通过公有的静态方法来获取类的实例\n![](./设计模式/68747470733a2f2f6b737461722d313235333835353039332e636f732e61702d6e616e6a696e672e6d7971636c6f75642e636f6d2f6261677577656e312e302f696d6167652d32303234303130343131333832343938352e706e67.png)\n\n## 单例模式的实现\n单例模式的实现方式有多种，包括懒汉式、饿汉式等。\n- 懒汉式\n在类加载时就已经完成了实例的创建，不管后面创建的实例有没有使用，先创建再说，所以叫做 “饿汉”。\n```java\npublic class Singleton {\n    private static final Singleton instance = new Singleton();\n    \n    private Singleton() {\n        // 私有构造方法，防止外部实例化\n    }\n    \n    public static Singleton getInstance() {\n        return instance;\n    }\n}\n```\n- 饿汉式\n只有在请求实例时才会创建，如果在首次请求时还没有创建，就创建一个新的实例，如果已经创建，就返回已有的实例，意思就是需要使用了再创建，所以称为“懒汉”。\n```java\npublic class Singleton {\n    private static Singleton instance;\n    \n    private Singleton() {\n        // 私有构造方法，防止外部实例化\n    }\n    // 使用了同步关键字来确保线程安全, 可能会影响性能\n    public static synchronized Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n```\n在懒汉模式的基础上，可以使用双重检查锁来提高性能:\n```java\npublic class Singleton {\n    private static volatile Singleton instance;\n    \n    private Singleton() {\n        // 私有构造方法，防止外部实例化\n    }\n    \n    public static Singleton getInstance() {\n        if (instance == null) {\n            synchronized (Singleton.class) {\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n> 在多线程环境下，由于饿汉式在程序启动阶段就完成了实例的初始化，因此不存在多个线程同时尝试初始化实例的问题，但是懒汉式中多个线程同时访问`getInstance()`方法，并且在同一时刻检测到实例没有被创建，就可能会同时创建实例，从而导致多个实例被创建，这种情况下我们可以采用一些同步机制，例如使用互斥锁来确保在任何时刻只有一个线程能够执行实例的创建。\n\n## 单例模式的适用场景\n1. 资源共享  \n多个模块共享某个资源的时候，可以使用单例模式，比如说应用程序需要一个全局的配置管理器来存储和管理配置信息、亦或是使用单例模式管理数据库连接池。  \n2. 只有一个实例  \n当系统中某个类只需要一个实例来协调行为的时候，可以考虑使用单例模式， 比如说管理应用程序中的缓存，确保只有一个缓存实例，避免重复的缓存创建和管理，或者使用单例模式来创建和管理线程池。  \n3. 懒加载  \n如果对象创建本身就比较消耗资源，而且可能在整个程序中都不一定会使用，可以使用单例模式实现懒加载。\n\n\n## 练习题\n### 题目描述\n> 小明去了一家大型商场，拿到了一个购物车，并开始购物。请你设计一个购物车管理器，记录商品添加到购物车的信息（商品名称和购买数量），并在购买结束后打印出商品清单。（在整个购物过程中，小明只有一个购物车实例存在）。\n### 输入描述\n> 输入包含若干行，每行包含两部分信息，分别是商品名称和购买数量。商品名称和购买数量之间用空格隔开。\n### 输出描述\n> 输出包含小明购物车中的所有商品及其购买数量。每行输出一种商品的信息，格式为 \"商品名称 购买数量\"。\n### 输入示例\n```\nApple 3\nBanana 2\nOrange 5\n```\n### 输出示例\n```\nApple 3\nBanana 2\nOrange 5\n```\n### 提示信息\n> 本道题目请使用单例设计模式：   \n> 使用私有静态变量来保存购物车实例。  \n> 使用私有构造函数防止外部直接实例化。  \n### 代码\n```cpp\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\nclass shoppingCart\n{\nprivate:\n    unordered_map<string, int> goodsLst;\n    vector<string> orderLst;\n    \nprivate:\n    shoppingCart() {};\n    \npublic:\n    ~shoppingCart() {};\n    static shoppingCart* GetInstance();\n    void showCart();\n    void addCart(string gName, int gCnt);\n};\n\nshoppingCart* shoppingCart::GetInstance()\n{\n    static shoppingCart instance;\n    return &instance;\n}\n\nvoid shoppingCart::addCart(string gName, int gCnt)\n{\n    if (gName.empty() || gCnt <= 0)\n        return;\n    orderLst.push_back(gName);\n    goodsLst[gName] += gCnt;\n}\n\nvoid shoppingCart::showCart()\n{\n    if (!goodsLst.size())\n        return;\n    for (const auto& name : orderLst)\n        cout << name << \" \" << goodsLst.at(name) << endl;\n}\n\nint main(int argc, const char *argv[])\n{\n    shoppingCart *cart = shoppingCart::GetInstance();\n    int cnt;\n    string name;\n    while (cin >> name >> cnt)\n    {\n        cart->addCart(name, cnt);\n    }\n    cart->showCart();\n    return 0;\n}\n```\n\n\n# 工厂方法模式\n\n## 简单工厂模式\n> 简单工厂模式是一种创建型设计模式，但并不属于23种设计模式之一，更多的是一种编程习惯。\n\n简单工厂模式的核心思想是将产品的创建过程封装在一个工厂类中，把创建对象的流程集中在这个工厂类里面。\n\n> 简单工厂模式包括三个主要角色，工厂类、抽象产品、具体产品，下面的图示则展示了工厂类的基本结构。  \n- 抽象产品，描述产品的通用行为。\n- 具体产品: 实现抽象产品接口或继承抽象产品类，具体产品通过简单工厂类的if-else逻辑来实例化。\n- 工厂类：负责创建产品，根据传递的不同参数创建不同的产品示例。\n\n> 简单工厂类简化了客户端操作，客户端可以调用工厂方法来获取具体产品，而无需直接与具体产品类交互，降低了耦合，但是有一个很大的问题就是不够灵活，如果需要添加新的产品，就需要修改工厂类的代码。\n\n## 工厂方法模式\n> 工厂方法模式也是一种创建型设计模式，简单工厂模式只有一个工厂类，负责创建所有产品，如果要添加新的产品，通常需要修改工厂类的代码。而工厂方法模式引入了抽象工厂和具体工厂的概念，每个具体工厂只负责创建一个具体产品，添加新的产品只需要添加新的工厂类而无需修改原来的代码，这样就使得产品的生产更加灵活，支持扩展，符合开闭原则。\n\n工厂方法模式分为以下几个角色：  \n- 抽象工厂：一个接口，包含一个抽象的工厂方法（用于创建产品对象）。  \n- 具体工厂：实现抽象工厂接口，创建具体的产品。  \n- 抽象产品：定义产品的接口。  \n- 具体产品：实现抽象产品接口，是工厂创建的对象。\n\n> 实际上工厂方法模式也很好理解，就拿“手机Phone”这个产品举例，手机是一个抽象产品，小米手机、华为手机、苹果手机是具体的产品实现，而不同品牌的手机在各自的生产厂家生产。  \n![](./设计模式/2.png)\n\n## 基本实现\n根据上面的类图，我们可以写出工厂方法模式的基本实现。\n```java\n// 抽象产品\ninterface Shape {\n    void draw();\n}\n\n// 具体产品 - 圆形\nclass Circle implements Shape {\n    @Override\n    public void draw() {\n        System.out.println(\"Circle\");\n    }\n}\n\n// 具体产品 - 正方形\nclass Square implements Shape {\n    @Override\n    public void draw() {\n        System.out.println(\"Square\");\n    }\n}\n\n// 抽象工厂\ninterface ShapeFactory {\n    Shape createShape();\n}\n\n// 具体工厂 - 创建圆形\nclass CircleFactory implements ShapeFactory {\n    @Override\n    public Shape createShape() {\n        return new Circle();\n    }\n}\n\n// 具体工厂 - 创建正方形\nclass SquareFactory implements ShapeFactory {\n    @Override\n    public Shape createShape() {\n        return new Square();\n    }\n}\n\n// 客户端代码\npublic class Client {\n    public static void main(String[] args) {\n        ShapeFactory circleFactory = new CircleFactory();\n        Shape circle = circleFactory.createShape();\n        circle.draw();  // 输出：Circle\n\n        ShapeFactory squareFactory = new SquareFactory();\n        Shape square = squareFactory.createShape();\n        square.draw();  // 输出：Square\n    }\n}\n```\n\n","categories":["设计模式"]},{"title":"C_Cpp学习DAY1","url":"/2024/09/20/C-Cpp学习DAY1/","content":"\n# 编译过程\n\n> 在使用gcc编译程序时，编译过程可以简要划分为4个阶段：  \n> 1. 预处理  \n> 2. 汇编  \n> 3. 编译  \n> 4. 链接\n\n![](./C-Cpp学习DAY1/d022b7cbd85f5f769330c72f3fdd1e78.png)\n\n## 预处理  \n主要处理源文件中的#indef、#include和#define预处理命令；这里主要是把一些include的头文件和一些宏定义，放到源文件中。\n- 输入的是C语言的源文件\n- 输出 ：生成一个中间/预加载文件 *.i（以 .i 结尾的文件）\n- 这个阶段对应的gcc命令如下：\n`gcc –E（预处理） test.c（源文件） -o test.i（将结果生成的文件）`\n- 说明：它通过对源文件test.c使用E选项来生成中间文件test.i\n### -D 在编译的时候定义宏的。\n- -D后面直接跟宏名，相当于定义这个宏，默认这个宏的内容是1，如`gcc -DDEBUG`。\n- -D后面跟`key=value`表示定义`key`这个宏，它的内容是`value`，如`gcc -DNAME=Peter`。\n\n## 汇编  \n- 输入：中间文件*.i  \n- 输出：编译后生成汇编编语言文件*.s  \n- 这个阶段对应的gcc命令如下：  \n`gcc -S(汇编) test.i -o test.s（汇编编语言文件）`\n- 说明：它通过对源文件test.c使用S选项来生成汇编文件test.s\n### 反汇编\n*`objdump`命令，反汇编*  \n`objdump`命令是Linux下的反汇编目标文件或者可执行文件的命令，它以一种可阅读的格式让你更多地了解二进制文件可能带有的附加信息。  \n- 反汇编应用程序，`objdump -d main.o`  \n- 显示文件头信息，`objdump -f main.o`  \n- 显示制定section段信息(comment段)，`objdump -s -j .comment main.o`  \n\n## 编译  \n- 输入文件：汇编文件*.s  \n- 输出文件：二进制机器代码*.o  \n- 这个阶段对应的gcc命令如下：  \n`gcc -c（编译） test.s -o test.o`\n\n> ### *`gcc -c`命令*  \n> 在功能上，预处理、编译、汇编是3个不同的阶段  \n> 但gcc在实际操作时可以把这3个步骤合并为一个步骤来执行,即使用 -c选项  \n- 输入文件：源码*.c文件  \n- 输出文件：二进制机器代码*.o  \n- 这个阶段对应的gcc命令如下：  \n    `gcc –c test.c -o test.o`  \n    - -o指定了output_filename  \n- 或 ：`gcc -c test.c`  \n    - 省略-o output_filename  \n    - 默认输出为test.o  \n    - 与源文件同名，后缀为.o  \n\n## 链接  \n- 输入文件：二进制机器码*.o文件  \n- 输出文件：与其它的机器代码和库文件汇集成一个可执行的二进制代码文件（无后缀）  \n- 这个阶段对应的gcc命令如下：  \n`gcc （没有选项符号） test.o example.o -o test`  \n> *可用选项：*  \n> -L 指定库路径  \n> -l （小写的L）指定库名称  \n> -I （大写的i）指定头文件所在路径  \n> -i 指定头文件名称  \n  \n| 选项 | 用法 | 解释 |\n|:------:|:--------:|:-----------------------------------:|\n| -l（大写的i） | -Idirname(没有间隔) | 将名为dirname的目录加入到程序头文件目录列表中，它是在预处理阶段使用的选项，I是指Include |\n| -L | -Ldirname | 将名为dirname的目录加入到程序的库文件搜索目录列表中，它是在链接过程中使用的参数， L是指Link |\n| -l （小写的L） | -lname | 指示编译器，在链接时，装载名为libname.a的函数库，该函数库位于系统预定义的目录或者由-L选项指定的目录下 |\n\n## 简化过程\n上述过程可以简化为：  \n`gcc test.c （源文件） -o test（可执行文件）`  \n注意：与链接的语句差别主要在指令中输入文件的后缀  \n\n> 注：  \n> 1. 库是头文件的实现！  \n> 2. 在编译过程中可以被装载/拷贝的库为静态库（.a后缀）\n\n## 一些常用选项\n\n| 选项 | 功能 |\n|:--:|:---------------------------:|\n| -g |产生调试器gdb所必须的符号信息，要对源代码进行调试，就必须在编译程序时加入这个选项|\n| -O | 对程序进行优化编译、链接，采用这个选项，整个源代码会在编译、链接过程中进行优化处理，这样产生的可执行文件的执行效率较高，但是，编译、链接的速度就相应地要慢一些。|\n| -O2 | 比-O更好的优化编译、链接 |\n| -Wall | 输出所有警告信息 |\n| -w | 关闭所有警告信息 |\n| -save-temps | 输出中间代码 | 输出编译过程中所有的中间代码 |\n| -std | 指定编译版本 | 指定采用什么版本的规范进行编译，如`-std=c89`、`-std=c99` |\n| @ | 指定文件制定编译选项 | 可以使用@然后跟着文件名做编译选项，文件中的内容会连接在后面 |\n\n*更多的命令应该不太常用（？）*\n\n# Makefile\n软件项目中，模块之间的依赖关系一般比较复杂，想要通过一条命令gcc命令完成项目的编译非常困难，并且不利于扩展和维护，这个时候就需要使用Makefile了。\n\n## 语法\n```Makefile\ntarget... : prerequisites ...\n          command\n          ......\n```\n\n解析：\n\n- target：可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）。  \n- prerequisites：生成该target所依赖的文件，可以有多个依赖  \n- command：该target要执行的命令（任意的shell命令）    \n举例：\n![](./C-Cpp学习DAY1/1.webp)\n```Makefile\n# test依赖于libtest.a main.o\ntest: libtest.a main.o\n\tgcc main.o -ltest -L. -o test\n# main.o依赖于main.c\nmain.o:main.c\n\tgcc main.c -c -o main.o\n# libtest.a依赖于test1.o test2.o\nlibtest.a: test1.o test2.o\n\tar -r libtest.a test1.o test2.o\n# test1.o依赖于test1.c\ntest1.o:test1.c\n\tgcc test1.c -c -o test1.o\n# test2.o依赖于test2.c\ntest2.o:test2.c\n\tgcc test2.c -c -o test2.o\n```\n\n> 解释：  \n> 当要生成目标test时，make工具会从test开始依次寻找依赖关系，由源文件逐步生成目标test。  \n> test依赖于libtest.a和main.o，或者说libtest.a和main.o是生成test的前置条件（ prerequisites），  \n> 如果libtest.a和main.o存在，那么将直接使用命令\"gcc main.o -ltest -L. -o test\"生成test；  \n> 如果libtest.a和main.o不存在，再向下遍历，寻找libtest.a和main.o的前置条件，去生成libtest.a和main.o，  \n> 就这样一直寻找到可以满足的前置条件，逐步生成目标test。  \n> 如果找到最底层，依然无法满足生成条件，那么就会报错“make：*** 没有明确目标并且找不到 makefile。停止”      \n\n*在检查依赖关系时，同时会检查目标与源文件的时间戳，当源文件时间戳更新时，make会更新依赖它的链路上所有目录。*\n\n### 变量与目标\n上面的Makefile中，所有的依赖关系中直接使用文件名称，当新增加文件或者模块时，需要手动去添加新的依赖关系，那么这就比较麻烦，不利于扩展，因此可以使用变量，自动完成新依赖关系添加。  \n观察上面的依赖关系，可以发现所有的.o中间文件都依赖于一个.c源代码文件。那么这里就可以用变量表达.o中间文件和.c源代码文件，并指定它们之间的依赖关系。Makefile中的变量类型基本上就可以直接理解为字符串类型。\n\n```Makefile\nSRC = test1.c test2.c main.c\nOBJ = test1.o test2.o main.o\n\n${OBJ}:${SRC}\n\tgcc -c ${SRC}\n```\n\n更为方便的办法:\n```Makefile\nSRC = $(wildcard *.c)\nOBJ = $(patsubst %.c,%.o,${SRC})\n\n${OBJ}:${SRC}\n\tgcc -c ${SRC}\n```\n这里使用了Makefile中的函数，使用`$(<function> <arguments>)`的形式可以调用函数。  \n\n用模式匹配的形式来描述依赖关系:\n```Makefile\nSRC = $(wildcard *.c)\nOBJ = $(patsubst %.c,%.o,${SRC})\n\n${OBJ}:%.o:%.c\n\tgcc -c $< -o $@\n```\n`${OBJ}:%.o:%.c`表示OBJ变量中符合\"%.o\"模式的文件都依赖于\"%.c\"文件，例如OBJ中的test1.o依赖于test1.c，%在这时就匹配\"test1\"。另外，这里的命令使用了自动化变量:    \n\n| 自动化变量 | 作用 |  \n|:-------:|:--------------------------------------------------------------------------------------:|  \n| \\$@  | 规则的目标文件名(依赖关系中冒号:左边的文件，如果a: b c，那么\\$@指a)  |        \n| \\$%  | 当目标文件是一个静态库文件时，代表静态库的一个成员名。 |       \n| \\$<  | 被依赖文件的第一项(如果a: b c，那么\\$<指b) |  \n| \\$?  | 所有比目标文件更新的依赖文件列表，空格分隔 |  \n| \\$^  | 所有依赖文件列表，使用空格分隔(如果a: b c c，那么\\$^指b c)，不包含重复文件 |  \n| \\$+  | 所有依赖文件列表，使用空格分隔(如果a: b c c，那么\\$+指b c c)，包含重复文件 |  \n| \\$*  | 在模式规则和静态模式规则中的\"%\"所匹配的内容 |  \n\n### 伪目标\n```Makefile\n.PHONY : clean\nclean:\n\trm *.o *.a test\n```\n> 这里定义了一个clean目标，它没有依赖。当执行`make clean`命令时，会删除所有的.o、.a文件和test文件，这样就可以利用Makefile来清除生成的文件。这里make clean并不是为了生成一个名称为clean的文件，为了防止文件同名，可以用.PHONY来声明伪目标。  \n也可以利用伪目标来一次生成多个目标文件:\n\n```Makefile\n.PHONY : all clean\nall: ${Target1} ${Target2} ${Target3} ...\n\n${Target1}: ....\n\t......\n\n${Target2}: ....\n\t......\n\n${Target3}: ....\n\t......\n\n......\n\nclean:\n\trm ${Target1} ${Target2} ${Target3} ...\n```\n\n### 四种等号\n1. `?=`  \n\"?=\"表示，如果左边的变量没有被赋值，那么将等号右边的值赋给左边的变量。下面的例子中，如果VAR_A被赋过值了，VAR_A中的值将保持原来的值不变，否则其值变为123。\n\n```Makefile\nVAR_A ?= 123\n```\n2. `+=`  \n\"+=\"表示将等号右边的值追加到左边变量中，类似于C语言中的strcat函数。下面的例子中，VAR_B的最终值为123 456(中间有空格)。\n\n```Makefile\nVAR_B = 123\nVAR_B += 456\n```\n3. `=`与`:=`  \n- \"=\"与\":=\"是比较不好区分的两个等号，可以将\"=\"理解为\"址传递\"或引用，\":=\"理解为\"值传递\"。使用\"=\"赋值时，会将整个Makefile展开后再解释被赋值的变量内容，\"VAR_A = ${VAR_B}\"，当后面VAR_B的值发生改变时VAR_A的值会跟着进行变化；  \n- 使用\":=\"赋值时，被赋值的变量的值为此时等号右侧语句表示的值，\"VAR_A := ${VAR_B}\"，如果此时VAR_B的值是123，那么VAR_A的值也为123，后面VAR_B的值被修改了，VAR_A的值依旧为123。\n\n*在Makefile中是不允许将变量自己的值赋给自己的，Makefile不允许出现循环引用。*\n```Makefile\nvar_a := ${var_a} 1 2 3 # 允许\nvar_a = ${var_a} 1 2 3 # 不允许\n```\n\n### 环境变量\nMakefile的执行是受shell环境变量影响的，shell环境变量会直接传递到Makefile的执行过程中。\n\n例如，针对语句`VAR_A ?= yes`，如果在shell中设置过环境变量`export VAR_A=no`，那么在执行make命令时VAR_A的值会是no，而不是yes。另外可以在执行make命令时为传递变量的值，如果执行`make VAR_A=maybe`命令，那么执行过程中VAR_A是maybe。  \n利用这个特性，可以在Shell中设置环境变量来影响Makefile的执行过程。同样可以在Makefile中通过修改PATH等变量的值，来解决找不命令的问题。\n\n### 变量的嵌套使用\nMakefile允许变量的嵌套使用，下面的例子中`\\${var_a}`会解释为`b`，`var_\\${var_a}`变成`var_b`，`${var_${var_a}}`的值就变成了`123`。\n```Makefile\nvar_a = b\nvar_b = 123\nvar_c = ${var_${var_a}}\nvar_c:\n\techo ${var_c}\n# 执行make var_c结果\necho 123\n123\n```\n\n### 条件判断\n```Makefile\nifeq (${DEBUG_BUILD},\"yes\")\nCFLAGS += -ggdb -ggdb3 -gdwarf-2 -D_DEBUG_=1 -g\nelse\nCFLAGS += -O3 -DNDEBUG\nendif\n```\n\n### @\n在执行make命令时，会打印Makefile里面执行的command，有时候Command过长，不容易查看编译过程中出现的错误与警告，可以通过在command前加上@来取消打印command。\n```Makefile\nvar_a = 123\nvar_a:\n\techo ${var_a}\n-----------------------------\n# 执行make var_a输出\necho 123\n123\n##############################\nvar_a = 123\nvar_a:\n\t@echo ${var_a}\n------------------------------\n# 执行make var_a输出\n123\n```\n\n### \\-\n生成target的过程中，可能需要执行多条命令，执行过程中也可能出现错误， 一般出现错误后，make命令会立即退出，停止编译。如果想要忽略执行过程中的错误，可以在command前加上-来忽略这条命令的执行错误。\n```Makefile\nvar_a = 123\nvar_a:\n\t@ls dir1\n\t@echo ${var_a}\n----------------------------------------------\n# 执行make var_a输出\nls: 无法访问 'dir1': 没有那个文件或目录\nmake: [Makefile:19：var_a] 错误 2\n##############################################\nvar_a = 123\nvar_a:\n\t-@ls dir1\n\t@echo ${var_a}\n----------------------------------------------\n# 执行make var_a输出\nls: 无法访问 'dir1': 没有那个文件或目录\nmake: [Makefile:19：var_a] 错误 2 (已忽略）\n123\n```\n\n### make命令参数\n当直接运行make命令，后面不接target参数时，默认会生成Makefile中的第一个目标。如果要生成指定目标，需要在make命令后面接target名称。\n`make <target> VAR_A=<var_a> -j<num>`表示同时产生<num>个进程编译<target>，同时设置Makefile中变量VAR_A的值为var_a。如果-j后面不接数字参数，将会为每个目标文件产生一个进程进行编译，如果工程是源文件过多，可能导致进程数量过多而使计算机没有响应，所以直接使用-j参数而后面不接数字是一个不好的操作。\n\n`make -C /build/path -f make1.mak`表示在开始编译前，先将当前目录切换到/build/path路径下，再执行编译，相当于`cd /build/path && make -f make1.mak`。-f参数用于指定要使用的Makefile文件，如果不使用-f参数，则默认使用当前目录下的名称为\"Makefile\"的文件。注意，这里的make1.mak文件是存放在/build/path目录下的。\n\n## 简单Makefile模板\n```Makefile\n###################################################################################################\n# 编译工具链设置\nPATH := ${PATH}:/your/tool_chain/path\nTOOL_CHAIN = \nCC = ${TOOL_CHAIN}gcc\nAR = ${TOOL_CHAIN}ar\n\nDEBUG_BUILD ?= yes\n\n# SHOW_COMMAND=yes，显示编译命令\nifeq (${SHOW_COMMAND}, yes)\nQUIET :=\nelse\nQUIET := @\nendif\n\n###################################################################################################\n# 目录设置\n# 工程根路径\nPROJ_ROOT = $(abspath ../..)\n# 中间文件缓存文件夹\nTMP_PATH = $(abspath .)/tmp\n# 当前路径\nPWD_PATH = $(abspath .)\n\n###################################################################################################\n# 源文件.c\nSRC := ${PROJ_ROOT}/module1/*.c\nSRC += ${PROJ_ROOT}/module2/*.c\n# 展开*匹配，获取所有源文件完整路径\nSRC := $(wildcard ${SRC})\n\n###################################################################################################\n# 头文件路径设置\nINCLUDE_PATH += /include/path1\nINCLUDE_PATH += /include/path2\nINCLUDE_PATH += ${PROJ_ROOT}/include/path1\nINCLUDE_PATH += ${PROJ_ROOT}/include/path2\n\n###################################################################################################\n# 编译宏设定\nDEFINE_SETTINGS := LINUX\nDEFINE_SETTINGS += A72=\"A72\"\nDEFINE_SETTINGS += TARGET_NUM_CORES=1\nDEFINE_SETTINGS += TARGET_ARCH=64\nDEFINE_SETTINGS += ARCH_64\nDEFINE_SETTINGS += ARM\n\n###################################################################################################\n# 库路径设置\n# 静态库.a文件夹路径\nSTATIC_LIB_PATH := ${PROJ_ROOT}/moduleXXX1/lib\nSTATIC_LIB_PATH += ${PROJ_ROOT}/moduleXXX2/lib\n# 动态库.so文件夹路径\nDYNAMIC_LIB_PATH := ${PROJ_ROOT}/moduleXXX3/lib\n\n###################################################################################################\n# 库设置(静态库)\nSTATIC_LIB += static_lib1\nSTATIC_LIB += static_lib2\nSTATIC_LIB += static_lib3\nSTATIC_LIB += static_lib4\n# 库设置(动态库)\nDYNAMIC_LIB := stdc++\nDYNAMIC_LIB += m\nDYNAMIC_LIB += rt\nDYNAMIC_LIB += pthread\n\n###################################################################################################\n# 编译选项\nCFLAGS := -fPIC -Wall -fms-extensions -Wno-write-strings -Wno-format-security\nCFLAGS += -fno-short-enums -Werror\nCFLAGS += -mlittle-endian  -Wno-format-truncation\nifeq (\"${DEBUG_BUILD}\",\"yes\")\nCFLAGS += -ggdb -ggdb3 -gdwarf-2 -D_DEBUG_=1 -g\nelse\nCFLAGS += -O3 -DNDEBUG\nendif\n\n###################################################################################################\n# 生成的中间文件.o\nOBJ := $(patsubst ${PROJ_ROOT}/%.c,${TMP_PATH}/%.o,${SRC})\n# 头文件存放路径设置\nINC := $(foreach path,${INCLUDE_PATH},-I${path})\n# 编译宏设置\nDEF := $(foreach macro,${DEFINE_SETTINGS},-D${macro})\n# 库设置\nLIB := -rdynamic -Wl,--cref\nLIB += $(foreach path,${DYNAMIC_LIB_PATH},\"-Wl,-rpath-link=${path}\")\nLIB += $(foreach path,${STATIC_LIB_PATH},-L${path})\nLIB += -Wl,-Bstatic -Wl,--start-group\nLIB += $(foreach lib,${STATIC_LIB},-l${lib})\nLIB += -Wl,--end-group\nLIB += -Wl,-Bdynamic\nLIB += $(foreach lib,${DYNAMIC_LIB},-l${lib})\n\n# 生成目标\nTARGET := ${PWD_PATH}/demo/demo\n# 生成目标中的详细符号信息文件\nDEP_FILE := -Wl,-Map=${TMP_PATH}/$(notdir ${TARGET}).dep\n\n.PHONY: all clean\nall: ${TARGET}\n\n${TARGET}:${OBJ}\n\t@echo \"[Linking $@]\"\n\t${QUIET}${CC} ${OBJ} ${CFLAGS} ${LIB} -o $@ ${DEP_FILE} >/dev/null\n\n${TMP_PATH}/%.o:${PROJ_ROOT}/%.c\n\t@echo \"[Compiling $@]\"\n\t@mkdir $(dir $@) -p\n\t${QUIET}${CC} -c $< -o $@ ${CFLAGS} ${DEF} ${INC} -MMD -MF $(patsubst %.o,%.dep,$@) -MT '$@'\n\nclean:\n\t@echo \"[cleaning ${TARGET}]\"\n\t${QUIET}rm -rf ${TARGET}\n\t${QUIET}rm -rf ${TMP_PATH}\n```\n\n# 参考资料\n- [CSDN](https://blog.csdn.net/weixin_47826078/article/details/120474122)  \n- [知乎](https://zhuanlan.zhihu.com/p/430029724#:~:text=%E6%9C%AC%E6%96%87%E5%B0%86%E8%AE%B2%E8%BF%B0%E5%A6%82%E4%BD%95%E4%BB%8E%E9%9B%B6%E5%BC%80)\n- [GitCode](https://gitcode.csdn.net/662b4a23c46af926427792b9.html?dp_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6MjYwOTgzNywiZXhwIjoxNzI3NDU0NDMzLCJpYXQiOjE3MjY4NDk2MzMsInVzZXJuYW1lIjoicXFfNzA3NTA1MjIifQ.QcN-Z_VFw6c6jxclvsfaCAlmysbL72GS_QP41sjp0Ic&spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7Ebaidujs_baidulandingword%7Eactivity-4-121261526-blog-120474122.235%5Ev43%5Epc_blog_bottom_relevance_base2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7Ebaidujs_baidulandingword%7Eactivity-4-121261526-blog-120474122.235%5Ev43%5Epc_blog_bottom_relevance_base2&utm_relevant_index=9)\n\n","categories":["C&C++","Linux"]},{"title":"中缀表达式","url":"/2024/09/06/中缀表达式/","content":"\n# 三种表达式\n对表达式的记法，因此也被称为前缀记法、中缀记法和后缀记法。它们之间的区别在于运算符相对与操作数的位置不同：前缀表达式的运算符位于与其相关的操作数之前；中缀和后缀同理。\n\n> 举例：\n> (3 + 4) × 5 - 6 就是中缀表达式   \n> × + 3 4 5 6 前缀表达式   \n> 3 4 + 5 × 6 - 后缀表达式  \n\n# 中缀表达式转后缀表达式\n## 转换步骤\n1. 定义优先级\n   `(` < `+`、`-` < `*`、`\\\\` < `)` \n2. 对中缀表达式从左往右遍历\n   1. 如果遇到数字，直接添加到后缀表达式末尾；\n   2. 如果遇到运算符`+`、`-`、`*`、`\\\\`\n      先判断栈是否为空。若是，则直接将此运算符压入栈。若不是，则查看当前栈顶元素。若栈顶元素优先级大于或等于此操作符级别，则弹出栈顶元素，将栈顶元素添加到后缀表达式中，并继续进行上述判断。如果不满足上述判断或者栈为空，将这个运算符入栈。要注意的是，经过上述步骤，这个运算符最终一定会入栈。\n   3. 如果遇到括号\n      如果是左括号，直接入栈。如果是右括号，弹出栈中第一个左括号前所有的操作符，并将左括号弹出。（右括号别入栈）。\n   4. 字符串遍历结束后\n      如果栈不为空，则弹出栈中所有元素，将它们添加到后缀表达式的末尾，直到栈为空。\n\n## 代码实现\n\n```c++\nstring infixConvertToPostfix(string str){\n    stack<char> stk;\n    int n=str.size();\n    string res=\"\";\n    char c=0;\n    char top=0;\n    for(int i=0;i<n;i++){\n        c=str[i];\n        if(c==' ') continue;\n        if(c>='0'&&c<='9'){\n            res.push_back(c);\n        }else if(c== '+' || c== '-' || c == '*' || c == '/'){\n            if(stk.empty()){\n                stk.push(c);\n            }else{\n                while(!stk.empty()){\n                    top=stk.top();\n                    if(getPriority(top)>=getPriority(c)){\n                        res.push_back(top);\n                        stk.pop();\n                    }else break;\n                }\n                stk.push(c);\n            }\n        }else{\n            if(c=='(') stk.push(c);\n            else{\n                while (stk.top()!='(')\n                {\n                    res.push_back(stk.top());\n                    stk.pop();\n                }\n                stk.pop();\n            }\n        }\n    }\n    //遍历完后，若栈非空，弹出所有元素  \n    while(!stk.empty()){\n        res.push_back(stk.top());\n        stk.pop();\n    }\n    return res;\n}\n```\n# 后缀表达式的计算\n## 步骤\n准备一个数字栈。从左到右扫描后缀表达式，如果是数字，放入数字栈。如果是符号，从数字栈中弹出两个数字，第一个取出的数字为右运算数，第二个为左运算数，进行运算。然后将结果放进数字栈中。如此反复，直到读完整个表达式后，留在数字栈中的那个数字就是最终结果。\n\n## 代码实现\n```c++\nint calculatByInfix(string str){\n    stack<int> stk;\n    int n=str.size();\n    int num1, num2, num3;  \n    char c=0;\n    for (int i = 0; i < n; i++) {  \n        c=str[i];\n        if (c >= '0' && c <= '9') {  \n            stk.push(c - '0');  \n        }  \n        else {  \n            num2 = stk.top();  \n            stk.pop();  \n            num1 = stk.top();  \n            stk.pop();  \n            if (c == '+') {  \n                num3 = num1 + num2;  \n            }  \n            else if (c == '-') {  \n                num3 = num1 - num2;  \n            }  \n            else if (c == '*') {  \n                num3 = num1 * num2;  \n            }  \n            else if (c == '/') {  \n                num3 = num1 / num2;  \n            }  \n            stk.push(num3);  \n        }  \n    }  \n    return stk.top();  \n}\n```\n\n# 中缀表达式的计算\n## 步骤\n将前面的两步结合起来，就可以得到直接计算的方法。\n准备一个数字栈和一个符号栈，从左到右遍历中缀表达式。如果遇到数字，入数字栈。\n如果遇到符号（四个运算符以及括号），跟前面的“中缀表达式转后缀表达式”过程一样，对符号栈进行处理。处理过程中，对每一个出栈的运算符：+ - * /，根据“计算后缀表达式”的方法，计算结果（跟数字栈配合）。\n如果遍历完中缀表达式后符号栈还非空，就继续出符号栈的运算符，计算，直到符号栈为空。最后数字栈剩下的数字就是结果。\n\n## 代码实现\n```c++\nint getPriority(char ch)  \n{  \n    //获取优先级  \n    if (ch == '(') return 1;  \n    else if (ch == '+' || ch == '-') return 2;  \n    else if (ch == '*' || ch == '/') return 3;  \n    else return 4;  \n}  \n  \nvoid calculate(stack<double> &stk, char operation)  \n{  \n    double num1, num2, num3;  \n    num2 = stk.top();  \n    stk.pop();  \n    num1 = stk.top();  \n    stk.pop();  \n    if (operation == '+') {  \n        num3 = num1 + num2;  \n    }  \n    else if (operation == '-') {  \n        num3 = num1 - num2;  \n    }  \n    else if (operation == '*') {  \n        num3 = num1 * num2;  \n    }  \n    else if (operation == '/') {  \n        num3 = num1 / num2;  \n    }  \n  \n    stk.push(num3);  \n}  \n  \ndouble calculator(string str)  \n{  \n    //计算中缀表达式,默认输入是合法的  \n    stack<double> stk_number;  \n    stack<char> stk_operation;  \n    int i = 0, j;  \n    int size = str.size();  \n    char tmp_operation;  \n    string tmp_num;  \n    while (i < size) {  \n        if (str[i] >= '0' && str[i] <= '9') {  \n            j = i;  \n            while (j < size && str[j] >= '0' && str[j] <= '9') { j++; }  \n            tmp_num = str.substr(i, j - i);  \n            stk_number.push(atoi(tmp_num.c_str()));  \n            i = j;  \n        }  \n        else if (str[i] == '+' || str[i] == '-' || str[i] == '*' || str[i] == '/') {  \n            if (stk_operation.empty()) {  \n                stk_operation.push(str[i]);  \n            }  \n            else {  \n                while (!stk_operation.empty()) {  \n                    tmp_operation = stk_operation.top();  \n                    if (getPriority(tmp_operation) >= getPriority(str[i])) {  \n                        //计算  \n                        calculate(stk_number, tmp_operation);  \n                        stk_operation.pop();  \n                    }  \n                    else break;  \n                }  \n                stk_operation.push(str[i]);  \n            }  \n            i++;  \n        }  \n        else {  \n            if (str[i] == '(') stk_operation.push(str[i]);  \n            else {  \n                while (stk_operation.top() != '(') {  \n                    tmp_operation = stk_operation.top();  \n                    //计算  \n                    calculate(stk_number, tmp_operation);  \n                    stk_operation.pop();  \n                }  \n                stk_operation.pop();  \n            }  \n            i++;  \n        }  \n  \n    }  \n    //遍历完后，若栈非空，弹出所有元素  \n    while (!stk_operation.empty()) {  \n        tmp_operation = stk_operation.top();  \n        //计算  \n        calculate(stk_number, tmp_operation);  \n        stk_operation.pop();  \n    }  \n    return stk_number.top();  \n}  \n```\n\n*代码默认中缀表达式中所有数字都是整数，并且都在0到9之间*\n\n# 参考\n[CSDN](https://blog.csdn.net/sinat_27908213/article/details/80273557)","categories":["算法"]},{"title":"算法刷题记录DAY9","url":"/2024/09/06/算法刷题记录DAY9/","content":"\n# 解数独\n\n<p>编写一个程序，通过填充空格来解决数独问题。</p>\n\n<p>数独的解法需<strong> 遵循如下规则</strong>：</p>\n\n<ol> \n <li>数字&nbsp;<code>1-9</code>&nbsp;在每一行只能出现一次。</li> \n <li>数字&nbsp;<code>1-9</code>&nbsp;在每一列只能出现一次。</li> \n <li>数字&nbsp;<code>1-9</code>&nbsp;在每一个以粗实线分隔的&nbsp;<code>3x3</code>&nbsp;宫内只能出现一次。（请参考示例图）</li> \n</ol>\n\n<p>数独部分空格内已填入了数字，空白格用&nbsp;<code>'.'</code>&nbsp;表示。</p>\n\n<p>&nbsp;</p>\n\n<div class=\"top-view__1vxA\"> \n <div class=\"original__bRMd\"> \n  <div> \n   <p><strong>示例 1：</strong></p> \n   <img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png\" style=\"height:250px; width:250px\" /> \n   <pre>\n<strong>输入：</strong>board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n<strong>输出：</strong>[[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\n<strong>解释：</strong>输入的数独如上图所示，唯一有效的解决方案如下所示：\n</pre>\n  </div>\n </div>\n</div>\n<img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714_solutionsvg.png\" style=\"height:250px; width:250px\" />\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul> \n <li><code>board.length == 9</code></li> \n <li><code>board[i].length == 9</code></li> \n <li><code>board[i][j]</code> 是一位数字或者 <code>'.'</code></li> \n <li>题目数据 <strong>保证</strong> 输入数独仅有一个解</li> \n</ul>\n\n<div><div>Related Topics</div><div><li>数组</li><li>哈希表</li><li>回溯</li><li>矩阵</li></div></div><br><div><li>👍 1855</li><li>👎 0</li></div>\n\n> 思路：dfs,扫到结果就结束了，不要继续回溯\n\n```cpp\nclass Solution\n{\npublic:\n    void solveSudoku(vector<vector<char>> &board)\n    {\n        dfs(board, 0);\n    }\n\nprivate:\n    bool dfs(vector<vector<char>> &board, int index)\n    {\n        if (index > 80)\n        {\n            return true;\n        }\n        int x = index / 9;\n        int y = index % 9;\n        if (board[x][y] != '.')\n        {\n            return dfs(board, index + 1);\n        }\n        else\n        {\n            bool b = false;\n            for (char i = '1'; i <= '9'; i++)\n            {\n                // 验证i能不能填这里\n                bool flag = true;\n                for (int k = 0; k < 9; k++)\n                {\n                    if (board[x][k] == i || board[k][y] == i)\n                    {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag)\n                {\n                    int posx = x / 3;\n                    int posy = y / 3;\n                    for (int j = 0; j < 3; j++)\n                    {\n                        for (int k = 0; k < 3; k++)\n                        {\n                            if (board[posx * 3 + j][posy * 3 + k] == i)\n                            {\n                                flag = false;\n                                break;\n                            }\n                        }\n                    }\n                }\n                if (flag)\n                {\n                    b = true;\n                    board[x][y] = i;\n                    if (!dfs(board, index + 1))\n                    {\n                        board[x][y] = '.';\n                    }\n                    else\n                    {\n                        return true;\n                    }\n                }\n            }\n            if (!b)\n            {\n                return false;\n            }\n        }\n        return false;\n    }\n};\n```\n\n","categories":["算法","搜索"]},{"title":"算法刷题记录DAY8","url":"/2024/09/05/算法刷题记录DAY8/","content":"\n# 分发饼干\n\n![](./算法刷题记录DAY8/1725540156324.png)\n\n> 先排序，然后让先拿尽量小的饼干满足胃口小的孩子。\n\n```cpp\nclass Solution {\npublic:\n    int findContentChildren(vector<int>& g, vector<int>& s) {\n        int res=0;\n        int n=g.size();\n        sort(g.begin(),g.end());sort(s.begin(),s.end());\n        int index=0;\n        int m=s.size();\n        for(int i=0;i<n;i++){\n            while(index<m&&s[index]<g[i]) index++;\n            if(index<m) {\n                res++;\n                index++;\n            }\n            else break;\n        }\n        return res;\n    }\n};\n```\n\n# 种花问题\n\n![](./算法刷题记录DAY8/1725541202614.png)\n\n> 遇到能种的地方就种，n减到0就返回true\n\n```cpp\nclass Solution {\npublic:\n    bool canPlaceFlowers(vector<int>& flowerbed, int n) {\n        if(n==0) return true;\n        for(int i=0;i<flowerbed.size();i++){\n            if(flowerbed[i]==1){\n                i++;\n            }else{\n                if((i==0||flowerbed[i-1]==0)&&(i==flowerbed.size()-1||flowerbed[i+1]==0)){\n                    flowerbed[i]=1;\n                    n--;\n                    if(n==0) return true;\n                    i++;\n                }\n            }\n\n        }\n        return false;\n    }\n};\n```\n\n# \n\n![](./算法刷题记录DAY8/1725545385062.png)\n\n```cpp\n// 力扣官方题解\nclass Solution {\npublic:\n    bool checkPalindrome(const string& s, int low, int high) {\n        for (int i = low, j = high; i < j; ++i, --j) {\n            if (s[i] != s[j]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    bool validPalindrome(string s) {\n        int low = 0, high = s.size() - 1;\n        while (low < high) {\n            char c1 = s[low], c2 = s[high];\n            if (c1 == c2) {\n                ++low;\n                --high;\n            } else {\n                return checkPalindrome(s, low, high - 1) || checkPalindrome(s, low + 1, high);\n            }\n        }\n        return true;\n    }\n};\n```\n\n# 柠檬水找零\n\n![](./算法刷题记录DAY8/1725545726514.png)\n\n\n```cpp\nclass Solution {\npublic:\n    bool lemonadeChange(vector<int>& bills) {\n        int cnt5=0,cnt10=0,cnt20=0;\n        for(int i=0;i<bills.size();i++){\n            if(bills[i]!=5){\n                if(bills[i]==10){\n                    if(cnt5){\n                        cnt5--;\n                    }else return false;\n                    cnt10++;\n                }else if(bills[i]==20){\n                    if(cnt10>=1&&cnt5>=1) {\n                        cnt10--;\n                        cnt5--;\n                    }else if(cnt5>=3) cnt5-=3;\n                    else return false;\n                    cnt20++;\n                }\n            }else{\n                cnt5++;\n            }\n        }\n        return true;\n    }\n};\n```\n\n# 增减字符串匹配\n\n![](./算法刷题记录DAY8/1725546330480.png)\n\n> 思路：$I$ 就放剩余数字中的最小数，$D$ 就放剩余数字中的最大数。\n\n```cpp\nclass Solution {\npublic:\n    vector<int> diStringMatch(string s) {\n        int n=s.size();\n        int lo=0,hi=n;\n        vector<int> res(n+1,0);\n        for(int i=0;i<n;i++){\n            res[i]=(s[i]=='I'?lo++:hi--);\n        }\n        res[n]=lo;\n        return res;\n    }\n};\n```\n\n# 三角形的最大周长\n\n![](./算法刷题记录DAY8/1725547202126.png)\n\n```cpp\nclass Solution {\npublic:\n    bool isTrangle(int a,int b,int c){\n        return a+b>c&&b+c>a&&a+c>b;\n    }\n    int largestPerimeter(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int res=0;\n        int n=nums.size();\n        for(int i=n-1;i>=2;i--){\n            for(int j=i-1;j>=1;j--){\n                int hi=nums[i]+nums[j]-1;\n                int lo=nums[i]-nums[j]+1;\n                if(nums[j-1]<lo||nums[0]>hi) continue;\n                else{\n                    res=max(res,nums[i]+nums[j]+nums[j-1]);\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n\n# K次取反后最大化的数组和\n\n![](./算法刷题记录DAY8/1725548308296.png)\n\n```cpp\nclass Solution {\npublic:\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\n        int sum=0;\n        vector<int> negative;\n        int min_postive=INT_MAX;\n        for(int i=0;i<nums.size();i++){\n            if(nums[i]<0) negative.push_back(nums[i]);\n            else if(nums[i]<min_postive) min_postive=nums[i];\n            sum+=nums[i];\n        }\n        sort(negative.begin(),negative.end());\n        int index=0;\n        while(k&&index<negative.size()){\n            negative[index]=-negative[index];\n            sum+=2*negative[index];\n            index++;\n            k--;\n        }\n        if(k%2){\n            if(negative.size()>0){\n                min_postive=min(min_postive,negative[negative.size()-1]);\n            }\n            sum-=2*min_postive;\n        }\n        return sum;\n    }\n};\n```\n\n# 将数组分成和相等的三个部分\n\n![](./算法刷题记录DAY8/1725549174475.png)\n\n```cpp\nclass Solution {\npublic:\n    bool canThreePartsEqualSum(vector<int>& arr) {\n        int n=arr.size();\n        int sum=0;\n        for(int i=0;i<n;i++){\n            sum+=arr[i];\n        }   \n        if(sum%3!=0) return false; \n        int left=0;\n        int right=n-1;\n        int s0=0,s1=0;\n        while(left<n){\n            s0+=arr[left];\n            if(s0==sum/3){\n                break;\n            }\n            left++;\n        }\n        while(right>=0){\n            s1+=arr[right];\n            if(s1==sum/3){\n                break;\n            }\n            right--;\n        }\n        return right>left+1;\n    }\n};\n```\n\n# 加油站\n\n<p>在一条环路上有 <code>n</code>&nbsp;个加油站，其中第 <code>i</code>&nbsp;个加油站有汽油&nbsp;<code>gas[i]</code><em>&nbsp;</em>升。</p>\n\n<p>你有一辆油箱容量无限的的汽车，从第<em> </em><code>i</code><em> </em>个加油站开往第<em> </em><code>i+1</code><em>&nbsp;</em>个加油站需要消耗汽油&nbsp;<code>cost[i]</code><em>&nbsp;</em>升。你从其中的一个加油站出发，开始时油箱为空。</p>\n\n<p>给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> gas = [1,2,3,4,5], cost = [3,4,5,1,2]\n<strong>输出:</strong> 3\n<strong>解释:\n</strong>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油\n开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油\n开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油\n开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油\n开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油\n开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。\n因此，3 可为起始索引。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> gas = [2,3,4], cost = [3,4,3]\n<strong>输出:</strong> -1\n<strong>解释:\n</strong>你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。\n我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油\n开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油\n开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油\n你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。\n因此，无论怎样，你都不可能绕环路行驶一周。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul> \n <li><code>gas.length == n</code></li> \n <li><code>cost.length == n</code></li> \n <li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li> \n <li><code>0 &lt;= gas[i], cost[i] &lt;= 10<sup>4</sup></code></li> \n</ul>\n\n<div><div>Related Topics</div><div><li>贪心</li><li>数组</li></div></div><br><div><li>👍 1674</li><li>👎 0</li></div>\n\n> 思路：就是从0开始遍历，在哪个位置出现了油不够，那下一个遍历的位置就从这里之后开始，找到第一个gas大于cost的位置\n> 注意：这里要把begin_index加入set，以此判断有没有重复遍历，有重复了就说明不存在解\n\n```c++\nclass Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int n=gas.size();\n        set<int> st;\n        int begin_index=-1;\n        for(int i=0;i<n;i++){\n            if(gas[i]-cost[i]>=0) {\n                begin_index=i;\n                break;\n            }\n        }\n        if(begin_index==-1) return -1;\n        int bug_index=-1;\n        st.insert(begin_index);\n        while(begin_index<n){\n            int total=gas[begin_index]-cost[begin_index];\n            for(int j=(begin_index+1)%n;j!=begin_index;j=(j+1)%n){\n                total+=(gas[j]-cost[j]);\n                if(total<0) {\n                    bug_index=j;\n                    break;\n                }\n            }\n            if(total>=0) return begin_index;\n            else{\n                int k;\n                for(k=bug_index;;k=(k+1)%n){\n                    if(gas[k]>=cost[k]) {\n                        break;\n                    }\n                }\n                begin_index=k;\n                if(st.count(begin_index)) return -1;\n                else st.insert(begin_index);\n            }\n        }\n        return -1;\n    }\n};\n```\n\n# 不含AAA或BBB的字符串\n\n<p>给定两个整数 <code>a</code>&nbsp;和 <code>b</code>&nbsp;，返回&nbsp;<strong>任意</strong>&nbsp;字符串 <code>s</code>&nbsp;，要求满足：</p>\n\n<ul> \n <li><code>s</code>&nbsp;的长度为 <code>a + b</code>，且正好包含&nbsp;<code>a</code>&nbsp;个 <code>'a'</code>&nbsp;字母与&nbsp;<code>b</code> 个 <code>'b'</code>&nbsp;字母；</li> \n <li>子串&nbsp;<code>'aaa'</code>&nbsp;没有出现在 <code>s</code>&nbsp;中；</li> \n <li>子串&nbsp;<code>'bbb'</code> 没有出现在 <code>s</code>&nbsp;中。</li> \n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 1, b = 2\n<strong>输出：</strong>\"abb\"\n<strong>解释：</strong>\"abb\", \"bab\" 和 \"bba\" 都是正确答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 4, b = 1\n<strong>输出：</strong>\"aabaa\"</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul> \n <li><code>0 &lt;= a, b&nbsp;&lt;= 100</code></li> \n <li>对于给定的 <code>a</code> 和 <code>b</code>，保证存在满足要求的 <code>s</code>&nbsp;</li> \n</ul> \n<span style=\"display:block\"><span style=\"height:0px\"><span style=\"position:absolute\">​​​</span></span></span>\n\n<div><div>Related Topics</div><div><li>贪心</li><li>字符串</li></div></div><br><div><li>👍 94</li><li>👎 0</li></div>\n\n> 思路：先初始化一个全部是数量更大的字符的字符串串，长度为 $a+b$ ，然后用另一个字符去填，该位置满足条件就能填，填完为止\n\n```c++\nclass Solution {\nprivate:\n    bool isOk(string& s, int index, char now, char change) {\n        s[index]=change;\n        int begin=(index>=2?index-2:0);\n        bool flag=(s[begin  ]==change&&s[begin+1]==change&&s[begin+2]==change)||\n                  (s[begin+1]==change&&s[begin+2]==change&&s[begin+3]==change)||\n                  (s[begin+2]==change&&s[begin+3]==change&&s[begin+4]==change);\n        s[index]=now;\n        return !flag;\n    }\n\npublic:\n    string strWithout3a3b(int a, int b) {\n        string res = \"\";\n        char before = 'a';\n        if (a > b)\n            before = 'a';\n        else\n            before = 'b';\n        for (int i = 0; i < a + b; i++)\n            res += before;\n        char after = (before == 'a' ? 'b' : 'a');\n        int cnt = (after == 'a' ? a : b);\n        for (int i = 2; i < a + b && cnt;) {\n            res[i] = after;\n            i += 3;\n            cnt--;\n        }\n        if (cnt) {\n            for (int i = 0; i < a + b && cnt; i++) {\n                if (res[i] == after) {\n                    continue;\n                }\n                if (isOk(res, i, res[i], after)) {\n                    res[i]=after;\n                    cnt--;\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n\n# \n","categories":["算法","贪心"]},{"title":"算法刷题记录DAY7","url":"/2024/09/04/算法刷题记录DAY7/","content":"\n# 删除并获得点数\n\n![](./算法刷题记录DAY7/1725509700859.png)\n\n```cpp\nclass Solution {\npublic:\n    int deleteAndEarn(vector<int>& nums) {\n        int maxx=0;\n        for(int i=0;i<nums.size();i++){\n            if(nums[i]>maxx) maxx=nums[i];\n        }\n        vector<int> arr(maxx+1,0);\n        vector<int> dp(maxx+1);\n        for(int i=0;i<nums.size();i++){\n            arr[nums[i]]++;\n        }\n        cout<<endl;\n        dp[0]=0;\n        dp[1]=arr[1];\n        for(int i=2;i<=maxx;i++){\n            dp[i]=max(dp[i-1],i*arr[i]+dp[i-2]);\n        }\n        return dp[maxx];\n    }\n};\n```\n\n# 三角形最小路径和\n\n![](./算法刷题记录DAY7/1725518563150.png)\n\n```cpp\nclass Solution {\n    public:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        vector<vector<int>> dp(triangle.size(),vector<int>(triangle.size(),0));\n        dp[0][0]=triangle[0][0];\n        for(int i=1;i<triangle.size();i++){\n            for(int j=0;j<=i;j++){\n                if(j==0){\n                    dp[i][j]=dp[i-1][j]+triangle[i][j];\n                }else if(j==i){\n                    dp[i][j]=dp[i-1][j-1]+triangle[i][j];\n                }else{\n                    dp[i][j]=min(dp[i-1][j],dp[i-1][j-1])+triangle[i][j];\n                }\n            }\n        }\n        int res=INT_MAX;\n        for(int i=0;i<triangle.size();i++){\n            cout<<dp[triangle.size()-1][i]<<endl;\n            res=min(res,dp[triangle.size()-1][i]);\n        }\n        return res;\n    }\n};\n\n```\n\n# 下降路径最小和\n\n![](./算法刷题记录DAY7/1725520304584.png)\n\n```cpp\n#define min_(a,b,c) min(min((a),(b)),(c))\n\nclass Solution {\npublic:\n    int minFallingPathSum(vector<vector<int>>& matrix) {\n        int n=matrix.size();\n        vector<vector<int>> dp(n,vector<int>(n));\n        for(int i=0;i<n;i++) dp[0][i]=matrix[0][i];\n        for(int i=1;i<n;i++){\n            for(int j=0;j<n;j++) { \n                dp[i][j]=min_(j==0?INT_MAX:dp[i-1][j-1],dp[i-1][j],j==n-1?INT_MAX:dp[i-1][j+1])+matrix[i][j];\n            }\n        }\n        int res=INT_MAX;\n        for(int i=0;i<n;i++) res=min(res,dp[n-1][i]);\n        return res;\n    }\n};\n```\n\n# 完全平方数 \n\n![](./算法刷题记录DAY7/1725523032217.png)\n\n```cpp\nclass Solution {\npublic:\n    bool isT(int n){\n        int i= (int)sqrt(n);\n        return i*i==n;\n    }\n    int numSquares(int n) {\n        if(n<4) return n;\n        if(isT(n)) return 1;\n        vector<int> dp(n+1,0);\n        dp[0]=0;\n        dp[1]=1;\n        dp[2]=2;\n        dp[3]=3;\n        for(int i=4;i<=n;i++){\n            if(isT(i)) dp[i]=1;\n            else{\n                int mincnt=INT_MAX;\n                for(int t=1;i-t*t>0;t++){\n                    mincnt=min(dp[i-t*t]+1,mincnt);\n                }\n                dp[i]=mincnt;\n            }\n        }\n        return dp[n];\n    }\n};\n```\n\n# 零钱兑换 II\n\n![](./算法刷题记录DAY7/1725524143689.png)\n\n> 思路：\n> ![](./算法刷题记录DAY7/1725524204542.png)\n\n```cpp\nclass Solution {\npublic:\n    int change(int amount, vector<int>& coins) {\n        vector<int> dp(amount+1,0);\n        dp[0]=1;\n        for(int i=0;i<coins.size();i++){\n            for(int j=coins[i];j<=amount;j++){\n                dp[j]+=dp[j-coins[i]];\n            }\n        }\n        return dp[amount];\n    }\n};\n```\n\n# 组合总和 IV\n\n![](./算法刷题记录DAY7/1725525116192.png)\n\n```cpp\n// 一定要开ull\ntypedef unsigned long long ull;\nclass Solution {\npublic:\n    int combinationSum4(vector<int>& nums, int target) {\n        vector<ull> dp(target+1,0);\n        dp[0]=1;\n        for(int i=1;i<=target;i++){\n            for(int j=0;j<nums.size();j++){\n                if(i-nums[j]>=0) dp[i]+=dp[i-nums[j]];\n            }\n        }\n        return (int)dp[target];\n    }\n};\n```\n\n","categories":["算法","动态规划"]},{"title":"网络安全复习-第二章","url":"/2024/09/04/网络安全复习-第二章/","content":"\n# 密码学研究的主要目标\n- 机密性\n- 数据完整性\n- 认证(真实性)\n- 不可抵赖(可审计性)\n\n# 对称加密\n发送方和接收方使用相同的密钥\n![](./网络安全复习-第二章/1.png)\n\n# 密码编码学\n如何描述:  \n\n> 1. 加密操作的方法  \n>   替代/转置/乘积  \n> 2. 使用的密钥数  \n>   单密钥或私钥/双密钥或公钥   \n> 3. 明文的处理方式  \n>   块加密/流加密\n\n# 对称加密方法\n## 古典替代密码\n### 凯撒码Caesar\n将每个字母替换为其后的第三个字母。\n凯撒码可以表示为  \n\n> c = E§ = (p + k) mod (26)  \n> p = D© = (c – k) mod (26)\n\n#### 特点分析\n只有26个可能的密码，可以很容易的依次验证——暴力破解\n对于已知密文，只需依次移动字母，当明文产生时需要能够识别\n\n### 单表代替密码\n每个原文字符都可以被映射为一个任意的密文字符\n密码长度为26个字母\n\n#### 单一字母替代码不会改变字母的出现的频率  \n\n> 该特点由阿拉伯科学家于公元9世纪发现  \n> 计算字母出现频率  \n> 将计算值于已知值进行对比  \n\n### Playfair 密码\nPlayfair矩阵:  \n举例：密钥词是monarchy\n![](./网络安全复习-第二章/1725782909198.png)  \n1. 如果该字母对的两个字母是相同的，那么在它们之间加一个填充字母，比如x。例如balloon先把它变成ba Ix lo on这样四个字母对  \n2. 落在矩阵同一行的明文字母对中的字母由其右边的字母来代替，每行中最右边的一个字母就用该列中最左边的第一个字母来代替，比如ar变成RM  \n3. 落在矩阵同一列的明文字母对中的字母由其下面的字母来代替，每行中最下面的一个字母就用该列中最上面的第一个字母来代替，比如mu变成CM。  \n4. 其他的每组明文字母对中的字母按如下方式代替，该字母所在行为密文所在行，另一字母所在列为密文所在列。比如hs变成BP,ea变成IM(或JM)。(对角变对角)  \n\n#### 特点\n\n> 比单一字母替换安全性好  \n> 频率表项增加到了26x26=676  \n> 曾被广泛应用多年（如第一次世界大战）  \n> 提供几百个字母下可破解  \n> 仍能够保留部分明文结构特征\n\n### 多字母密码\n性质：使用一系列相关的单字母替代规律  \n一个密钥决定对一个给定的变换选择那种特定的规则  \n![](./网络安全复习-第二章/2.png)  \n\n### 一次一密One-Time Pad\n采用与明文一样长的随机串为关键词  \n具备很强的安全性，统计学特征被隐藏  \n一次一密  \n密钥的生成与共享是存在的难题  \n没多大用——难以把密钥传过去\n\n## 置换技术\n该方法通过将字符重新排列隐藏信息  \n并不改变使用的字符  \n该方案可以通过原文，密文中字符出现的频率相同进行识别  \n\n### 栅栏技术\n按照对角线顺序写出明文，然后按照行的顺序读取作为密文，例如：用深度为2的栅栏技术加密信息“meet me after the toga party”，可写作:\n\n> m e m a t r h t g p r y  \n> e t e f e t e o a a t    \n\n密文为：$MEMATRHTGPRYETEFETEOAAT$\n\n### 行置换技术\n一个更复杂的方案是：  \n将消息按照特定的列数写成矩阵形式  \n按照密钥值依次读出按照行排列  \n\n*软微没入营，复习nm。。。*","categories":["网络信息安全"]},{"title":"网络安全复习-第一章","url":"/2024/09/03/网络安全复习-第一章/","content":"\n# 关键性的安全概念 **CIAAA**\n- C:机密性，对信息资源访问，，开放的限制比如访问控制，加密等\n- I：完整性。保证信息未被不恰当的更改与破坏。\n- A：可用性。合法的访问能够及时有效地得到实施\n- Authenticity (Authentication)：真实性。鉴别(认证)还有翻译成可控。指特性(身份)等可验证，可信\n- Accountability：可审计性。可说明性指实体行为前唯一性的追踪我们书上的描述是不可否认性(non-repudication)\n\n# 安全攻击\n- 被动攻击：被动攻击从本质上是在传输中的偷听或监视，其目的是从传输中获得信息。可分为以下两种：\n> 1、析出消息release of message contens：知道消息内容。\n> \n> 2、通信量分析traffic analysis：不知道具体的消息，但是可以通过消息发送的量来攻击。该方法比较难检测，应对方法是防止而不是检测。——通信量填充来解决 \n![](./网络安全复习-第一章/1.png)\n\n- 主动攻击：主动攻击涉及某些数据流的篡改或一个虚假流的产生可进一步划分为：伪装，重放，篡改消息和拒绝服务。分类：\n> 1. 伪装就是一个实体假装为另一个实体\n>\n> 2. 重放涉及一个数据单元被动获取及后继的重传，以产生一个未授权的效果\n>\n> 3. 消息篡改意味着、一个合法消息的部分被改变，或消息被延迟或改变次序，以产生一个未授权的效果\n>\n> 4. 拒绝服务防止或禁止通信设施的正常使用或管理：Ddos\n>\n> ![](./网络安全复习-第一章/2.png)\n\n# 安全服务\n> CIAAA+访问控制\n> 访问控制：在网络环境中，访问控制是限制和控制经通信链路对主机系统和应用程序进行访问的能力\n\n**越往上定制性越好，越往下透明性越好**\n\n# 安全机制\n\n**密码学是许多安全机制的基础**\n\n1. 特定的安全机制：加密，签名，完整性检验，认证，流量填充等\n> 针对特定攻击方式\n2. 被动的安全机制：信任机制，安全级别，事件检测，安全追踪，安全恢复\n> 不针对某个特定的威胁","categories":["网络信息安全"]},{"title":"算法刷题记录DAY6","url":"/2024/09/02/算法刷题记录DAY6/","content":"\n# [NOIP2002 普及组] 过河卒\n\n## 题目描述\n\n棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。\n\n棋盘用坐标表示，$A$ 点 $(0, 0)$、$B$ 点 $(n, m)$，同样马的位置坐标是需要给出的。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ipmwl52i.png)\n\n现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。\n\n## 输入格式\n\n一行四个正整数，分别表示 $B$ 点坐标和马的坐标。\n\n## 输出格式\n\n一个整数，表示所有的路径条数。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n6 6 3 3\n```\n\n### 样例输出 #1\n\n```\n6\n```\n\n## 提示\n\n对于 $100 \\%$ 的数据，$1 \\le n, m \\le 20$，$0 \\le$ 马的坐标 $\\le 20$。\n\n**【题目来源】**\n\nNOIP 2002 普及组第四题\n\n## 代码\n\n> dp即可，得开long long才能过。\n\n```cpp\n#include<iostream>\n#include<vector>\ntypedef long long ll;\nusing namespace std;\nconst int MAX_N=20,MAX_M=20;\n\nll dp[MAX_N+1][MAX_M+1];\nint n,m;\nint x,y;\nbool checkIsControl(int r,int c){\n  if((r==x&&c==y)||((r-x)*(r-x)+(c-y)*(c-y)==5)) {\n    return true;\n    }\n  return false;\n}\nint main(){\n  cin>>n>>m;\n  cin>>x>>y;\n  dp[0][0]=1;\n  for(int i=0;i<=n;i++){\n    for(int j=0;j<=m;j++){\n      if(i==0&&j==0) continue;\n      if(checkIsControl(i,j)) dp[i][j]=0;\n      else dp[i][j]=((i==0?0:dp[i-1][j])+(j==0?0:dp[i][j-1]));\n    }\n  }\n  cout<<dp[n][m];\n  return 0;\n}\n```\n\n# [NOIP2011 提高组] 铺地毯\n\n## 题目描述\n\n为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。\n\n地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。\n\n## 输入格式\n\n输入共 $n + 2$ 行。\n\n第一行，一个整数 $n$，表示总共有 $n$ 张地毯。\n\n接下来的 $n$ 行中，第 $i+1$ 行表示编号 $i$ 的地毯的信息，包含四个整数 $a ,b ,g ,k$，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标 $(a, b)$ 以及地毯在 $x$ 轴和 $y$ 轴方向的长度。\n\n第 $n + 2$ 行包含两个整数 $x$ 和 $y$，表示所求的地面的点的坐标 $(x, y)$。\n\n## 输出格式\n\n输出共 $1$ 行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出 `-1`。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n3\n1 0 2 3\n0 2 3 3\n2 1 3 3\n2 2\n```\n\n### 样例输出 #1\n\n```\n3\n```\n\n## 样例 #2\n\n### 样例输入 #2\n\n```\n3\n1 0 2 3\n0 2 3 3\n2 1 3 3\n4 5\n```\n\n### 样例输出 #2\n\n```\n-1\n```\n\n## 提示\n\n【样例解释 1】\n\n如下图，$1$ 号地毯用实线表示，$2$ 号地毯用虚线表示，$3$ 号用双实线表示，覆盖点 $(2,2)$ 的最上面一张地毯是 $3$ 号地毯。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q4izfzpb.png)\n\n【数据范围】\n\n对于 $30\\%$ 的数据，有 $n \\le 2$。  \n对于 $50\\%$ 的数据，$0 \\le a, b, g, k \\le 100$。  \n对于 $100\\%$ 的数据，有 $0 \\le n \\le 10^4$, $0 \\le a, b, g, k \\le {10}^5$。   \n\nnoip2011 提高组 day1 第 $1$ 题。\n\n## 代码\n\n> 暴力\n\n```cpp\n#include<iostream>\n#include<vector>\nusing namespace std;\nconst int MAX_N=10000;\nint a[MAX_N+1],b[MAX_N+1],g[MAX_N+1],k[MAX_N+1];\nint n;\nint main(){\n  cin>>n;\n  int res=-1;\n  for(int i=0;i<n;i++){\n    cin>>a[i]>>b[i]>>g[i]>>k[i];\n  }\n  int x,y;\n  cin>>x>>y;\n  for(int i=0;i<n;i++){\n    if(x>=a[i]&&y>=b[i]&&a[i]+g[i]>=x&&b[i]+k[i]>=y) res=i+1;\n  }\n  cout<<res<<endl;\n  return 0;\n}\n```\n\n# 魔族密码\n\n## 题目背景\n\n风之子刚走进他的考场，就……\n\n花花：当当当当~~偶是魅力女皇——花花！！^^（华丽出场，礼炮，鲜花）\n\n风之子：我呕……（杀死人的眼神）快说题目！否则……-\\_-###\n\n## 题目描述\n\n花花：……咦~~好冷~~我们现在要解决的是魔族的密码问题（自我陶醉：搞不好魔族里面还会有人用密码给我和菜虫写情书咧，哦活活，当然是给我的比较多拉\\*^\\_^\\*）。\n\n魔族现在使用一种新型的密码系统。每一个密码都是一个给定的仅包含小写字母的英文单词表，每个单词至少包含 $1$ 个字母，至多 $75$ 个字母。如果在一个由一个词或多个词组成的表中，除了最后一个以外，每个单词都被其后的一个单词所包含，即前一个单词是后一个单词的前缀，则称词表为一个词链。例如下面单词组成了一个词链：\n\n- $\\verb!i!$；\n- $\\verb!int!$；\n- $\\verb!integer!$。\n\n但下面的单词不组成词链：\n\n- $\\verb!integer!$；\n- $\\verb!intern!$。\n\n现在你要做的就是在一个给定的单词表中取出一些词，组成最长的词链，就是包含单词数最多的词链。将它的单词数统计出来，就得到密码了。\n\n风之子：密码就是最长词链所包括的单词数阿……\n\n## 输入格式\n\n这些文件的格式是，第一行为单词表中的单词数 $N$（$1 \\le N \\le 2000$），下面每一行有一个单词，按字典顺序排列，中间也没有重复的单词。\n\n## 输出格式\n\n输出共一行，一个整数，表示密码。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n5\ni\nint\ninteger\nintern\ninternet\n```\n\n### 样例输出 #1\n\n```\n4\n```\n\n## 代码\n\n> 构建字典树\n\n```cpp\n#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nstruct TrirNode\n{\n    bool isWord;\n    vector<TrirNode*> children;\n    TrirNode(): children(26) ,isWord(false) {}\n}*trie;\n\nvoid createTrie(){\n    trie=new TrirNode();\n}\n\nvoid insertHelper(string& word,int index,TrirNode* node){\n    if(index==word.size()) return;\n    int i=word[index]-'a';\n    if(node->children[i]==nullptr){\n        node->children[i]=new TrirNode();\n    }\n    if(node->children[i]->isWord==false) node->children[i]->isWord=(index==word.size()-1);\n    insertHelper(word,index+1,node->children[i]);\n}\n\nvoid insert(string& word){\n    if(word.size()==0) return;\n    insertHelper(word,0,trie);\n}\n\nint res=0;\n\nint findHeight(TrirNode* node){\n    if(node==nullptr) return 0;\n    int maxHeight=0;\n    for(int i=0;i<node->children.size();i++){\n        maxHeight=max(maxHeight,findHeight(node->children[i]));\n    }\n    return maxHeight+(node->isWord?1:0);\n}\n\nvoid findMaxHeight(){\n    res=findHeight(trie);\n}\n\nint main(){\n    int n;\n    string word;\n    cin>>n;\n    createTrie();\n    while (n--)\n    {\n        cin>>word;\n        insert(word);\n    }\n    findMaxHeight();\n    cout<<res<<endl;\n    return 0;\n}\n```\n\n# [NOIP1998 普及组] 阶乘之和\n\n## 题目描述\n\n用高精度计算出 $S = 1! + 2! + 3! + \\cdots + n!$（$n \\le 50$）。\n\n其中 `!` 表示阶乘，定义为 $n!=n\\times (n-1)\\times (n-2)\\times \\cdots \\times 1$。例如，$5! = 5 \\times 4 \\times 3 \\times 2 \\times 1=120$。\n\n## 输入格式\n\n一个正整数 $n$。\n\n## 输出格式\n\n一个正整数 $S$，表示计算结果。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n3\n```\n\n### 样例输出 #1\n\n```\n9\n```\n\n## 提示\n\n**【数据范围】**\n\n对于 $100 \\%$ 的数据，$1 \\le n \\le 50$。\n\n**【其他说明】**\n\n注，《深入浅出基础篇》中使用本题作为例题，但是其数据范围只有 $n \\le 20$，使用书中的代码无法通过本题。\n\n如果希望通过本题，请继续学习第八章高精度的知识。\n\nNOIP1998 普及组 第二题\n\n## 代码\n\n```cpp\n// 20以内能过，大了就错\n#include<iostream>\n\ntypedef long long ll;\n\nusing namespace std;\n\nconst int MAX_N=50;\nvector<ll> nums(MAX_N+1,0);\nnums[0]=1;\nnums[1]=1;\nll func(int n){\n  if(n==0||n==1) return 1;\n  if(nums[n-1]==0){\n    nums[n-1]=func(n-1);\n  }\n  nums[n]=nums[n-1]*n;\n  return nums[n];\n}\nint main(){\n  int n;\n  cin>>n;\n  ll s=0;\n  for(int i=1;i<=n;i++){\n    s+=func(i);\n  }\n  cout<<s;\n  return 0;\n}\n\n```\n\n```cpp\n//题解\n#include<iostream>\n#include<cstdio>\nusing namespace std;\nint n,a[101]={0},s[101]={0};\nvoid change(int x)\n{\n\tint g=0;\n\tfor(int i=100;i>=0;i--)\n\t{\n\t\ta[i]=a[i]*x+g;\n\t\tg=a[i]/10;\n\t\ta[i]=a[i]%10;\n\t}\n}\nvoid qh()\n{\n\tint g=0;\n\tfor(int i=100;i>=0;i--)\n\t{\n\t\ts[i]=s[i]+a[i]+g;\n\t\tg=s[i]/10;\n\t\ts[i]=s[i]%10;\n\t}\n}\nvoid sc()\n{\n\tint w;\n\tfor(int i=0;i<=100;i++)\n\t{\n\t\tif(s[i]!=0)\n\t\t{\n\t\t\tw=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=w;i<=100;i++)\n\t   printf(\"%d\",s[i]);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts[100]=a[100]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tchange(i);\n\t\tqh();\n\t}\n\tsc();\n\treturn 0;\n}\n```\n\n\n","categories":["算法"]},{"title":"算法刷题记录DAY5","url":"/2024/08/13/算法刷题记录DAY5/","content":"\n# 最常见的单词\n\n![](./算法刷题记录DAY5/1723534648949.png)\n\n> 思路：暴力，先将paragraph的`\"!?',;.\"`全部改为空格，然后分隔字符串后依次遍历，判断每个字符串是不是在banned中。\n\n```java\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nclass Solution {\n    public String mostCommonWord(String paragraph, String[] banned) {\n        paragraph=paragraph.replace('!',' ').replace('?',' ').replace('\\'',' ')\n                .replace(',',' ').replace(';',' ').replace('.',' ');\n        String[] split = paragraph.split(\" \");\n        String ans=null;\n        int max=0;\n        Map<String,Integer> map=new HashMap();\n        Set<String> set=new HashSet();\n        for (int i = 0; i < banned.length; i++) {\n            set.add(banned[i]);\n        }\n        for (int i = 0; i < split.length; i++) {\n            String str=split[i].trim().toLowerCase();\n            if((!str.equals(\"\"))&&(!set.contains(str))){\n                System.out.println(str);\n                map.put(str,map.getOrDefault(str,0)+1);\n            }\n        }\n        for (Map.Entry<String, Integer> entry : map.entrySet()) {\n            String key = entry.getKey();\n            Integer value = entry.getValue();\n            if (max<value){\n                max=value;\n                ans=key;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n# 设计哈希集合\n\n![](./算法刷题记录DAY5/1723536250704.png)\n\n> 思路，用取模运算作为散列函数，并且使用追加链表解决哈希冲突\n\n```java\nclass MyHashSet {\n    private final int DEFAULT_SIZE=10;\n\n    private Item[] items;\n\n    public MyHashSet() {\n        items=new Item[DEFAULT_SIZE];\n    }\n\n    public void add(int key) {\n        if(contains(key)) return;\n        int index=key%DEFAULT_SIZE;\n        if(items[index]==null){\n            items[index]=new Item();\n            items[index].value=key;\n        }else{\n            if(items[index].list==null){\n                items[index].list=new LinkedList();\n            }\n            items[index].list.add(key);\n        }\n    }\n\n    public void remove(int key) {\n        int index=key%DEFAULT_SIZE;\n        if(items[index]==null) return;\n        if(items[index].value==key){\n            List<Integer> list = items[index].list;\n            if(list==null||list.isEmpty()){\n                items[index]=null;\n            }else{\n                int lastValue=list.get(list.size()-1);\n                items[index].value=lastValue;\n                list.remove(list.size()-1);\n                if(list.isEmpty()) items[index].list=null;\n            }\n        }else{\n            List<Integer> list=items[index].list;\n            if(list==null) return;\n            int findIndex=-1;\n            for (int i = 0; i < list.size(); i++) {\n                if(list.get(i).equals(key)){\n                    findIndex=i;\n                }\n            }\n            if(findIndex!=-1){\n                list.remove(findIndex);\n                if(list.isEmpty()) items[index].list=null;\n            }\n        }\n    }\n\n    public boolean contains(int key) {\n        int index=key%DEFAULT_SIZE;\n        if(items[index]==null) return false;\n        else{\n            if(items[index].value==key) return true;\n            List<Integer> list = items[index].list;\n            if(list==null) return false;\n            for (int i = 0; i < list.size(); i++) {\n                if(list.get(i).equals(key)) return true;\n            }\n            return false;\n        }\n    }\n\n    public static void main(String[] args) {\n        MyHashSet myHashSet = new MyHashSet();\n        myHashSet.add(1);      // set = [1]\n        myHashSet.add(2);      // set = [1, 2]\n        myHashSet.contains(1); // 返回 True\n        myHashSet.contains(3); // 返回 False ，（未找到）\n        myHashSet.add(2);      // set = [1, 2]\n        myHashSet.contains(2); // 返回 True\n        myHashSet.remove(2);   // set = [1]\n        myHashSet.contains(2); // 返回 False ，（已移除）\n    }\n}\n\nclass Item{\n    int value;\n    List<Integer> list;\n}\n```\n\n","categories":["算法"]},{"title":"算法刷题记录DAY4","url":"/2024/08/11/算法刷题记录DAY4/","content":"\n# 字母异位分词\n\n![](./算法刷题记录DAY4/1723365543223.png)\n\n> 思路：用一个count记录p中26个字母出现的频率，再遍历s，用数组cnt记录s中从i到i+len-1中各字母出现的频率，重点是cnt数组的更新：i迭代时，不需要再重新遍历i到i+len-1，只需要更新一头一尾的字母频率。\n\n```cpp\nclass Solution {\npublic:\n    vector<int> findAnagrams(string s, string p) {\n        vector<int> res;\n        int len=p.size();\n        int n=s.size();\n        vector<int> count(26,0);\n        for(int i=0;i<len;i++){\n            count[p[i]-'a']++;\n        }\n        vector<int> cnt(26,0);\n        for(int i=0;i<=n-len;i++){\n            if(i==0){\n                for(int j=0;j<len;j++){\n                    cnt[s[i+j]-'a']++;\n                }\n            }\n            bool flag=true;\n            for(int k=0;k<26;k++){\n                if(cnt[k]!=count[k]) {\n                    flag=false;\n                    break;\n                }\n            }\n            if(flag){\n                res.push_back(i);\n            }\n            if(i!=n-len){\n                cnt[s[i]-'a']--;\n            cnt[s[i+len]-'a']++;\n            }\n        }\n        return res;\n    }\n};\n```\n\n# 合并区间\n\n![](./算法刷题记录DAY4/1723367494958.png)\n\n> 思路：排序即可：先按start升序排序，start值相同的区间end值大的在前；排序好后遍历区间即可。\n\n```java\nclass Solution {\n    public int[][] merge(int[][] intervals) {\n        Arrays.sort(intervals, new Comparator<int[]>() {\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                if(o1[0]>o2[0]) return 1;\n                else if(o1[0]<o2[0]) return -1;\n                else{\n                    if(o1[1]<o2[1]) return 1;\n                    else if(o1[1]>o2[1]) return -1;\n                    return 0;\n                }\n            }\n        });\n        List<int[]> res=new LinkedList();\n        int begin=0;\n        int end=0;\n        for(int i=0;i<intervals.length;i++){\n            if(i==0){\n                begin=intervals[0][0];\n                end=intervals[0][1];\n            }else{\n                if(end>=intervals[i][0]&&end<intervals[i][1]){\n                    end=intervals[i][1];\n                }else if(end>=intervals[i][1]){\n                    \n                }else if(end<intervals[i][0]){\n                    res.add(new int[]{begin,end});\n                    begin=intervals[i][0];\n                    end=intervals[i][1];\n                }\n            }\n            if(i==intervals.length-1){\n                res.add(new int[]{begin,end});\n            }\n        }\n        int[][] ans=new int[res.size()][2];\n        int index=0;\n        for (int[] re : res) {\n            ans[index][0]=re[0];\n            ans[index][1]=re[1];\n            index++;\n        }\n        return ans;\n    }\n}\n```\n\n> **STL自定义排序**\n\n由于我对这个不是特别熟悉，这里记录一下\n\n1. sort简介\n- 内部实现方法类似于快排，时间复杂度为$nlog2(n)$\n- 需要引入头文件 `#include<algorithm>`\n\n2. sort使用方法\n- 调用形式：`sort(first,last,cmp)` 其中，first是元素的起始地址，last是结束地址，cmp是排序的方式。对[first，last)（一定要注意这里的区间是左闭又开）区间内数据根据cmp的方式进行排序。也可以不写第三个参数，此时按默认排序，从小到大进行排序。\n\n3. 自定义排序\n- 自定义比较函数cmp\n```cpp\nbool cmp(vector<int> nums1,vector<int> nums2){\n    if(nums1[0]>nums2[0]) return true;\n    else if(nums1[0]<nums2[0]) return false;\n    else{\n        if(nums1[1]<nums2[1]) return false;\n        else if(nums1[1]>nums2[1]) return false;\n        return true;\n    }\n}\n```\n**传入的参数类型和需要排序的数据类型一致**\n- 重载比较运算符“<”\n```cpp\nbool operator< (const Student& s1, const Student& s2)\n{\n    if(s1.age==s2.age) return s1.name <s2.name;//年龄相同时，按姓名小到大排\n    else return s1.age > s2.age; //从年龄大到小排序\n}\nsort(a,a+n);\n```\n**参数类型如果是自定义类型，比如自己定义的结构体，类，尽管sort函数默认是从小到大排列，但是这里必须要重载比较运算符“<”!!!**\n\n- 声明比较类\n```cpp\nstruct cmp\n{\n    bool operator() (const Student& s1, const Student& s2)\n    {\n        if(s1.age==s2.age) return s1.name <s2.name;\n        else  return s1.age < s2.age;\n    }\n};\nsort(a,a+n,cmp());\n```\n\n**[参考](https://blog.csdn.net/weixin_41588502/article/details/86620305)**\n\n# 除自身以外数组的乘积\n\n![](./算法刷题记录DAY4/1723450251113.png)\n\n```cpp\nclass Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        int n=nums.size();\n        vector<int> prefix(n,1);\n        vector<int> endfix(n,1);\n        prefix[0]=nums[0];\n        for(int i=1;i<n;i++){\n           prefix[i]=prefix[i-1]*nums[i];\n        }\n        endfix[n-1]=nums[n-1];\n        for(int i=n-2;i>=0;i--){\n            endfix[i]=endfix[i+1]*nums[i];\n        }\n        vector<int> ans(n,0);\n        for(int i=0;i<n;i++){\n            ans[i]=(i>0?prefix[i-1]:1)*(i<n-1?endfix[i+1]:1);\n        }\n        return ans;\n    }\n};\n```\n\n> 优化：从左往右遍历时使用answer数组进行计算，而从右往左遍历时只使用一个变量进行记录即可减小空间复杂度。\n\n```cpp\nclass Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        int length = nums.size();\n        vector<int> answer(length);\n\n        // answer[i] 表示索引 i 左侧所有元素的乘积\n        // 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1\n        answer[0] = 1;\n        for (int i = 1; i < length; i++) {\n            answer[i] = nums[i - 1] * answer[i - 1];\n        }\n\n        // R 为右侧所有元素的乘积\n        // 刚开始右边没有元素，所以 R = 1\n        int R = 1;\n        for (int i = length - 1; i >= 0; i--) {\n            // 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R\n            answer[i] = answer[i] * R;\n            // R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上\n            R *= nums[i];\n        }\n        return answer;\n    }\n};\n\n// 作者：力扣官方题解\n// 链接：https://leetcode.cn/problems/product-of-array-except-self/solutions/272369/chu-zi-shen-yi-wai-shu-zu-de-cheng-ji-by-leetcode-/\n// 来源：力扣（LeetCode）\n// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n# 岛屿数量\n\n![](./算法刷题记录DAY4/1723389400817.png)\n\n> 思路：对二维数组使用dfs，使用了多少次dfs则代表有多少个岛屿\n\n```cpp\nclass Solution {\npublic:\n    int m,n;\n    int dir[4][2]={\n        {-1,0},\n        {1,0},\n        {0,-1},\n        {0,1}\n    };\n    int numIslands(vector<vector<char>>& grid) {\n        m=grid.size();\n        n=grid[0].size();\n        int ans=0;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(grid[i][j]=='1'){\n                    ans++;\n                    dfs(grid,i,j);\n                }\n            }\n        }\n        return ans;\n    }\n    void dfs(vector<vector<char>> &grid,int row,int col){\n        if(row<0||row>=m||col<0||col>=n) return;\n        if(grid[row][col]=='0') return;\n        grid[row][col]='0';\n        for(int i=0;i<4;i++){\n            int nx=row+dir[i][0];\n            int ny=col+dir[i][1];\n            dfs(grid,nx,ny);\n        }\n    }\n};\n```\n\n# 括号生成\n\n![](./算法刷题记录DAY4/1723390811334.png)\n\n> 思路：暴力，每个位置只有`'('`和`')'`两种可能，总共有 $4^n$ 种可能，n最大为8，可能会超时，优化一下：依据左右括号数目应该相同，进行减枝。\n\n```cpp\n#include<stack>\nclass Solution {\npublic:\n    vector<string> ans;\n    vector<string> generateParenthesis(int n) {\n        dfs(\"\",n,0);\n        return ans;\n    }\n    void dfs(string s,int n,int lcnt){\n        if(s.size()==2*n&&lcnt==n&&check(s)){\n            ans.push_back(s);\n            return;\n        }\n        int rcnt=s.size()-lcnt;\n        if(rcnt<n){\n            dfs(s+')',n,lcnt);\n        }\n        if(lcnt<n){\n            dfs(s+'(',n,lcnt+1);\n        }\n    }\n    bool check(string s){\n        stack<char> stk;\n        for(int i=0;i<s.size();i++){\n            if(s[i]=='(') stk.push(s[i]);\n            else{\n                if(stk.size()==0) return false;\n                if(stk.top()=='('){\n                    stk.pop();\n                }else return false;\n            }\n        }\n        return stk.size()==0;\n    }\n};\n```\n","categories":["算法"]},{"title":"算法刷题记录DAY3","url":"/2024/08/08/算法刷题记录DAY3/","content":"\n# 位运算的奇巧淫技\n\n- 判断奇偶数\n`x&1=1`为奇数，`x&1=0`为偶数\n\n- 获取二进制位是1还是0\n左移后和1作&运算\n\n- 交换两个整数变量的值\n```cpp\nx=x^y;\ny=x^y;\nx=x^y;\n```\n- 不用判断语句，求整数的绝对值\n\n## 异或性质\n\n![](./算法刷题记录DAY3/1723186263238.png)\n\n# 找出唯一成对的数\n\n![](./算法刷题记录DAY3/1723186362438.png)\n\n> 思路：可以利用set，也可以单独开一个长度1000的数组，但是都不符合题意；这个时候可以利用`^`运算：\n```\nA^A=0;\nA^A^B^C^C=B;\nA^A^A=A;\n```\n即奇数个一样的数异或等于它本身。\n\n```cpp\nint slove(vector<int> &nums){\n    int n=1000;\n    int number=0;\n    number=number^nums[0];\n    for(int i=1;i<=n;i++){\n        number=number^i;\n        number=number^nums[i];\n    }\n    return number;\n}\n```\n\n# 二进制中1的个数\n\n![](./算法刷题记录DAY3/1723187280829.png)\n\n> 思路1：获取到该数中二进制的每一位，计算为1的个数\n\n```cpp\nint slove(int n){\n    int ans=0;\n    while(n){\n        ans+=(n&1);\n        n>>1;\n    }\n    return ans;\n}\n```\n\n> 思路2：x&(x-1)可以将x中最低位的1变成0，循环操作即可，循环次数即为1的个数\n\n```cpp\nint solve(int n){\n    int ans=0;\n    while(n){\n        n=n&(n-1);\n        ans++;\n    }\n    return ans;\n}\n```\n\n# 是不是2的整数次方\n\n用1条语句判断一个整数是不是2的整数次方\n\n> 思路：x&(x-1)之后可以将x最低位的1变成0，如果x是2的整数次方，则x二进制中只有一个1，与x-1作&运算之后将变为0；\n\n```cpp\nbool slove(int n){\n    return x&(x-1) ==0 ;\n}\n```\n\n# 将整数的奇偶位互换\n\n> 思路：![](./算法刷题记录DAY3/1723188154647.png)\n![](./算法刷题记录DAY3/1723188213237.png)\n然后将c左移一位、d右移一位，拼接在一起即可\n\n```cpp\nint slove(int n){\n    int a=0x55555555;\n    int b=0xaaaaaaaa;\n    int c=a&n;\n    int d=b&n;\n    return (c<<1)|(d>>1);\n}\n```\n\n# 0~1间浮点实数的二进制表示\n\n![](./算法刷题记录DAY3/1723188474391.png)\n\n> 思路：依次小数*2取整数位即可。\n\n```cpp\n#include<string>\nvoid slove(double a){\n    string ans=\"0.\";\n    int count=0;\n    while(a>0&&count<32){\n        a=a*2;\n        if(a>=1) {\n            ans+=\"1\";\n            a-=1;\n        }else{\n            ans+=\"0\";\n        }\n        count++;\n    }\n    if(a>0) cout<<\"ERROR\"<<endl;\n    else cout<<ans<<endl;\n}\n```\n\n# 出现K次与出现1次\n\n![](./算法刷题记录DAY3/1723188840312.png)\n\n> 思路：k个相同的数作k进制下的不进位加和结果为0，所以只需要这些数全部作k进制下的不进位加和，将结果还原即为答案。\n\n```cpp\nint slove(vector<int> &nums,int k){\n    vector<vector<int>> numskradix(nums.size(),vector<int>());\n    //求每个数的k进制表示\n    int maxlen=0;\n    for(int i=0;i<nums.size();i++){\n        int t=nums[i];\n        while(t){\n            numskradix[i].push_back(t%k);\n            t=t/k;\n        }\n        maxlen=max(maxlen,numskradix[i].size());\n    }\n\n    //计算\n    vector<int> arr(maxlen,0);\n    for(int i=0;i<maxlen;i++){\n        for(int j=0;j<nums.size();j++){\n            if(i<numskradix[j].size()){\n                arr[i]=(arr[i]+numskradix[j][i])%k;\n            }\n        }\n    }\n\n    //复原\n    int ans=0;\n    int m=1;\n    for(int i=0;i<maxlen;i++){\n        ans+=arr[i]*m;\n        m=m*k;\n    }\n    return ans;\n}\n```\n","categories":["算法","位运算"]},{"title":"sql递归查询","url":"/2024/08/07/sql递归查询/","content":"\n# 前言\n\n之前在南大夏令营笔试遇到一题SQL递归查询的，当时空在那，现在补一下\n\n# MySQL with Recursive\nMySQL with Recursive是一种基于递归思想的MySQL查询方式，可以实现对数据的递归查询和处理，返回符合条件的数据。在MySQL 8.0版本中，该功能被正式引入。\n\n> WITH RECURSIVE 语句包含两部分：\n> - 递归部分: 定义了如何递归查询数据;\n> - 终止条件部分: 定义了递归查询何时停止。\n\n## 语法\n\n```sql\nWITH RECURSIVE recursive_query_name (col1, col2, ..., coln) AS (\n    -- 递归部分\n    SELECT \n\t\t\tinitial_query_result_col1, \n\t\t\tinitial_query_result_col2, \n\t\t\t...,\n\t\t\tinitial_query_result_coln\n    FROM initial_query\n    UNION ALL\n    SELECT \n\t\t\trecursive_query_result_col1,\n\t\t\trecursive_query_result_col2, \n\t\t\t..., \n\t\t\trecursive_query_result_coln\n    FROM recursive_query_name, recursive_query\n    WHERE recursive_query_condition\n)\n-- 终止条件部分\nSELECT * FROM recursive_query_name ;\n```\n\n![](./sql递归查询/1.png)\n\n### 案例\n\n![](./sql递归查询/image.png)\n\n![](./sql递归查询/04ecb3374db9d50e65baea1384bb6cbc.png)\n\n> 分析：`SELECT p.* FROM course_category p WHERE p.id = '1' ` 这个sql结果赋值给t1;然后通过这个初次查询结果的t1表继续去跟course_category联查,符合where条件的再赋值给t1;直至没有符合条件的;最后需要的数据都在t1表里了,只需要查询t1表即可;\n\n# 参考\n[CSDN](https://blog.csdn.net/djdjfjf1/article/details/134808935)\n","categories":["sql"]},{"title":"codeforces-964-div4","url":"/2024/08/07/codeforces-964-div4/","content":"\n# 前言\n\n本想先拿div4的难度入个门，没想到只会签到题，还是太菜了。。。\n\n# A. A+B\n\n![](./codeforces-964-div4/1723016317231.png)\n\n```cpp\n#include<iostream>\n\nusing namespace std;\n\nint main(){\n    int t;\n    cin>>t;\n    int a;\n    while(t--){\n        cin>>a;\n        cout<<a/10+a%10<<endl;\n    }\n    return 0;\n}\n```\n\n# B. Card Game\n\n![](./codeforces-964-div4/1723016430524.png)\n![](./codeforces-964-div4/1723016563903.png)\n\n> 思路：情况很少，枚举出来就行\n\n```cpp\n#include<iostream>\n\nusing namespace std;\n\nint func(int a1,int a2,int b1,int b2){\n    int ans=0;\n    //a1-b1 a2-b2\n    if(a1>b1&&a2>b2) ans+=2;\n    else if(a1>b1&&a2==b2) ans+=2;\n    else if(a1==b1&&a2>b2) ans+=2;\n\n    //a1-b2 a2-b1\n    if(a1>b2&&a2>b1) ans+=2;\n    else if(a1>b2&&a2==b1) ans+=2;\n    else if(a1==b2&&a2>b1) ans+=2;\n    return ans;\n}\nint main(){\n    int t;\n    cin>>t;\n    int a1,a2,b1,b2;\n    while(t--){\n        cin>>a1>>a2>>b1>>b2;\n        cout<<func(a1,a2,b1,b2)<<endl;\n    }\n    return 0;\n}\n```\n\n# C. Showering\n\n![](./codeforces-964-div4/1723016780857.png)\n![](./codeforces-964-div4/1723016998339.png)\n\n> 思路：计算区间间距，大于s就可以\n\n```cpp\n#include<iostream>\n#include<vector>\n\nusing namespace std;\nbool func(int n,int s,int m,vector<pair<int,int>> &nums){\n    int before=0;\n    if(m-nums[n-1].second>=s) return true;\n    for(int i=0;i<n;i++){\n        if(nums[i].first-before>=s) return true;\n        else{\n            before=nums[i].second;\n        }\n    }\n    return false;\n}\nint main(){\n    int t;\n    cin>>t;\n    int a;\n    int n,s,m;\n    while(t--){\n        cin>>n>>s>>m;\n        vector<pair<int,int>> nums(n);\n        for(int i=0;i<n;i++){\n            cin>>nums[i].first>>nums[i].second;\n        }\n        if(func(n,s,m,nums)){\n            cout<<\"YES\"<<endl;\n        }else{\n            cout<<\"NO\"<<endl;\n        }\n    }\n    return 0;\n}\n```\n\n# D. Slavic's Exam\n\n![](./codeforces-964-div4/1723016954808.png)\n![](./codeforces-964-div4/1723017090563.png)\n\n> 思路：\n\n\n# E. Triple Operations\n\n![](./codeforces-964-div4/image.png)\n\n> 思路：\n\n\n# F. Expected Median\n\n![](./codeforces-964-div4/1723017618441.png)\n\n![](./codeforces-964-div4/1723017667456.png)\n\n> 思路：\n\n\n# G1. Ruler (easy version)\n\n![](./codeforces-964-div4/1723017842288.png)\n![](./codeforces-964-div4/1723017873538.png)\n![](./codeforces-964-div4/1723017899752.png)\n\n> 思路：\n\n# G2. Ruler (hard version)\n\n![](./codeforces-964-div4/1723017988966.png)\n![](./codeforces-964-div4/1723018030170.png)\n![](./codeforces-964-div4/1723018053558.png)\n\n> 思路：\n\n","categories":["算法"]},{"title":"数学","url":"/2024/08/05/数学/","content":"\n[参考](https://www.bilibili.com/video/BV1Ei4y137gj/?spm_id_from=333.337.search-card.all.click&vd_source=1e4dde82b17a014f17a01a1aada081b1)\n\n# 集卡片 [原题链接](http://acm.hdu.edu.cn/showproblem.php?pid=1099)\n![](./数学/image.png)\n\n> 关键思想：知道此处期望是概率的倒数即可，<br>\n> 比如有5张卡片，<br>\n- 第一步你获得想要卡片的概率是1，倒数为1；<br>\n- 第二步你获得想要卡片的概率是4/5，倒数为5/4；<br>\n- 第三步你获得想要卡片的概率是3/5，倒数为5/3；<br>\n……累加即为结果\n\n```cpp\n#include <iostream>\nusing namespace std;\n\ntypedef long long ll;\n\nll GCD(ll a,ll b){\n    if(a==0||b==0)return 1; \n    return a%b==0?b:GCD(b,a%b);\n}\n\nint digits(ll n){\n    int d=0;\n    while(n){\n        n/=10;\n        d++;\n    }\n    return d;\n}\n\nint main(){\n    int n;\n    ll num,deno,inte;//分子分母整数部分 \n    while(scanf(\"%d\",&n)!=EOF){\n        num=0,deno=1,inte=1;\n        for(int i=1;i<=n-1;i++){ \n            num=num*i+deno*n;\n            deno=deno*i;\n            ll gcd=GCD(num,deno);//约分 \n            num/=gcd;\n            deno/=gcd; \n        } \n        inte+=num/deno;//整数部分 \n        num=num%deno;//分数部分 \n        if(num==0)printf(\"%lld\\n\",inte);//若能整除 \n        else{//格式化输出 \n            for(int i=0;i<=digits(inte);i++)printf(\" \"); \n            printf(\"%lld\\n\",num);\n            printf(\"%lld \",inte);\n            for(int i=0;i<digits(deno);i++)printf(\"-\");\n            printf(\"\\n\");\n            for(int i=0;i<=digits(inte);i++)printf(\" \");\n            printf(\"%lld\\n\",deno);\n        }\n\n    }\n    return 0;\n}\n```\n\n[来源](https://www.cnblogs.com/G-M-WuJieMatrix/p/7400401.html)\n\n# 随机数生成器\n\n![](./数学/1722852855899.png)\n\n> 使用","categories":["算法","数学"]},{"title":"力扣热题100","url":"/2024/08/04/力扣热题100/","content":"# 两数之和\n> easy\n\n![](./力扣热题100/image.png)\n\n> 用哈希存储遍历过的元素即可\n\n```cpp\n#include<vector>\n#include<map>\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        vector<int> ans;\n        map<int,int> mp;\n        for(int i=0;i<nums.size();i++){\n            if(mp[target-nums[i]]!=0){\n                ans.push_back(mp[target-nums[i]]-1);\n                ans.push_back(i);\n                return ans;\n            }else{\n                mp[nums[i]]=i+1;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n# 字母异位词分组\n> medium\n\n![](./力扣热题100/1722785853405.png)\n\n> 一开始的思路是计算每个字符串的哈希值，两个异位词的哈希值相同，但是想不出怎么计算比较合适，于是改成直接排序字符串\n\n```cpp\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<map>\n\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        vector<vector<string>> ans;\n        map<string,int> mp;\n        for(int i=0;i<strs.size();i++){\n            string ss=sort_(strs[i]);\n            auto fd=mp.find(ss);\n            if(fd!=mp.end()){\n                int index=mp[ss];\n                ans[index].push_back(strs[i]);\n            }else{\n                mp[ss]=ans.size();\n                ans.push_back(vector<string>(1,strs[i]));\n            }\n        }\n        return ans;\n    }\n\n    string sort_(string str){\n        sort(str.begin(),str.end());\n        return str;\n    }\n};\n```\n\n> 官方题解中另一种方法是用字符和该字符出现的次数拼接成字符串作为哈希map的键，感觉也大差不差\n![](./力扣热题100/1722787345351.png)\n\n```java\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        Map<String, List<String>> map = new HashMap<String, List<String>>();\n        for (String str : strs) {\n            int[] counts = new int[26];\n            int length = str.length();\n            for (int i = 0; i < length; i++) {\n                counts[str.charAt(i) - 'a']++;\n            }\n            // 将每个出现次数大于 0 的字母和出现次数按顺序拼接成字符串，作为哈希表的键\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < 26; i++) {\n                if (counts[i] != 0) {\n                    sb.append((char) ('a' + i));\n                    sb.append(counts[i]);\n                }\n            }\n            String key = sb.toString();\n            List<String> list = map.getOrDefault(key, new ArrayList<String>());\n            list.add(str);\n            map.put(key, list);\n        }\n        return new ArrayList<List<String>>(map.values());\n    }\n}\n```\n\n> 作者：[力扣官方题解](https://leetcode.cn/problems/group-anagrams/solutions/520469/zi-mu-yi-wei-ci-fen-zu-by-leetcode-solut-gyoc/)\n来源：力扣（LeetCode）\n\n# 最长连续序列\n\n![](./力扣热题100/1723019783568.png)\n\n> 思路：先用set存好数，然后用每个数去匹配，这样大概是$O(n^2)$复杂度，改进：遍历set中的数，每对一个数进行匹配，当前数num的前驱num-1不能在set中。\n\n```cpp\n#include<vector>\n#include<set>\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        set<int> st;\n        int n=nums.size();\n        for(int i=0;i<n;i++){\n            st.insert(nums[i]);\n        }\n        int ans=0;\n        for(int num:st){\n            if(!st.count(num-1)){\n                int cur=num;\n                int len=1;\n                while(st.count(cur+1)){\n                    cur++;\n                    len++;\n                }\n                ans=max(ans,len);\n            }\n        }\n        return ans;\n    }\n};\n```\n\n# 盛最多水的容器\n\n> medium\n\n![](./力扣热题100/1723020925708.png)\n![](./力扣热题100/1723020968959.png)\n![](./力扣热题100/1723021071234.png)\n\n> 思路：双指针法，从两边向中间遍历，每次移动那个height值更小的位置指针，因为如果移动更大的指针，则之后面积一定会比当前的面积更小。**短板效应**\n\n```cpp\nclass Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        int left=0;\n        int right=height.size()-1;\n        int ans=0;\n        int s=0;\n        while(left<right){\n            s=(right-left)*min(height[left],height[right]);\n            ans=max(ans,s);\n            if(height[left]<height[right]) left++;\n            else right--;\n        }\n        return ans;\n    }\n};\n```\n\n# 缺失的第一个正数\n\n<p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p> 请你实现时间复杂度为 \n<code>O(n)</code> 并且只使用常数级别额外空间的解决方案。\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,0]\n<strong>输出：</strong>3\n<strong>解释：</strong>范围 [1,2] 中的数字都在数组中。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,4,-1,1]\n<strong>输出：</strong>2\n<strong>解释：</strong>1 在数组中，但 2 没有。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [7,8,9,11,12]\n<strong>输出：</strong>1\n<strong>解释：</strong>最小的正数 1 没有出现。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul> \n <li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li> \n <li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li> \n</ul>\n\n<div><div>Related Topics</div><div><li>数组</li><li>哈希表</li></div></div><br><div><li>👍 2187</li><li>👎 0</li></div>\n\n> 思路：用set存下每个大于0的数，然后遍历，这里因为set是升序的，所以容易找到缺了哪个\n\n```c++\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        set<int> st;\n        for (int num:nums) {\n            if(num>0) st.insert(num);\n        }\n        int res=0;\n        for(int num:st){\n            if(num==res+1) res++;\n            else return res+1;\n        }\n        return res+1;\n    }\n};\n```\n","categories":["算法","Leetcode热题100"]},{"title":"算法刷题记录DAY2","url":"/2024/08/04/算法刷题记录DAY2/","content":"\n# 华为2016研发工程师编程题 [牛客网](https://www.nowcoder.com/exam/test/81883766/detail?pid=710802&examPageSource=Company&testCallback=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fcompany%3FcurrentTab%3Drecommand%26jobId%3D100%26selectStatus%3D0%26tagIds%3D239&testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91)\n\n## 删数\n![](./算法刷题记录DAY2/image.png)\n\n> 思路：用计数器计数即可\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\nvoid solve(int n) {\n    stack<int> stk;\n    vector<bool> nums(n, true);\n    int count = 0;\n    int index = 0;\n    while (stk.size() < n) {\n        if (nums[index] && count == 2) {\n            nums[index] = false;\n            stk.push(index);\n            count = 0;\n            index = (index + 1) % n;\n        } else if (!nums[index]) {\n            index = (index + 1) % n;\n        } else {\n            index = (index + 1) % n;\n            count++;\n        }\n    }\n    cout << stk.top() << endl;\n}\nint main() {\n    int n;\n    while(cin>>n){\n        solve(n);\n    }\n    return 0;\n}\n// 64 位输出请用 printf(\"%lld\")\n```\n\n## 字符集合\n![](./算法刷题记录DAY2/image1.png)\n\n> 思路：用set记录之前出现过的字符即可\n\n```cpp\n#include <iostream>\n#include <set>\n#include <string>\nusing namespace std;\n\nvoid solve(string &s){\n    set<char> st;\n    for(int i=0;i<s.length();i++){\n        if(st.count(s[i])) continue;\n        else{\n            st.insert(s[i]);\n            cout<<s[i];\n        }\n    }\n    cout<<endl;\n}\nint main() {\n    string s;\n    while(cin>>s){\n        solve(s);\n    }\n    return 0;\n}\n// 64 位输出请用 printf(\"%lld\")\n```\n\n## 数独\n![](./算法刷题记录DAY2/image3.png)\n\n> 思路：使用回溯法，一行一行的进行搜索<br>\n注意：不需要用数组存储该位置可以放的数\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <set>\n#define SIZE 9\n\nusing namespace std;\n\nvector<vector<int>> map(SIZE, vector<int>(SIZE));\n// int cnt = 0;\nint notzerocnt = 0;\nbool check(int row, int col, int num)\n{\n    for (int i = 0; i < SIZE; i++)\n    {\n        if (map[row][i] == num || map[i][col] == num)\n            return false;\n    }\n    int rb = (row / 3) * 3;\n    int cb = (col / 3) * 3;\n    for (int i = rb; i < rb + 3; i++)\n    {\n        for (int j = cb; j < cb + 3; j++)\n        {\n            if (map[i][j] == num)\n                return false;\n        }\n    }\n    return true;\n}\nvoid print()\n{\n    for (int i = 0; i < 9; i++)\n    {\n        for (int j = 0; j < 9; j++)\n        {\n            cout << map[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\nvoid backtrace(int n, int notzerocnt)\n{\n    int row = n / 9;\n    int col = n % 9;\n    if (n == 81 || notzerocnt == 81)\n    {\n        print();\n        return;\n    }\n    if (map[row][col] != 0)\n    {\n\n        if (col < SIZE - 1)\n        {\n            backtrace(++n, notzerocnt);\n        }\n        else\n        {\n            backtrace(++n, notzerocnt);\n        }\n    }\n    else\n    {\n        for (int i = 1; i <= SIZE; i++)\n        {\n\n            if (check(row, col, i))\n            {\n                map[row][col]=i;\n                backtrace(n+1, notzerocnt+1);\n                map[row][col]=0;\n            }\n        }\n    }\n}\nint main()\n{\n\n    for (int i = 0; i < SIZE; i++)\n    {\n        for (int j = 0; j < SIZE; j++)\n        {\n            cin >> map[i][j];\n            if (map[i][j] != 0)\n                notzerocnt++;\n        }\n    }\n    backtrace(0, notzerocnt);\n}\n```","categories":["算法"]},{"title":"CSAPP-Lab1-data","url":"/2024/08/04/CSAPP-Lab1-data/","content":"\n\n# 实验准备\n\n> 了解! ~ & ^ | + << >> 运算符\n**&（按位与）、|（按位或）、^（按位异或）、~（按位取反）和<<（左移）、>>（右移）都是直接在整数的补码表示上进行运算。**\n\n1. ! 运算符\n    - 若对布尔值进行运算非false则true，非true则false。\n    - 若对整数进行运算，C语言中的整数可以直接在逻辑表达式中隐式地转换为布尔值，其中非零整数转换为 true，零整数转换为 false，计算规则同上。\n2. ~ 运算符 \n    对操作数的每一位进行取反。在补码表示中，按位取反然后加1等价于取一个数的二进制补码。但是，~ 运算符本身不涉及补码转换，它只是简单地翻转每一位。\n3. & 运算符\n\t对两个操作数的对应位进行逻辑与操作。由于操作数已经是补码形式，直接进行位运算。\n4. ^ 运算符\n\t对两个操作数的对应位进行逻辑异或操作。与 & 类似，直接在补码形式上进行。\n5. | 运算符\n\t对两个操作数的对应位进行逻辑或操作，同样直接在补码形式上进行。\n6. \\+ 运算符\n\t加法运算符在补码表示上直接进行。如果操作数是整数，它们已经是补码形式，加法运算会考虑溢出。\n7. << 、>>运算符\n    - 左移运算符将操作数的所有位向左移动指定的位数，空出的位填充为0。\n    - 右移运算符将操作数的所有位向右移动指定的位数。\n        - 逻辑右移用0填充空出的位；\n        - 算术右移用符号位填充空出的位。\n\n\n# 1-bitXor\n\n> 要求：\n bitXor - x^y using only ~ and & \n Example: bitXor(4, 5) = 1\n Legal ops: ~ &\n Max ops: 14\n Rating: 1\n \n 代码\n```c\nint bitXor(int x, int y) {\n  int ans=~((~((~x)&y))&(~(x&(~y))));\n  return ans;\n}\n```\n\n# 1-tmin\n\n> 要求：\ntmin - return minimum two's complement integer \nLegal ops: ! ~ & ^ | + << >>\nMax ops: 4\nRating: 1\n\n代码：\n```c\nint tmin(void) {\n  int ans=1<<31;\n  return ans;\n}\n```\n\n# 2-isTmax\n\n> 要求：\n  isTmax - returns 1 if x is the maximum, two's complement number,\n  and 0 otherwise \n  Legal ops: ! ~ & ^ | +\n  Max ops: 10\n \n 代码：\n```c\nint isTmax(int x) {\n  int plus1=x+1;\n  plus1=(plus1^x);\n  int tmp=((plus1>>31)&1);\n  int ans=tmp&(!(x>>31)&1);\n  return ans;\n}\n```\n\n# 2-allOddBits\n\n> 要求：\nallOddBits - return 1 if all odd-numbered bits in word set to 1\n  where bits are numbered from 0 (least significant) to 31 (most significant)\n  Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1\n  Legal ops: ! ~ & ^ | + << >>\n  Max ops: 12\n  Rating: 2\n\n```c\nint allOddBits(int x) {\n  /*\n   */\n  int t1=(x&0xAA)^0xAA;\n  int t2=((x>>8)&0xAA)^0xAA;\n  int t3=((x>>16)&0xAA)^0xAA;\n  int t4=((x>>24)&0xAA)^0xAA;\n  int t=!(t1+t2+t3+t4);\n  return t;\n}\n```\n","categories":["计算机基础","CSAPP"]},{"title":"CSAPP-Lab0-环境搭建","url":"/2024/08/04/CSAPP-Lab0-环境搭建/","content":"\n# 使用工具\nWindows 11，WSL，VScode，GCC编译套装\n\n# 安装步骤\n## WSL安装Ubuntu\n\n参考：**[安装WSL](https://blog.csdn.net/weixin_57367513/article/details/135001273)**\n\n## VScode配置WSL插件\nvscode搜索如下插件进行安装：![alt text](./CSAPP-Lab0-环境搭建/image.png)\n参考：**[安装WSL插件](https://blog.csdn.net/yanbober/article/details/138245581)**\n\n## 安装GCC编译套装\n打开WSL命令行窗口，输入 `sudo apt-get update` \n然后输入下面三条指令：\n```shell\nsudo apt-get install build-essential\nsudo apt-get install gcc-multilib\nsudo apt-get install gdb\n```\n参考：**[GCC编译套装的安装](https://blog.csdn.net/qq_45703010/article/details/120897185)**","categories":["计算机基础","CSAPP"]},{"title":"树","url":"/2024/08/04/树/","content":"\n\n# 树的定义\n\n![](树/Untitled.png)\n\n![](树/Untitled%201.png)\n\n![](树/Untitled%202.png)\n\n![](树/Untitled%203.png)\n\n## 树的性质\n\n![](树/Untitled%204.png)\n\n# 二叉树\n\n二叉树是另一种树形结构，其特点是每个结点至多只有两棵子树( 即二叉树中不存在度大于2的结点)，并且二叉树的子树有左右之分，其次序不能任意颠倒。\n\n![](树/Untitled%205.png)\n\n![](树/Untitled%206.png)\n\n## 满二叉树\n\n每个节点要么是叶节点，要么是有两个子节点的节点\n\n## 完全二叉树\n\n每一层都从左往右尽量铺满\n\n## 二叉树的实现\n\n```java\nimport java.util.*;\n\n/**\n * 二叉检索树：对任意一个节点，\n *      左子树上的节点的值均小于该节点的值\n *      右子树上的节点的值均不小于该节点的值\n */\npublic class MyBST<K extends Comparable<K> ,V> implements BST<K,V>{\n\n    private BinNode<K,V> root;\n    public MyBST(){\n        root=null;\n    }\n    @Override\n    public void insert(K key, V value) {\n        if (key==null){\n            try {\n                throw new Exception(\"key is null.\");\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return;\n        }\n        root=insertHelper(key,value,root);\n    }\n\n    private BinNode<K,V> insertHelper(K key,V value,BinNode<K,V> root){\n        if (root==null){\n            return new BinNode<>(key,value);\n        }\n        int res=root.getKey().compareTo(key);\n        if (res<=0){//root更小 插入右子树\n            root.setRight(insertHelper(key,value,root.getRight()));\n        }else{\n            root.setLeft(insertHelper(key,value,root.getLeft()));\n        }\n        return root;\n    }\n\n    @Override\n    public V remove(K key) {\n        if (key==null) {\n            try {\n                throw new Exception(\"key is null.\");\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n        V val=search(key);\n        if (val!=null) removeHelper(key,root);\n        return val;\n    }\n\n    private BinNode<K,V> findMin(BinNode<K,V> root){\n        if (root==null) return null;\n        if (root.getLeft()==null) return root;\n        return findMin(root.getRight());\n    }\n\n    private BinNode<K,V> removeHelper(K key,BinNode<K,V> root){\n        if (root==null) return null;\n        int res=root.getKey().compareTo(key);\n        if (res>0){\n            root.setLeft(removeHelper(key,root.getLeft()));\n        } else if (res<0) {\n            root.setRight(removeHelper(key,root.getRight()));\n        }else{\n            //恰好是这个节点需要删除\n            V val=root.getValue();\n            if (root.getLeft()==null){\n                root=root.getRight();\n            }else if (root.getRight()==null){\n                root=root.getLeft();\n            }else{\n                //找到右子树中最大的节点\n                BinNode<K, V> min = findMin(root);\n                root.setKey(min.getKey());\n                root.setValue(min.getValue());\n                root.setRight(min);\n            }\n        }\n        return root;\n    }\n\n    private void deleteMaxHelper(BinNode<K,V> root){\n        if (root==null) return;\n        if (root.getRight()==null) return;\n        if (root.getRight().getRight()==null){\n            root.getRight().setRight(null);\n        }else{\n            deleteMaxHelper(root.getRight());\n        }\n    }\n    @Override\n    public V search(K key) {\n        if (key==null) {\n            try {\n                throw new Exception(\"key is null.\");\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n        return searchHelper(key,root);\n    }\n\n    private V searchHelper(K key, BinNode<K,V> root){\n        if (root==null) return null;\n        int res=root.getKey().compareTo(key);\n        if (res==0) return root.getValue();\n        else if (res>0) return searchHelper(key,root.getLeft());\n        else return searchHelper(key,root.getRight());\n    }\n\n    @Override\n    public boolean update(K key, V value) {\n        if (key==null) {\n            try {\n                throw new Exception(\"key is null.\");\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return false;\n        }\n        return updateHelper(key,value,root);\n    }\n\n    private boolean updateHelper(K key, V value, BinNode<K,V> root){\n        if (root==null) return false;\n        int res=root.getKey().compareTo(key);\n        if (res==0) {\n            root.setValue(value);\n            return true;\n        }else if (res>0) return updateHelper(key,value,root.getLeft());\n        else return updateHelper(key,value,root.getRight());\n    }\n    @Override\n    public boolean isEmpty() {\n        return root==null;\n    }\n\n    @Override\n    public void clear() {\n        root=null;\n    }\n\n    @Override\n    public void travelPrev() {\n        travelPrev(root);\n    }\n\n    private void travelPrev(BinNode<K,V> root){\n        System.out.println(\"先序遍历\");\n        if (root==null) return;\n        System.out.print(root);\n        travelPrev(root.getLeft());\n        travelPrev(root.getRight());\n    }\n\n    @Override\n    public void travelMid() {\n        travelMid(root);\n    }\n    private void travelMid(BinNode<K,V> root){\n//        System.out.println(\"中序遍历\");\n        if (root==null) return;\n        travelMid(root.getLeft());\n        System.out.print(root);\n        travelMid(root.getRight());\n    }\n\n    @Override\n    public void travelLast() {\n\n        travelLast(root);\n    }\n\n    private void travelLast(BinNode<K,V> root){\n        System.out.println(\"后序遍历\");\n        if (root==null) return;\n        travelLast(root.getLeft());\n        travelLast(root.getRight());\n        System.out.print(root);\n    }\n\n    @Override//层序遍历，也就是广度优先遍历\n    public void travel() {\n        System.out.println(\"层序遍历\");\n        Map<Integer, List<BinNode<K,V>>> map=new HashMap();\n        class MyQueue{\n            class BinNodeWithLevel{\n                int level;\n                BinNode<K,V> binNode;\n                BinNodeWithLevel next;\n                BinNodeWithLevel(int level,BinNode<K,V> binNode,BinNodeWithLevel next){\n                    this.level=level;\n                    this.binNode=binNode;\n                    this.next=next;\n                }\n            }\n            int size;\n            BinNodeWithLevel top;\n            MyQueue(){\n                top=null;\n                size=0;\n            }\n            public void push(int level,BinNode<K,V> node){\n                top=new BinNodeWithLevel(level,node,top);\n                size++;\n            }\n            public BinNodeWithLevel pop(){\n                if (this.isEmpty()) return null;\n                BinNodeWithLevel res=top;\n                top=top.next;\n                size--;\n                return res;\n            }\n            public boolean isEmpty(){\n                return size==0;\n            }\n        }\n        MyQueue queue=new MyQueue();\n        queue.push(0,root);\n        while (!queue.isEmpty()){\n            MyQueue.BinNodeWithLevel pop = queue.pop();\n            int level=pop.level;\n            BinNode<K,V> node=pop.binNode;\n            List<BinNode<K,V>> list=map.get(level);\n            if (list==null){\n                list=new LinkedList<>();\n                list.add(node);\n                map.put(level,list);\n            }else{\n                list.add(node);\n            }\n            System.out.print(node);\n            if (node.getLeft()!=null) queue.push(level+1,node.getLeft());\n            if (node.getRight()!=null) queue.push(level+1,node.getRight());\n        }\n        System.out.print(map);\n    }\n}\n```\n完美解决！\n\n# AVL树\n\n![](树/Untitled%207.png)\n\n查找效率提高\n\n将二叉检索树转变为AVL树\n\n![](树/Untitled%208.png)\n\n![](树/Untitled%209.png)\n\n![](树/Untitled%2010.png)\n\n**在插入和删除节点时会出现失衡**\n\n- **插入**\n\n  - LL型\n\n  ![](树/Untitled%2011.png)\n\n  - LR型\n\n  ![](树/Untitled%2012.png)\n\n  1. 先对root的左子树进行一个左旋\n\n     ![](树/Untitled%2013.png)\n\n     ![](树/Untitled%2014.png)\n\n  2. 对roo右旋\n\n     ![](树/Untitled%2015.png)\n\n  - RR型\n\n    ![](树/Untitled%2016.png)\n\n  - RL型\n\n    1. 先对root的右子树进行一个右旋\n\n    ![](树/Untitled%2017.png)\n\n    ![](树/Untitled%2018.png)\n\n    1. 对root进行左旋\n\n    ![](树/Untitled%2019.png)\n\n  **删除基本相同，删除后判断是哪种类型，进行相应处理**","categories":["算法","数据结构","树"]},{"title":"算法渐进分析","url":"/2024/08/04/算法渐进分析/","content":"\n# 三个符号\n\n$O(n)$:上界。相当于\"<=”\n\n![](./算法渐进分析/Untitled.png)\n\n$o(n)$:非紧的上界。相当于\"<”\n\n![](./算法渐进分析/Untitled%201.png)\n\n$Ω(n)$:下界。相当于\">=”\n\n![](./算法渐进分析/Untitled%202.png)\n\n$w(n)$:非紧的下界。 相当于\">”\n\n![](./算法渐进分析/Untitled%203.png)\n\n$θ(n)$:紧确界。相当于\"=”\n\n![](./算法渐进分析/Untitled%204.png)\n\n注解：渐近非负的意思是“当n趋于无穷大时，f(n)和g(n)都非负”。\n\n- 如果$f(n)=Θ(g(n))$,则$f(n)=O(g(n))$且$f(n)=Ω(g(n))$。\n- 如果$f(n)=o(g(n))$,则$f(n)=O(g(n))$。\n- 如果$f(n)=ω(g(n))$，则$f(n)=Ω(g(n))$。\n\n[参考](https://blog.csdn.net/gaoxiangnumber1/article/details/45066841)\n\n## 用集合描述\n\n$f(n)∈ O(g(n))$\n\n举例：\n\n![](./算法渐进分析/Untitled%205.png)\n\n如果$f(n)=O(g(n))$,则要么是$f(n)=o(g(n))$，要么是$f(n)=Θ(g(n))$。\n\n## 性质（没啥用）\n\n1. 传递性：一条链上的都是同一个符号\n\n![](./算法渐进分析/Untitled%206.png)\n\n2. 自反性：带等号的\n\n![](./算法渐进分析/Untitled%207.png)\n\n3. 对称性\n\n![](./算法渐进分析/Untitled%208.png)\n\n4. 单调性\n\n![](./算法渐进分析/Untitled%209.png)\n\n5. 多部份决策：通俗点来说来说就是当算法由两个连续执行部分组成时，该算法的整体效率由具有较大增长次数的那部分所决定，即效率较差的部分决定。\n\n![](./算法渐进分析/Untitled%2010.png)\n\n## 例题\n\n![](./算法渐进分析/Untitled%2011.png)","categories":["算法","基础知识"]},{"title":"网络安全大作业","url":"/2024/08/03/网络安全大作业/","content":"{% pdf 安全通信软件的设计与实现.pdf %} ","categories":["课程学习","网络信息安全"]},{"title":"计算机网络课程设计","url":"/2024/08/03/计算机网络课程设计/","content":"{% pdf 计算机网络课程设计项目报告.pdf %} \n","categories":["课程学习","计算机网络"]},{"title":"算法刷题记录DAY1","url":"/2024/08/03/算法刷题记录DAY1/","content":"\n先从暴力开始吧\n\n# 暴力\n\n## 三角形\n\n![](./算法刷题记录DAY1/qq_pic_merged_1717912944477.jpg)\n\n这个暴力就行\n\n```cpp\n#include<stdio.h>\nint max(int a,int b){\n\treturn a>b?a:b;\n}\nint check(int a,int b,int c){\n\tif(a+b>c&&a+c>b&&b+c>a) return 1;\n\treturn 0;\n}\nint main(){\n\tint ans=0;\n\tint n;\n\tscanf(\"%d\",&n);\n\tint len[n];\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&len[i]);\n\t}\n\tfor(int i=0;i<n-2;i++){\n\t\tfor(int j=i+1;j<n-1;j++){\n\t\t\tfor(int k=j+1;k<n;k++){\n\t\t\t\tif(check(len[i],len[j],len[k]){\n\t\t\t\t\tans=max(ans,len[i]+len[j]+len[k]);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n\n下面这个有技巧：\n\n## Ants\n\n题目链接：[1852 -- Ants (poj.org)](http://poj.org/problem?id=1852)\n\n![](./算法刷题记录DAY1/qq_pic_merged_1717913392418.jpg)\n\n题目中说的不能交错通过，相遇之后会各自反向，这和相遇之后不改变方向的情况的时间是一样的，所以只需要扫描一遍。\n\n```c\n#include<stdio.h>\nint max(int a,int b){\n    return a>b?a:b;\n}\nint min(int a,int b){\n    return a<b?a:b;\n}\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    int len,t;\n    int x;\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&len,&t);\n        int mid=len/2;\n        int mn=0,mx=0;\n        for(int j=0;j<t;j++){\n            scanf(\"%d\",&x);\n            if(x>mid){\n                mn=max(mn,len-x);\n                mx=max(mx,x);\n            }else{\n                mn=max(mn,x);\n                mx=max(mx,len-x);\n            }\n        }\n        printf(\"%d %d\\n\",mn,mx);\n    }\n    return 0;\n}\n```\n\n## 抽签\n\n![](./算法刷题记录%20DAY1_pic_merged_1717913706542.jpg)\n\n这题直接暴力：\n\n![](./算法刷题记录%20DAY1_pic_merged_1717913813520.jpg)\n\n$$\n进阶：n的限制条件改为1\\leq n \\leq 1000\n$$\n\n解法：二分搜索\n\n先排好序，然后查找m-ka-kb-kc(假设为x)，查找数组中间的元素\n\n- 如果它比x小，x只能在后半段\n- 如果它比x大，x只能在前半段\n\n$$\n总时间复杂度：O(n^3logn)\n$$\n\n```cpp\n//二分查找方法\nbool binary_search(vector<int> nums,int target){\n\tint l=0,r=nums.size()-1;\n\twhile(l<=r){\n\t\tint mid=l+(r-l)/2;\n\t\tint com=nums[mid]-target;\n\t\tif(com==0) return true;\n\t\telse if(com>0){\n\t\t\tr=mid-1;\n\t\t}else{\n\t\t\tl=mid+1;\n\t\t}\n\t}\n\treturn false;\n}\n```\n\n这样的时间复杂度还是太大，继续改进\n\n先枚举出$kc+kd$，然后寻找$kc+kd=m-ka-kb$\n\n时间复杂度： $排序O(n^2logn)+循环O(n^2logn)$\n\n![](./算法刷题记录%20DAY1_pic_merged_1717914931937.jpg)\n\n![](./算法刷题记录%20DAY1_pic_merged_1717914879578.jpg)\n\n## 二进制枚举法\n\n使用二进制与位运算\n\n![](./算法刷题记录%20DAY1_pic_merged_1717916148154.jpg)\n\n```c\ntypedef long long ll;\nint a[MAX_N];\nint n,k;\nvoid solve(){\n\tll mask=1<<n;\n\tfor(ll i=1;i<mask;i++){\n\t\tll t=i;\n\t\tint m=0;\n\t\tint sum=0;\n\t\twhile(t){\n\t\t\tif(t&1) sum+=a[m];\n\t\t\tm++;\n\t\t\tt>>1;\n\t\t}\n\t\tif(sum==k){\n\t\t\tprintf(\"Yes\\n\");\n\t\t}\n\t}\n\tprintf(\"No\\n\");\n}\n```\n\n也可以用DFS（回溯法）\n\n```c\nint a[MAX_N];\nint n,k;\n\nbool dfs(int index,int sum){\n\tif(i==n) return sum==k;\n\tif(dfs(i+1,sum)) return true;\n\tif(dfs(i+1,sum+a[i])) return true;\n\treturn false;\n}\nvoid solve(){\n\tif(dfs(0,0)) printf(\"Yes\\n\");\n\telse printf(\"No\\n\");\n}\n```\n\n## DFS\n### 连通域判断\n![](./算法刷题记录%20DAY1_pic_merged_1717939197339.jpg)\n\n```c\n#include<stdio.h>\nchar map[101][101];\nint m;\nint n;\nvoid dfs(int x,int y){\n\tmap[x][y]='.';\n\tfor(int dx=-1;dx<=1;dx++){\n\t\tfor(int dy=-1;dy<=1;dy++){\n\t\t\tint nx=x+dx;\n\t\t\tint ny=y+dy;\n\t\t\tif(nx>=0&&nx<n&&ny>=0&&ny<m&&map[nx][ny]=='W'){\n\t\t\t\tdfs(nx,ny);\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%s\",map[i]);\n\t}\n\tint ans=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(map[i][j]=='W'){\n\t\t\t\tdfs(i,j);\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n\n\n还有道力扣：\n### 字母迷宫\n![](./算法刷题记录DAY1/Untitled.png)\n![](./算法刷题记录DAY1/Untitled%201.png)\n\n```cpp\n#include<vector>\n#include<string>\nusing namespace std;\nclass Solution {\npublic:\n    bool wordPuzzle(vector<vector<char>>& grid, string target) {\n        vector<vector<bool>> used(grid.size(),vector<bool>(grid[0].size(),false));\n        for(int i=0;i<grid.size();i++){\n            for(int j=0;j<grid[i].size();j++){\n                used[i][j]=true;\n                if(dfs(grid,target,0,i,j,used)) return true;\n                used[i][j]=false;\n            }\n        }\n        return false;\n    }\n    int dirx[4]={-1,0,0,1};\n    int diry[4]={0,1,-1,0};\n    bool dfs(vector<vector<char>>& grid,string target,int index,int x,int y,vector<vector<bool>> used){\n        if(index==target.length()-1) \n            return target.at(index)==grid[x][y];\n        if(target.at(index)!=grid[x][y]) return false;\n        for(int i=0;i<4;i++){\n            int nx=x+dirx[i];\n            int ny=y+diry[i];\n            if(nx>=0&&nx<grid.size()&&ny>=0&&ny<grid[0].size()&&used[nx][ny]==false){\n                used[nx][ny]=true;\n                bool res=dfs(grid,target,index+1,nx,ny,used);\n                used[nx][ny]=false;\n                if(res) return true;\n            }\n        }\n        return false;\n    }\n};\n```\n\n这里有一个大佬的解：\n\n```cpp\nclass Solution {\npublic:\n    bool exist(vector<vector<char>>& board, string word) {\n        int rows = board.size(), cols = board[0].size();\n\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++) {\n                if (board[r][c] == word[0] && dfs(board, word, 0, r, c)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    bool dfs(vector<vector<char>>& board, string& word, int index, int row, int col) {\n        if (index == word.size()) {\n            return true;\n        }\n\n        if (row < 0 || col < 0 || row >= board.size() || col >= board[0].size()) {\n            return false;\n        }\n\n        if (board[row][col] != word[index]) {\n            return false;\n        }\n    \n        auto board_val = board[row][col];\n        board[row][col] = '0';//用当前数组代替了used\n        bool result = dfs(board, word, index + 1, row - 1, col);\n        result = result || dfs(board, word, index + 1, row + 1, col);\n        result = result || dfs(board, word, index + 1, row, col - 1);\n        result = result || dfs(board, word, index + 1, row, col + 1);\n        board[row][col] = board_val;\n\n        return result;\n    }\n};\n```\n\n### 二叉树\n![](./算法刷题记录DAY1/Untitled%202.png)\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n#include<string>\n#include<vector>\n#include<stack>\nclass Solution {\npublic:\n    vector<string> ans;\n    vector<string> binaryTreePaths(TreeNode* root) {\n        vector<int> stk;\n        stk.push_back(root->val);\n        dfs(root,stk);\n        return ans;\n    }\n    void dfs(TreeNode* root, vector<int>& stk){\n        if(isleaf(root)!=0){\n            ans.push_back(copy(stk));\n            return;\n        }\n        if(root->left==nullptr){\n            stk.push_back(root->right->val);\n            dfs(root->right,stk);\n            stk.pop_back();\n        }else if(root->right==nullptr){\n            stk.push_back(root->left->val);\n            dfs(root->left,stk);\n            stk.pop_back();\n        }else {\n            stk.push_back(root->left->val);\n            dfs(root->left,stk);\n            stk.pop_back();\n\n            stk.push_back(root->right->val);\n            dfs(root->right,stk);\n            stk.pop_back();\n        }\n    }\n    string copy(vector<int>& stk){\n        string ans=\"\";\n        for(int i=0;i<stk.size();i++){\n            if(i!=0) ans+=\"->\";\n            ans+=to_string(stk[i]);\n        }\n        return ans;\n    }\n    int isleaf(TreeNode* root){\n        if(root==nullptr) return -1;\n        if(root->right==nullptr&&root->left==nullptr) return 1;\n        return 0;\n    }\n    \n};\n```\n\n## BFS\n\n### 迷宫\n\n![](./算法刷题记录DAY1/Untitled.jpeg)\n\n![](./算法刷题记录DAY1/Untitled%201.jpeg)\n\n![](./算法刷题记录DAY1/Untitled%202.jpeg)\n\n\n### 二叉树层序遍历\n\n![](./算法刷题记录DAY1/Untitled%204.png)\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\n#include<vector>\n#include<queue>\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> ans;\n        queue<pair<int,TreeNode*>> q;\n        if(root==nullptr) return ans;\n        q.push(make_pair(0,root));\n        while(q.size()){\n            pair<int,TreeNode*> t=q.front();q.pop();\n            int level=t.first;\n            TreeNode* node=t.second;\n            if(level<ans.size()){\n                ans[level].push_back(node->val);\n            }else{\n                vector<int> next(1,node->val);\n                ans.push_back(next);\n            }\n            if(node->left!=nullptr){\n                q.push(make_pair(level+1,node->left));\n            }\n            if(node->right!=nullptr){\n                q.push(make_pair(level+1,node->right));\n            }\n        }\n        return ans;\n    }\n};\n```\n\n### N叉树层序遍历\n\n![](./算法刷题记录DAY1/Untitled%205.png)\n\n![](./算法刷题记录DAY1/Untitled%206.png)\n\n```cpp\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n#include<queue>\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(Node* root) {\n        vector<vector<int>> ans;\n        queue<pair<int,Node*>> q;\n        if(root==nullptr) return ans;\n        q.push(make_pair(0,root));\n        while(q.size()){\n            pair<int,Node*> t=q.front();q.pop();\n            int level=t.first;\n            Node* node=t.second;\n            if(level<ans.size()){\n                ans[level].push_back(node->val);\n            }else{\n                vector<int> next(1,node->val);\n                ans.push_back(next);\n            }\n            vector<Node*> cld=node->children;\n            for(int i=0;i<cld.size();i++){\n                if(cld[i]!=nullptr){\n                    q.push(make_pair(level+1,cld[i]));\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n# 贪心\n## 心算挑战\n![](./算法刷题记录DAY1/Untitled%207.png)\n\n这题一开始没想到：\n\n**排序先取最大的cnt个数，如果它们的和是偶数直接输出，不然就找一个已取的最小的奇数换成剩下未取的最大的偶数，或者找一个已取的最小的偶数换成剩下未取的最大奇数**\n\n看看大佬答案：\n\n```cpp\nclass Solution {\npublic:\n    int maxmiumScore(vector<int>& cards, int cnt) {\n        sort(cards.begin(), cards.end(), greater<int>());\n        int res = 0, lastodd = 0, lasteven = 0;\n        for (int i = 0; i < cnt; i++)\n        {\n            res += cards[i];\n            if (cards[i] % 2 == 1) lastodd = cards[i];\n            else lasteven = cards[i];\n        }\n        if (res % 2 == 0) return res;\n\n        int max1 = 0, max2 = 0;\n        for (int i = cnt; i < cards.size(); i++)\n        {\n            if (lasteven && max1 == 0 && cards[i]%2) max1 = res - lasteven + cards[i];\n            if (lastodd && max2 == 0 && cards[i]%2 == 0) max2 = res - lastodd + cards[i];\n        }\n        return max(max1, max2);\n    }\n};\n```\n## 硬币问题\n![](./算法刷题记录%20DAY1_pic_merged_1718006386488.jpg)\n\n优先使用大面值的硬币：\n\n```cpp\nconst int V[6]={1, 5, 10, 50, 100, 500};\nint C[6];//\nint A;\n\nvoid solve(){\n\tint ans=0;\n\tfor(int i=5;i>=0;i++){\n\t\tint t = min(A/V[i], C[i]);\n\t\tA -= t*V[i];\n\t\tans+=t;\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n}\n```\n## 字典序最小\n![](./算法刷题记录%20DAY1_pic_merged_1718006622569.jpg)\n\n![](./算法刷题记录%20DAY1_pic_merged_1718006677452.jpg)\n\n![](./算法刷题记录%20DAY1_pic_merged_1718006696584.jpg)\n\n![](./算法刷题记录%20DAY1_pic_merged_1718006711202.jpg)\n\n## 哈夫曼编码\n\n![](./算法刷题记录%20DAY1_pic_merged_1718006911989.jpg)\n\n```cpp\n#include<iostream>\n#include <queue>\n#include<vector>\nusing namespace std;\ntypedef long long ll;//开ll才不会溢出\nint main(){\n    priority_queue<ll,vector<ll>,greater<ll> > q;\n    int n;\n    cin>>n;\n    ll x;\n    for(int i=0;i<n;i++){\n        cin>>x;\n        q.push(x);\n    }\n    ll ans=0;\n    while(q.size()>1){\n        // ans+=q.front();\n        ll y1=q.top();\n        q.pop();\n        ll y2=q.top();\n        q.pop();\n        ans+=(y1+y2);\n        q.push(y1+y2);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n```\n\n动态规划先不看\n\n先看数学：\n# 数学\n## 辗转相除法\n\n![](./算法刷题记录%20DAY1_pic_merged_1718008211277.jpg)\n\n鬼能看出这题是求最大公约数\n\n$$\n答案就是|x_1-x_2|和|y_1-y2|的最大公约数-1！！！！\n$$\n\n现在问题来到计算最大公约数：\n\n### 辗转相除法\n\n```cpp\nint gcd(int a, int b) {\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\n```\n\n$$\n时间复杂度：O(log max(a,b))以内\n$$\n\n还有一些比较低效的方法：https://blog.csdn.net/Brilliance_panpan/article/details/88372432\n\n### 扩展欧几里得算法\n\n$$\n求整数x和y使得ax+by=1\n$$\n\n可以发现，如果gcd(a,b)不等于1，无解；如果gcd(a,b)=1,就可以通过扩展原来的辗转相除法来求解。事实上，一定存在整数对（x,y）使得ax+by=gcd(a,b)。\n\n![](./算法刷题记录DAY1/Untitled%208.png)\n\n代码：\n\n```cpp\nint extgcd(int a,int b,int& x,int& y){\n\tint d=a;\n\tif(b){\n\t\td=extgcd(b,a%b,y,x);\n\t\ty-=(a/b)*x;\n\t}else{\n\t\tx=1;y=0;\n\t}\n\treturn d;\n}\n```\n\n## 素数\n\n### 素性检验\n\n$$\n给定整数n，判断n是不是素数(1\\leq n \\leq 10^9)\n$$\n\n想到的最直接的方法就是从2到n-1遍历，能整除就不是素数，但是时间复杂度太大；实际上我们只需要检查2~根号n的整数就可以。\n\n```cpp\nint n;\nvoid solve(){\n\tif(n==2){\n\t\tprintf(\"Yes\\n\");\n\t\treturn;\n\t}\n\tfor(int i=2;i*i<=n;i++){\n\t\tif(n%i==0){\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tprintf(\"Yes\\n\");\n}\n```\n\n$$\n给定整数n,请问n以内有多少个素数？（n \\leq 10^6）\n$$\n\n### 埃氏筛法\n\n首先把2到n范围内的所有整数谢下来，最小的数组2是素数，将表中所有2的倍数划去，然后是3（素数），将3的倍数全部划去，以此类推。\n\n![](./算法刷题记录%20DAY1_pic_merged_1718012475501.jpg)\n\n\n![](./算法刷题记录DAY1/Untitled%2015.png)\n\n```cpp\n#include<vector>\nclass Solution {\npublic:\n    int countPrimes(int n) {\n        if(n<2) return 0;\n        vector<bool> isPrime(n,true);\n        isPrime[0]=false;\n        isPrime[1]=false;\n        int ans=0;\n        for(int i=2;i<n;i++){\n            if(isPrime[i]){\n                ans++;\n                if(2*i<n){\n                    for(int j=2*i;j<n;j+=i){\n                        isPrime[j]=false;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n### 区间筛法\n\n![](./算法刷题记录%20DAY1_pic_merged_1718012639631.jpg)\n\n![](./算法刷题记录%20DAY1_pic_merged_1718012675564.jpg)\n\n![](./算法刷题记录%20DAY1_pic_merged_1718012812983.jpg)\n\n### 快速幂运算\n\n![](./算法刷题记录%20DAY1_pic_merged_1718012862839.jpg)\n\n思路：\n\n![](./算法刷题记录%20DAY1_pic_merged_1718013054084.jpg)\n\n代码1：\n\n![](./算法刷题记录%20DAY1_pic_merged_1718013072543.jpg)\n\n代码2（递归）：\n\n![](./算法刷题记录%20DAY1_pic_merged_1718013088936.jpg)\n\n# 贪心\n## 救生艇\n![](./算法刷题记录DAY1/Untitled%209.png)\n\n思路：先把people排序，每次均从头和从尾各选取一个人凑在一条船上，能凑上就凑，凑不上就放大的。\n\n```cpp\n#include<vector>\n#include<algorithm>\nclass Solution {\npublic:\n    int numRescueBoats(vector<int>& people, int limit) {\n        sort(people.begin(),people.end());//从小到大排序\n        int ans=0;\n        int pbig=people.size()-1;\n        int psml=0;\n        while(pbig>psml){\n            int big=people[pbig];\n            int small=people[psml];\n            if(big+small<=limit) {\n                ans++;\n                psml++;\n                pbig--;\n            }\n            else{\n                ans++;\n                pbig--;\n            }\n        }\n        if(pbig==psml) ans++;\n        return ans;\n    }\n};\n```\n## 最大数\n![](./算法刷题记录DAY1/Untitled%2010.png)\n\n![](./算法刷题记录DAY1/Untitled%2011.png)\n\n```cpp\n#include <vector>\n#include <algorithm>\ntypedef unsigned long long ll;\nll pingjie(ll a, ll b)\n{\n    ll x = b;\n    if (x == 0)\n        return a * 10;\n    while (x > 0)\n    {\n        a = a * 10;\n        x /= 10;\n    }\n    a += b;\n    return a;\n}\nbool cmp(int a, int b)\n{\n    ll ab = pingjie(a, b);\n    ll ba = pingjie(b, a);\n    return ab > ba;\n}\n\nclass Solution\n{\npublic:\n    string largestNumber(vector<int> &nums)\n    {\n        sort(nums.begin(), nums.end(), cmp);\n        if(nums[0]==0) return \"0\";\n        string ans;\n        for (int i = 0; i < nums.size(); i++)\n        {\n            ans += to_string(nums[i]);\n        }\n        return ans;\n    }\n};\n```\n\n可以优化比较方法：c++中，sort中自定义的比较函数可以直接用字符串比较\n\n```cpp\nsort(nums.begin(), nums.end(), [](const int &x, const int &y) {\n\treturn to_string(x) + to_string(y) > to_string(y) + to_string(x);\n});\n```\n## 加油站\n![](./算法刷题记录DAY1/Untitled%2012.png)\n\n![](./算法刷题记录DAY1/Untitled%2013.png)\n\n```cpp\n/*\n\t这题一开始暴力，没有优化，TLK了，后面看了答案优化了过了。\n\t**关键点：我们首先检查第 000 个加油站，并试图判断能否环绕一周；\n\t\t\t\t\t如果不能，就从第一个无法到达的加油站开始继续检查。**\n*/\n#include<vector>\n#include<set>\nclass Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int n=gas.size();\n        set<int> st;\n        int begin_index=-1;\n        for(int i=0;i<gas.size();i++){\n            if(gas[i]-cost[i]>=0) {\n                begin_index=i;\n                break;\n            }\n        }\n        if(begin_index==-1) return -1;\n        int bugindex=-1;\n        st.insert(begin_index);\n        for(;begin_index<n;){\n            int total=gas[begin_index]-cost[begin_index];\n            for(int j=(begin_index+1)%n;j!=begin_index;j=(j+1)%n){\n                total+=(gas[j]-cost[j]);\n                if(total<0) {\n                    bugindex=j;\n                    break;\n                }\n            }\n            if(total>=0) return begin_index;\n            else{\n                int k;\n                for(k=bugindex;;k=(k+1)%n){\n                    if(gas[k]>=cost[k]) {\n                        break;\n                    }\n                }\n                begin_index=k;\n                if(st.count(begin_index)) return -1;\n                else st.insert(begin_index);\n            }\n        }\n        return -1;\n    }\n};\n```\n\n## 经典跳跃游戏\n\n初级版\n\n![](./算法刷题记录DAY1/Untitled%2014.png)\n\n```cpp\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int maxindex=0;\n        for(int i=0;i<=maxindex&&i<nums.size();i++){\n            maxindex=max(maxindex,i+nums[i]);\n        }\n        return maxindex>=nums.size()-1;\n    }\n};\n```\n\n# 动态规划\n## 最小路径和\n![](./算法刷题记录DAY1/Untitled%2016.png)\n\n```cpp\nclass Solution {\npublic:\n    int dp[201][201];\n    int minimumTotal(vector<vector<int>>& triangle) {\n        memset(dp,-1,sizeof dp);\n        dp[0][0]=triangle[0][0];\n        for(int i=1;i<triangle.size();i++){\n            for(int j=0;j<=i;j++){\n                if(i==j){\n                    dp[i][j]=dp[i-1][j-1]+triangle[i][j];\n                }else if(j==0){\n                    dp[i][j]=dp[i-1][j]+triangle[i][j];\n                }else{\n                    dp[i][j]=min(dp[i-1][j-1],dp[i-1][j])+triangle[i][j];\n                }\n            }\n        }\n        int min=dp[triangle.size()-1][0];\n        for(int i=1;i<triangle.size();i++){\n            if(min>dp[triangle.size()-1][i])\n                min=dp[triangle.size()-1][i];\n        }\n        return min;\n    }\n};\n```\n\n**压缩后：**\n\n```cpp\nclass Solution {\npublic:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        int n = triangle.size();\n        vector<vector<int>> f(2, vector<int>(n));\n        f[0][0] = triangle[0][0];\n        for (int i = 1; i < n; ++i) {\n            int curr = i % 2;\n            int prev = 1 - curr;\n            f[curr][0] = f[prev][0] + triangle[i][0];\n            for (int j = 1; j < i; ++j) {\n                f[curr][j] = min(f[prev][j - 1], f[prev][j]) + triangle[i][j];\n            }\n            f[curr][i] = f[prev][i - 1] + triangle[i][i];\n        }\n        return *min_element(f[(n - 1) % 2].begin(), f[(n - 1) % 2].end());\n    }\n};\n\n// 作者：力扣官方题解\n// 链接：https://leetcode.cn/problems/IlPe0q/solutions/1036365/san-jiao-xing-zhong-zui-xiao-lu-jing-zhi-srun/\n// 来源：力扣（LeetCode）\n// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n## leetcode 2849\n![](./算法刷题记录DAY1/Untitled%2017.png)\n\n![](./算法刷题记录DAY1/Untitled%2018.png)\n\n题解：\n\n![](./算法刷题记录DAY1/Untitled%2019.png)\n\n```cpp\nclass Solution {\npublic:\n    bool isReachableAtTime(int sx, int sy, int fx, int fy, int t) {\n        if(sx==fx&&sy==fy) return t!=1;\n        return t>=max(abs(sx-fx),abs(sy-fy));\n    }\n};\n```\n## 分糖果I\n![](./算法刷题记录DAY1/Untitled%2020.png)\n\n```cpp\nclass Solution {\npublic:\n    int distributeCandies(int n, int limit) {\n        int ans=0;\n        for(int i=0;i<=limit;i++){\n            for(int j=0;j<=n-i&&j<=limit;j++){\n                if(n-i-j<=limit) ans++;\n            }\n        }\n        return ans;\n    }\n};\n```\n## 分糖果II\n![](./算法刷题记录DAY1/Untitled%2021.png)\n\n```cpp\nclass Solution {\npublic:\n    long long distributeCandies(int n, int limit) {\n        if(limit<n/3) return 0;\n        long long ans=0;\n        for(int i=max(0,n-2*limit);i<=limit&&n-i>=0;i++){\n            int k=n-i;\n            if(k<limit) ans+=k+1;\n            else ans+=limit-(k-limit)+1;\n        }\n        return ans;\n    }\n};\n```\n# 杂题\n## 删除重复项\n![](./算法刷题记录DAY1/Untitled%2022.png)\n\n![](./算法刷题记录DAY1/Untitled%2023.png)\n\n```cpp\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int n=nums.size();\n        int cnt=0;\n        for(int i=0;i<n;i++){\n            if(i>0&& nums[i]!=nums[i-1]) cnt=1;\n            else cnt++;\n            if(cnt==3){\n                remove(nums,i,n);\n                n--;\n                cnt--;\n                i--;\n            }\n        }\n        return n;\n    }\n    void remove(vector<int>& nums,int index,int end){\n        for(int i=index;i<end-1;i++){\n            nums[i]=nums[i+1];\n        }\n    }\n};\n```","categories":["算法"]},{"title":"排序算法","url":"/2024/08/01/排序算法/","content":"\n> **排序是指重新排列列表中的元素，使表中的元素按照关键字有序的过程**\n\n# 分类\n\n- 按照稳定性分类\n  \n  ![](./排序算法/Untitled.png)\n    \n- 内部排序与外部排序\n    - 内部排序：数据都在内存中（考虑时间复杂度和空间复杂度）\n    - 外部排序：数据太多，无法全部放入内存（还需要考虑读写磁盘次数）\n\n**[可视化]([Comparison Sorting Visualization (usfca.edu)](https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html))**\n\n# 插入排序（稳定的）\n\n算法思想：每次将一个待排序的记录按照其关键字大小插入到前面已经排行的子序列中，知道全部记录插入完成。\n\n```java\npublic static void insertSortAsc(int[] arr){\n    int n=arr.length;\n    int i,j;\n    for (i=1;i<n;i++){\n        if (arr[i]<arr[i-1]){\n            int temp=arr[i];\n            for (j=i-1;j>=0&&temp<arr[j];j--){\n                arr[j+1]=arr[j];\n            }\n            arr[j+1]=temp;\n        }\n    }\n}\n```\n\n> **代码思路：**从第二个元素开始遍历，当当前元素的关键字与前一个元素的关键字不满足规定的排序方式时，这个时候，当前元素要插入前面已经排好序的序列之中，操作如下：用一个变量存储当前元素，对于前面已经排好的序列中的元素，从后往前遍历，每遇到一个比需要插入的元素的关键字小（或大，更精确的描述应该是不满足规定的排序方式）的元素，就将该元素后移一格，直到遇到满足规定排序方式的元素，将暂存变量的值赋值给改元素后一个格子的位置。\n\n## review\n\n```java\npublic static void insertSort(Element[] elements){\n    int i,j;\n    for (i=1;i<elements.length;i++){\n        if (elements[i].getKey()<elements[i-1].getKey()){\n            Element tmp=elements[i];\n            for (j=i-1;j>=0&&elements[j].getKey()>tmp.getKey();j--){\n                elements[j+1]=elements[j];\n            }\n            elements[j+1]=tmp;\n        }\n    }\n}\n```\n\n# 选择排序（不稳定的）\n\n算法思想：每次从未排序好中的序列中选择一个关键字最大（最小）的元素放入到排序好序列的后面即可\n\n```java\n//不稳定的排序\npublic static void selectSort(Element[] elements){\n    int start=0;\n    for (;start<elements.length;start++){\n        int minIndex=start;\n        for (int i=start+1;i<elements.length;i++){\n            if (elements[i].getKey()<elements[minIndex].getKey()){\n                minIndex=i;\n            }\n        }\n        swap(elements,minIndex,start);\n    }\n}\n```\n\n# 冒泡排序（稳定的）\n\n算法思想：每迭代一轮都比较相邻俩元素大小，不满足排序规则则交换他们\n\n```java\n//稳定的排序\npublic static void bobbleSort(Element[] elements){\n    //从前往后冒泡,使得末尾的序列元素必然是排好的\n    for (int end=elements.length-1;end>=0;end--){\n        for (int i=0;i<end;i++){\n            if (elements[i].getKey()>elements[i+1].getKey()){\n                swap(elements,i,i+1);\n            }\n        }\n    }\n}\n```\n\n# 希尔排序\n\n算法思想：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录\"基本有序\"时，再对全体记录进行依次直接插入排序。\n\n大概意思就是，先等间隔分组，分好组后组内先排序，然后再等间隔分组（间隔减半），再组内排序，循环迭代，直到间隔为1并排行序号。\n\n利用的原理是，先分组排序，利用插入排序的优势：当序列较为有序时，算法效率高。\n\n```java\nprivate static void insertSortHelper(Element[] elements,int gap,int start){\n    int i,j;\n    for (i=start+gap;i<elements.length;i++){\n        if (elements[i].getKey()<elements[i-gap].getKey()){\n            Element tmp=elements[i];\n            for (j=i-gap;j>=0&&elements[j].getKey()>tmp.getKey();j=j-gap) {\n                elements[j+gap]=elements[j];\n            }\n            elements[j+gap]=tmp;\n        }\n    }\n}\n\npublic static void shellSort(Element[] elements){\n    int gap=elements.length/2;\n    while (gap>0){\n        for (int i = 0; i < gap ; i++) {\n            insertSortHelper(elements,gap,i);\n        }\n        gap/=5;\n    }\n}\n```\n\n# 归并排序\n\n算法思路：先分再合，分：等分序列；合：排序合并序列（使用双指针）\n\n![](./排序算法/Untitled%201.png)\n\n```java\nprivate static void integerite(Element[] elements,int left1,int right1,int left2,int right2){\n    int index1=left1;\n    int index2=left2;\n    int currIndex=left1;\n    while (currIndex<=right2){\n        int compare= 0;\n        if (index1>right1) compare=1;\n        else if (index2>right2) compare=-1;\n        else compare=elements[index1].getKey()-elements[index2].getKey();\n        if (compare>0){\n            elements[currIndex++]=elements[index2++];\n        } else {\n            elements[currIndex++]=elements[index1++];\n        }\n    }\n}\n\nprivate static void mergeSortHelper(Element[] elements,int left,int right){\n    if (left>=right) return;\n    int mid=(left+right)/2;\n    mergeSortHelper(elements,left,mid);\n    mergeSortHelper(elements,mid+1,right);\n    integerite(elements,left,mid,mid+1,right);\n}\n\npublic static void mergeSort(Element[] elements){\n    mergeSortHelper(elements,0,elements.length-1);\n}\n```\n\n时间复杂度分析：$O(nlogn)$\n\n# 快速排序\n\n算法思想：分治思想，取一个基准值，让比基准值小的放一边，比基准值大的放一边（双指针实现）。\n\n**一定要先移动右指针！！！**\n\n```cpp\nvoid Sort::quick_sort(vector<int> &nums) {\n    quick_sort_helper(nums,0,nums.size()-1);\n}\n\nvoid Sort::quick_sort_helper(vector<int> &nums,\n                             int start, int end) {\n    if (start>=end) return;\n    int pivot=nums[start];\n    int left=start;\n    int right=end;\n    while (left<right){\n        //先移动right\n        while (right>left&&nums[right]>=pivot){\n            right--;\n        }\n        while (right>left&&nums[left]<=pivot){\n            left++;\n        }\n        swap(nums[left],nums[right]);\n    }\n    nums[right]=pivot;\n    quick_sort_helper(nums,start,right-1);\n    quick_sort_helper(nums,right+1,end);\n}\n```","categories":["算法"]}]